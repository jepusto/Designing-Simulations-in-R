<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Designing Monte Carlo Simulations in R</title>
  <meta name="description" content="A text on designing, implementing, and reporting on Monte Carlo simulation studies" />
  <meta name="generator" content="bookdown #bookdown:version# and GitBook 2.6.7" />

  <meta property="og:title" content="Designing Monte Carlo Simulations in R" />
  <meta property="og:type" content="book" />
  
  <meta property="og:description" content="A text on designing, implementing, and reporting on Monte Carlo simulation studies" />
  <meta name="github-repo" content="jepusto/Designing-Simulations-in-R" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Designing Monte Carlo Simulations in R" />
  
  <meta name="twitter:description" content="A text on designing, implementing, and reporting on Monte Carlo simulation studies" />
  

<meta name="author" content="Luke W. Miratrix and James E. Pustejovsky (Equal authors)" />


<meta name="date" content="2025-07-02" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<!--bookdown:link_prev-->
<!--bookdown:link_next-->
<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<link href="libs/anchor-sections-1.1.0/anchor-sections.css" rel="stylesheet" />
<link href="libs/anchor-sections-1.1.0/anchor-sections-hash.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.1.0/anchor-sections.js"></script>
<script src="libs/kePrint-0.0.1/kePrint.js"></script>
<link href="libs/lightable-0.0.1/lightable.css" rel="stylesheet" />


<style type="text/css">
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<style type="text/css">
  
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
</style>
<style type="text/css">
/* Used with Pandoc 2.11+ new --citeproc when CSL is used */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



<!--bookdown:title:start-->
<div id="header">
<h1 class="title">Designing Monte Carlo Simulations in R</h1>
<p class="author"><em>Luke W. Miratrix and James E. Pustejovsky
(Equal authors)</em></p>
<p class="date"><em>2025-07-02</em></p>
</div>
<!--bookdown:title:end-->

<!--bookdown:toc:start-->
  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">
<!--bookdown:toc2:start-->
<ul>
<li><a href="#welcome" id="toc-welcome">Welcome</a>
<ul>
<li><a href="#license" id="toc-license">License</a></li>
<li><a href="#about-the-authors" id="toc-about-the-authors">About the authors</a></li>
<li><a href="#acknowledgements" id="toc-acknowledgements">Acknowledgements</a></li>
</ul></li>
<li><a href="#part-an-introductory-look" id="toc-part-an-introductory-look">(PART) An Introductory Look</a></li>
<li><a href="#introduction" id="toc-introduction"><span class="toc-section-number">1</span> Introduction</a>
<ul>
<li><a href="#some-of-simulations-many-uses" id="toc-some-of-simulations-many-uses"><span class="toc-section-number">1.1</span> Some of simulation’s many uses</a>
<ul>
<li><a href="#comparing-statistical-approaches" id="toc-comparing-statistical-approaches"><span class="toc-section-number">1.1.1</span> Comparing statistical approaches</a></li>
<li><a href="#assessing-performance-of-complex-pipelines" id="toc-assessing-performance-of-complex-pipelines"><span class="toc-section-number">1.1.2</span> Assessing performance of complex pipelines</a></li>
<li><a href="#assessing-performance-under-misspecification" id="toc-assessing-performance-under-misspecification"><span class="toc-section-number">1.1.3</span> Assessing performance under misspecification</a></li>
<li><a href="#assessing-the-finite-sample-performance-of-a-statistical-approach" id="toc-assessing-the-finite-sample-performance-of-a-statistical-approach"><span class="toc-section-number">1.1.4</span> Assessing the finite-sample performance of a statistical approach</a></li>
<li><a href="#conducting-power-analyses" id="toc-conducting-power-analyses"><span class="toc-section-number">1.1.5</span> Conducting Power Analyses</a></li>
<li><a href="#simulating-processess" id="toc-simulating-processess"><span class="toc-section-number">1.1.6</span> Simulating processess</a></li>
</ul></li>
<li><a href="#the-perils-of-simulation-as-evidence" id="toc-the-perils-of-simulation-as-evidence"><span class="toc-section-number">1.2</span> The perils of simulation as evidence</a></li>
<li><a href="#simulating-to-learn" id="toc-simulating-to-learn"><span class="toc-section-number">1.3</span> Simulating to learn</a></li>
<li><a href="#why-r" id="toc-why-r"><span class="toc-section-number">1.4</span> Why R?</a></li>
<li><a href="#organization-of-the-text" id="toc-organization-of-the-text"><span class="toc-section-number">1.5</span> Organization of the text</a></li>
</ul></li>
<li><a href="#programming-preliminaries" id="toc-programming-preliminaries"><span class="toc-section-number">2</span> Programming Preliminaries</a>
<ul>
<li><a href="#welcome-to-the-tidyverse" id="toc-welcome-to-the-tidyverse"><span class="toc-section-number">2.1</span> Welcome to the tidyverse</a></li>
<li><a href="#functions" id="toc-functions"><span class="toc-section-number">2.2</span> Functions</a>
<ul>
<li><a href="#rolling-your-own" id="toc-rolling-your-own"><span class="toc-section-number">2.2.1</span> Rolling your own</a></li>
<li><a href="#a-dangerous-function" id="toc-a-dangerous-function"><span class="toc-section-number">2.2.2</span> A dangerous function</a></li>
<li><a href="#using-named-arguments" id="toc-using-named-arguments"><span class="toc-section-number">2.2.3</span> Using Named Arguments</a></li>
<li><a href="#argument-defaults" id="toc-argument-defaults"><span class="toc-section-number">2.2.4</span> Argument Defaults</a></li>
<li><a href="#function-skeletons" id="toc-function-skeletons"><span class="toc-section-number">2.2.5</span> Function skeletons</a></li>
</ul></li>
<li><a href="#pipe-dreams" id="toc-pipe-dreams"><span class="toc-section-number">2.3</span> <code>\&gt;</code> (Pipe) dreams</a></li>
<li><a href="#recipes-versus-patterns" id="toc-recipes-versus-patterns"><span class="toc-section-number">2.4</span> Recipes versus Patterns</a></li>
<li><a href="#exercises" id="toc-exercises"><span class="toc-section-number">2.5</span> Exercises</a></li>
</ul></li>
<li><a href="#t-test-simulation" id="toc-t-test-simulation"><span class="toc-section-number">3</span> An initial simulation</a>
<ul>
<li><a href="#simulating-a-single-scenario" id="toc-simulating-a-single-scenario"><span class="toc-section-number">3.1</span> Simulating a single scenario</a></li>
<li><a href="#a-non-normal-population-distribution" id="toc-a-non-normal-population-distribution"><span class="toc-section-number">3.2</span> A non-normal population distribution</a></li>
<li><a href="#simulating-across-different-scenarios" id="toc-simulating-across-different-scenarios"><span class="toc-section-number">3.3</span> Simulating across different scenarios</a></li>
<li><a href="#extending-the-simulation-design" id="toc-extending-the-simulation-design"><span class="toc-section-number">3.4</span> Extending the simulation design</a></li>
<li><a href="#exercises-1" id="toc-exercises-1"><span class="toc-section-number">3.5</span> Exercises</a></li>
</ul></li>
<li><a href="#part-structure-and-mechanics-of-a-simulation-study" id="toc-part-structure-and-mechanics-of-a-simulation-study">(PART) Structure and Mechanics of a Simulation Study</a></li>
<li><a href="#simulation-structure" id="toc-simulation-structure"><span class="toc-section-number">4</span> Structure of a simulation study</a>
<ul>
<li><a href="#general-structure-of-a-simulation" id="toc-general-structure-of-a-simulation"><span class="toc-section-number">4.1</span> General structure of a simulation</a></li>
<li><a href="#tidy-modular-simulations" id="toc-tidy-modular-simulations"><span class="toc-section-number">4.2</span> Tidy, modular simulations</a></li>
<li><a href="#skeleton-of-a-simulation-study" id="toc-skeleton-of-a-simulation-study"><span class="toc-section-number">4.3</span> Skeleton of a simulation study</a>
<ul>
<li><a href="#data-generating-process" id="toc-data-generating-process"><span class="toc-section-number">4.3.1</span> Data-Generating Process</a></li>
<li><a href="#data-analysis-procedure" id="toc-data-analysis-procedure"><span class="toc-section-number">4.3.2</span> Data Analysis Procedure</a></li>
<li><a href="#repetition" id="toc-repetition"><span class="toc-section-number">4.3.3</span> Repetition</a></li>
<li><a href="#performance-summaries" id="toc-performance-summaries"><span class="toc-section-number">4.3.4</span> Performance summaries</a></li>
<li><a href="#multifactor-simulations" id="toc-multifactor-simulations"><span class="toc-section-number">4.3.5</span> Multifactor simulations</a></li>
</ul></li>
<li><a href="#exercises-2" id="toc-exercises-2"><span class="toc-section-number">4.4</span> Exercises</a></li>
</ul></li>
<li><a href="#case-ANOVA" id="toc-case-ANOVA"><span class="toc-section-number">5</span> Case Study: Heteroskedastic ANOVA</a>
<ul>
<li><a href="#case-anova-DGP" id="toc-case-anova-DGP"><span class="toc-section-number">5.1</span> The data-generating model</a>
<ul>
<li><a href="#now-make-a-function" id="toc-now-make-a-function"><span class="toc-section-number">5.1.1</span> Now make a function</a></li>
<li><a href="#cautious-coding" id="toc-cautious-coding"><span class="toc-section-number">5.1.2</span> Cautious coding</a></li>
</ul></li>
<li><a href="#the-hypothesis-testing-procedures" id="toc-the-hypothesis-testing-procedures"><span class="toc-section-number">5.2</span> The hypothesis testing procedures</a></li>
<li><a href="#running-the-simulation" id="toc-running-the-simulation"><span class="toc-section-number">5.3</span> Running the simulation</a></li>
<li><a href="#summarizing-test-performance" id="toc-summarizing-test-performance"><span class="toc-section-number">5.4</span> Summarizing test performance</a></li>
<li><a href="#exAnovaExercises" id="toc-exAnovaExercises"><span class="toc-section-number">5.5</span> Exercises</a></li>
</ul></li>
<li><a href="#data-generating-processes" id="toc-data-generating-processes"><span class="toc-section-number">6</span> Data-generating processes</a>
<ul>
<li><a href="#DGP-examples" id="toc-DGP-examples"><span class="toc-section-number">6.1</span> Examples</a>
<ul>
<li><a href="#ANOVA-example" id="toc-ANOVA-example"><span class="toc-section-number">6.1.1</span> Example 1: One-way analysis of variance</a></li>
<li><a href="#BVPois-example" id="toc-BVPois-example"><span class="toc-section-number">6.1.2</span> Example 2: Bivariate Poisson model</a></li>
<li><a href="#CRT-example" id="toc-CRT-example"><span class="toc-section-number">6.1.3</span> Example 3: Hierarchical linear model for a cluster-randomized trial</a></li>
</ul></li>
<li><a href="#components-of-a-dgp" id="toc-components-of-a-dgp"><span class="toc-section-number">6.2</span> Components of a DGP</a></li>
<li><a href="#DGP-functions" id="toc-DGP-functions"><span class="toc-section-number">6.3</span> A statistical model is a recipe for data generation</a></li>
<li><a href="#DGP-plotting" id="toc-DGP-plotting"><span class="toc-section-number">6.4</span> Plot the artificial data</a></li>
<li><a href="#check-the-data-generating-function" id="toc-check-the-data-generating-function"><span class="toc-section-number">6.5</span> Check the data-generating function</a></li>
<li><a href="#case-cluster" id="toc-case-cluster"><span class="toc-section-number">6.6</span> Example: Simulating clustered data</a>
<ul>
<li><a href="#a-design-decision-what-do-we-want-to-manipulate" id="toc-a-design-decision-what-do-we-want-to-manipulate"><span class="toc-section-number">6.6.1</span> A design decision: What do we want to manipulate?</a></li>
<li><a href="#a-model-for-a-cluster-rct" id="toc-a-model-for-a-cluster-rct"><span class="toc-section-number">6.6.2</span> A model for a cluster RCT</a></li>
<li><a href="#from-equations-to-code" id="toc-from-equations-to-code"><span class="toc-section-number">6.6.3</span> From equations to code</a></li>
<li><a href="#DGP-standardization" id="toc-DGP-standardization"><span class="toc-section-number">6.6.4</span> Standardization in the DGP</a></li>
</ul></li>
<li><a href="#three-parameter-IRT" id="toc-three-parameter-IRT"><span class="toc-section-number">6.7</span> Sometimes a DGP is all you need</a></li>
<li><a href="#more-to-explore" id="toc-more-to-explore"><span class="toc-section-number">6.8</span> More to explore</a></li>
<li><a href="#exercises-3" id="toc-exercises-3"><span class="toc-section-number">6.9</span> Exercises</a>
<ul>
<li><a href="#Welch-t-dgp" id="toc-Welch-t-dgp"><span class="toc-section-number">6.9.1</span> The Welch test on a shifted-and-scaled <span class="math inline">\(t\)</span> distribution</a></li>
<li><a href="#plot-the-bivariate-poisson" id="toc-plot-the-bivariate-poisson"><span class="toc-section-number">6.9.2</span> Plot the bivariate Poisson</a></li>
<li><a href="#BVP-check" id="toc-BVP-check"><span class="toc-section-number">6.9.3</span> Check the bivariate Poisson function</a></li>
<li><a href="#BVP-error" id="toc-BVP-error"><span class="toc-section-number">6.9.4</span> Add error-catching to the bivariate Poisson function</a></li>
<li><a href="#BVNB1" id="toc-BVNB1"><span class="toc-section-number">6.9.5</span> A bivariate negative binomial distribution</a></li>
<li><a href="#BVNB2" id="toc-BVNB2"><span class="toc-section-number">6.9.6</span> Another bivariate negative binomial distribution</a></li>
<li><a href="#cluster-RCT-plot" id="toc-cluster-RCT-plot"><span class="toc-section-number">6.9.7</span> Plot the data from a cluster-randomized trial</a></li>
<li><a href="#cluster-RCT-checks" id="toc-cluster-RCT-checks"><span class="toc-section-number">6.9.8</span> Checking the Cluster RCT DGP</a></li>
<li><a href="#cluster-RCT-heterogeneity" id="toc-cluster-RCT-heterogeneity"><span class="toc-section-number">6.9.9</span> More school-level variation</a></li>
<li><a href="#cluster-RCT-baseline" id="toc-cluster-RCT-baseline"><span class="toc-section-number">6.9.10</span> Cluster-randomized trial with baseline predictors</a></li>
<li><a href="#IRT-DGP-parameters" id="toc-IRT-DGP-parameters"><span class="toc-section-number">6.9.11</span> 3-parameter IRT datasets</a></li>
<li><a href="#IRT-DGP-checking" id="toc-IRT-DGP-checking"><span class="toc-section-number">6.9.12</span> Check the 3-parameter IRT DGP</a></li>
<li><a href="#IRT-DGP-breaking" id="toc-IRT-DGP-breaking"><span class="toc-section-number">6.9.13</span> Explore the 3-parameter IRT model</a></li>
<li><a href="#meta-regression-DGP" id="toc-meta-regression-DGP"><span class="toc-section-number">6.9.14</span> Random effects meta-regression</a></li>
<li><a href="#Vevea-Hedges-DGP" id="toc-Vevea-Hedges-DGP"><span class="toc-section-number">6.9.15</span> Meta-regression with selective reporting</a></li>
</ul></li>
</ul></li>
<li><a href="#data-analysis-procedures" id="toc-data-analysis-procedures"><span class="toc-section-number">7</span> Data analysis procedures</a>
<ul>
<li><a href="#estimation-functions" id="toc-estimation-functions"><span class="toc-section-number">7.1</span> Writing estimation functions</a></li>
<li><a href="#multiple-estimation-procedures" id="toc-multiple-estimation-procedures"><span class="toc-section-number">7.2</span> Including Multiple Data Analysis Procedures</a></li>
<li><a href="#validating-an-estimation-function" id="toc-validating-an-estimation-function"><span class="toc-section-number">7.3</span> Validating an Estimation Function</a>
<ul>
<li><a href="#checking-against-existing-implementations" id="toc-checking-against-existing-implementations"><span class="toc-section-number">7.3.1</span> Checking against existing implementations</a></li>
<li><a href="#checking-novel-procedures" id="toc-checking-novel-procedures"><span class="toc-section-number">7.3.2</span> Checking novel procedures</a></li>
<li><a href="#checking-with-simulations" id="toc-checking-with-simulations"><span class="toc-section-number">7.3.3</span> Checking with simulations</a></li>
</ul></li>
<li><a href="#handling-errors-warnings-and-other-hiccups" id="toc-handling-errors-warnings-and-other-hiccups"><span class="toc-section-number">7.4</span> Handling errors, warnings, and other hiccups</a>
<ul>
<li><a href="#capturing-errors-and-warnings" id="toc-capturing-errors-and-warnings"><span class="toc-section-number">7.4.1</span> Capturing errors and warnings</a></li>
<li><a href="#adapting-for-errors" id="toc-adapting-for-errors"><span class="toc-section-number">7.4.2</span> Adapting estimation procedures for errors and warnings</a></li>
</ul></li>
<li><a href="#exercises-4" id="toc-exercises-4"><span class="toc-section-number">7.5</span> Exercises</a>
<ul>
<li><a href="#BFFs-forever" id="toc-BFFs-forever"><span class="toc-section-number">7.5.1</span> More Heteroskedastic ANOVA</a></li>
<li><a href="#contingent-testing" id="toc-contingent-testing"><span class="toc-section-number">7.5.2</span> Contingent testing</a></li>
<li><a href="#cross-check-CRT-estimators" id="toc-cross-check-CRT-estimators"><span class="toc-section-number">7.5.3</span> Check the cluster-RCT functions</a></li>
<li><a href="#CRT-ANCOVA-estimators" id="toc-CRT-ANCOVA-estimators"><span class="toc-section-number">7.5.4</span> Extending the cluster-RCT functions</a></li>
<li><a href="#contingent-estimator-processing" id="toc-contingent-estimator-processing"><span class="toc-section-number">7.5.5</span> Contingent estimator processing</a></li>
<li><a href="#IRT-3PL-estimation" id="toc-IRT-3PL-estimation"><span class="toc-section-number">7.5.6</span> Estimating 3-parameter item response theory models</a></li>
<li><a href="#Vevea-Hedges-estimation" id="toc-Vevea-Hedges-estimation"><span class="toc-section-number">7.5.7</span> Meta-regression with selective reporting</a></li>
</ul></li>
</ul></li>
<li><a href="#running-the-simulation-process" id="toc-running-the-simulation-process"><span class="toc-section-number">8</span> Running the Simulation Process</a>
<ul>
<li><a href="#repeating-oneself" id="toc-repeating-oneself"><span class="toc-section-number">8.1</span> Repeating oneself</a></li>
<li><a href="#one-run-at-a-time" id="toc-one-run-at-a-time"><span class="toc-section-number">8.2</span> One run at a time</a>
<ul>
<li><a href="#one-run-reparameterization" id="toc-one-run-reparameterization"><span class="toc-section-number">8.2.1</span> Reparameterizing</a></li>
</ul></li>
<li><a href="#bundle-sim-demo" id="toc-bundle-sim-demo"><span class="toc-section-number">8.3</span> Bundling simulations with <code>{simhelpers}</code></a></li>
<li><a href="#seeds-and-pseudo-RNGs" id="toc-seeds-and-pseudo-RNGs"><span class="toc-section-number">8.4</span> Seeds and pseudo-random number generators</a></li>
<li><a href="#exercises-5" id="toc-exercises-5"><span class="toc-section-number">8.5</span> Exercises</a>
<ul>
<li><a href="#Welch-simulation" id="toc-Welch-simulation"><span class="toc-section-number">8.5.1</span> Welch simulations</a></li>
<li><a href="#Pearson-sampling-distributions" id="toc-Pearson-sampling-distributions"><span class="toc-section-number">8.5.2</span> Compare sampling distributions of Pearson’s correlation coefficients</a></li>
<li><a href="#reparameterization-redux" id="toc-reparameterization-redux"><span class="toc-section-number">8.5.3</span> Reparameterization, redux</a></li>
<li><a href="#fancy-cluster-RCT-sims" id="toc-fancy-cluster-RCT-sims"><span class="toc-section-number">8.5.4</span> Fancy clustered RCT simulations</a></li>
</ul></li>
</ul></li>
<li><a href="#performance-criteria" id="toc-performance-criteria"><span class="toc-section-number">9</span> Performance criteria</a>
<ul>
<li><a href="#different-kinds-of-performance" id="toc-different-kinds-of-performance"><span class="toc-section-number">9.1</span> Different kinds of performance</a></li>
<li><a href="#assessing-a-point-estimator" id="toc-assessing-a-point-estimator"><span class="toc-section-number">9.2</span> Assessing a Point Estimator</a>
<ul>
<li><a href="#comparing-the-performances-of-the-cluster-rct-estimation-procedures" id="toc-comparing-the-performances-of-the-cluster-rct-estimation-procedures"><span class="toc-section-number">9.2.1</span> Comparing the Performances of the Cluster RCT Estimation Procedures</a></li>
<li><a href="#estimands-not-represented-by-a-parameter" id="toc-estimands-not-represented-by-a-parameter"><span class="toc-section-number">9.2.2</span> Estimands Not Represented By a Parameter</a></li>
</ul></li>
<li><a href="#assessing-a-standard-error-estimator" id="toc-assessing-a-standard-error-estimator"><span class="toc-section-number">9.3</span> Assessing a Standard Error Estimator</a>
<ul>
<li><a href="#why-not-assess-the-estimated-se-directly" id="toc-why-not-assess-the-estimated-se-directly"><span class="toc-section-number">9.3.1</span> Why Not Assess the Estimated SE directly?</a></li>
<li><a href="#assessing-ses-for-our-cluster-rct-simulation" id="toc-assessing-ses-for-our-cluster-rct-simulation"><span class="toc-section-number">9.3.2</span> Assessing SEs for Our Cluster RCT Simulation</a></li>
</ul></li>
<li><a href="#assessing-an-inferential-procedure-hypothesis-testing" id="toc-assessing-an-inferential-procedure-hypothesis-testing"><span class="toc-section-number">9.4</span> Assessing an Inferential Procedure (Hypothesis Testing)</a>
<ul>
<li><a href="#validity" id="toc-validity"><span class="toc-section-number">9.4.1</span> Validity</a></li>
<li><a href="#power" id="toc-power"><span class="toc-section-number">9.4.2</span> Power</a></li>
<li><a href="#the-rejection-rate" id="toc-the-rejection-rate"><span class="toc-section-number">9.4.3</span> The Rejection Rate</a></li>
<li><a href="#inference-in-our-cluster-rct-simulation" id="toc-inference-in-our-cluster-rct-simulation"><span class="toc-section-number">9.4.4</span> Inference in our Cluster RCT Simulation</a></li>
</ul></li>
<li><a href="#assessing-confidence-intervals" id="toc-assessing-confidence-intervals"><span class="toc-section-number">9.5</span> Assessing Confidence Intervals</a>
<ul>
<li><a href="#confidence-intervals-in-our-cluster-rct-example" id="toc-confidence-intervals-in-our-cluster-rct-example"><span class="toc-section-number">9.5.1</span> Confidence Intervals in our Cluster RCT Example</a></li>
</ul></li>
<li><a href="#additional-thoughts-on-measuring-performance" id="toc-additional-thoughts-on-measuring-performance"><span class="toc-section-number">9.6</span> Additional Thoughts on Measuring Performance</a>
<ul>
<li><a href="#sec-relative-performance" id="toc-sec-relative-performance"><span class="toc-section-number">9.6.1</span> Selecting Relative vs. Absolute Criteria</a></li>
<li><a href="#robust-measures-of-performance" id="toc-robust-measures-of-performance"><span class="toc-section-number">9.6.2</span> Robust Measures of Performance</a></li>
<li><a href="#summary-of-peformance-measures" id="toc-summary-of-peformance-measures"><span class="toc-section-number">9.6.3</span> Summary of Peformance Measures</a></li>
</ul></li>
<li><a href="#uncertainty-in-performance-estimates-the-monte-carlo-standard-error" id="toc-uncertainty-in-performance-estimates-the-monte-carlo-standard-error"><span class="toc-section-number">9.7</span> Uncertainty in Performance Estimates (the Monte Carlo Standard Error)</a>
<ul>
<li><a href="#mcse-for-relative-variance-estimators" id="toc-mcse-for-relative-variance-estimators"><span class="toc-section-number">9.7.1</span> MCSE for Relative Variance Estimators</a></li>
<li><a href="#calculating-mcses-with-the-simhelpers-package" id="toc-calculating-mcses-with-the-simhelpers-package"><span class="toc-section-number">9.7.2</span> Calculating MCSEs With the <code>simhelpers</code> Package</a></li>
<li><a href="#mcse-calculation-in-our-cluster-rct-example" id="toc-mcse-calculation-in-our-cluster-rct-example"><span class="toc-section-number">9.7.3</span> MCSE Calculation in our Cluster RCT Example</a></li>
</ul></li>
<li><a href="#exercises-6" id="toc-exercises-6"><span class="toc-section-number">9.8</span> Exercises</a></li>
</ul></li>
<li><a href="#case_Cronbach" id="toc-case_Cronbach"><span class="toc-section-number">10</span> Project: Cronbach Alpha</a>
<ul>
<li><a href="#background" id="toc-background"><span class="toc-section-number">10.1</span> Background</a></li>
<li><a href="#getting-started" id="toc-getting-started"><span class="toc-section-number">10.2</span> Getting started</a></li>
<li><a href="#the-data-generating-function" id="toc-the-data-generating-function"><span class="toc-section-number">10.3</span> The data-generating function</a></li>
<li><a href="#the-estimation-function" id="toc-the-estimation-function"><span class="toc-section-number">10.4</span> The estimation function</a>
<ul>
<li><a href="#exercises-naive-confidence-intervals" id="toc-exercises-naive-confidence-intervals"><span class="toc-section-number">10.4.1</span> Exercises (Naive confidence intervals)</a></li>
</ul></li>
<li><a href="#estimator-performance" id="toc-estimator-performance"><span class="toc-section-number">10.5</span> Estimator performance</a>
<ul>
<li><a href="#exercises-calculating-performance" id="toc-exercises-calculating-performance"><span class="toc-section-number">10.5.1</span> Exercises (Calculating Performance)</a></li>
</ul></li>
<li><a href="#replication-and-the-simulation" id="toc-replication-and-the-simulation"><span class="toc-section-number">10.6</span> Replication (and the simulation)</a></li>
<li><a href="#extension-confidence-interval-coverage" id="toc-extension-confidence-interval-coverage"><span class="toc-section-number">10.7</span> Extension: Confidence interval coverage</a></li>
<li><a href="#a-taste-of-multiple-scenarios" id="toc-a-taste-of-multiple-scenarios"><span class="toc-section-number">10.8</span> A taste of multiple scenarios</a>
<ul>
<li><a href="#exercises-7" id="toc-exercises-7"><span class="toc-section-number">10.8.1</span> Exercises</a></li>
</ul></li>
</ul></li>
<li><a href="#part-multifactor-simulations" id="toc-part-multifactor-simulations">(PART) Multifactor Simulations</a></li>
<li><a href="#exp-design" id="toc-exp-design"><span class="toc-section-number">11</span> Designing the multifactor simulation experiment</a>
<ul>
<li><a href="#choosing-parameter-combinations" id="toc-choosing-parameter-combinations"><span class="toc-section-number">11.1</span> Choosing parameter combinations</a>
<ul>
<li><a href="#choosing-parameters-for-the-clustered-rct" id="toc-choosing-parameters-for-the-clustered-rct"><span class="toc-section-number">11.1.1</span> Choosing parameters for the Clustered RCT</a></li>
</ul></li>
<li><a href="#using-pmap-to-run-multifactor-simulations" id="toc-using-pmap-to-run-multifactor-simulations"><span class="toc-section-number">11.2</span> Using pmap to run multifactor simulations</a></li>
<li><a href="#when-to-aggregate-results-across-multiple-simulations" id="toc-when-to-aggregate-results-across-multiple-simulations"><span class="toc-section-number">11.3</span> When to aggregate results across multiple simulations</a>
<ul>
<li><a href="#aggregate-as-you-simulate-inside" id="toc-aggregate-as-you-simulate-inside"><span class="toc-section-number">11.3.1</span> Aggregate as you simulate (inside)</a></li>
<li><a href="#keep-all-simulation-runs-outside" id="toc-keep-all-simulation-runs-outside"><span class="toc-section-number">11.3.2</span> Keep all simulation runs (outside)</a></li>
<li><a href="#getting-raw-results-ready-for-analysis" id="toc-getting-raw-results-ready-for-analysis"><span class="toc-section-number">11.3.3</span> Getting raw results ready for analysis</a></li>
</ul></li>
<li><a href="#running-the-cluster-rct-multifactor-experiment" id="toc-running-the-cluster-rct-multifactor-experiment"><span class="toc-section-number">11.4</span> Running the Cluster RCT multifactor experiment</a>
<ul>
<li><a href="#making-analyze_data-quiet" id="toc-making-analyze_data-quiet"><span class="toc-section-number">11.4.1</span> Making analyze_data() quiet</a></li>
</ul></li>
</ul></li>
<li><a href="#analyzing-the-multifactor-experiment" id="toc-analyzing-the-multifactor-experiment"><span class="toc-section-number">12</span> Analyzing the multifactor experiment</a>
<ul>
<li><a href="#ways-of-analyzing-simulation-results" id="toc-ways-of-analyzing-simulation-results"><span class="toc-section-number">12.1</span> Ways of analyzing simulation results</a>
<ul>
<li><a href="#plot-everything-with-many-small-multiples" id="toc-plot-everything-with-many-small-multiples"><span class="toc-section-number">12.1.1</span> Plot everything with many small multiples</a></li>
<li><a href="#bundling" id="toc-bundling"><span class="toc-section-number">12.1.2</span> Bundling</a></li>
<li><a href="#aggregation" id="toc-aggregation"><span class="toc-section-number">12.1.3</span> Aggregation</a></li>
<li><a href="#regression-summarization" id="toc-regression-summarization"><span class="toc-section-number">12.1.4</span> Regression Summarization</a></li>
<li><a href="#focus-on-a-subset-kick-rest-to-supplement" id="toc-focus-on-a-subset-kick-rest-to-supplement"><span class="toc-section-number">12.1.5</span> Focus on a subset, kick rest to supplement</a></li>
</ul></li>
<li><a href="#analyzing-results-when-some-trials-have-failed" id="toc-analyzing-results-when-some-trials-have-failed"><span class="toc-section-number">12.2</span> Analyzing results when some trials have failed</a></li>
<li><a href="#case-study-power-for-a-randomized-trial" id="toc-case-study-power-for-a-randomized-trial"><span class="toc-section-number">12.3</span> Case study: power for a randomized trial</a>
<ul>
<li><a href="#the-initial-analysis" id="toc-the-initial-analysis"><span class="toc-section-number">12.3.1</span> The initial analysis</a></li>
<li><a href="#focusing-on-validity" id="toc-focusing-on-validity"><span class="toc-section-number">12.3.2</span> Focusing on validity</a></li>
<li><a href="#aggregate-to-look-at-main-effects" id="toc-aggregate-to-look-at-main-effects"><span class="toc-section-number">12.3.3</span> Aggregate to look at main effects</a></li>
<li><a href="#recap" id="toc-recap"><span class="toc-section-number">12.3.4</span> Recap</a></li>
</ul></li>
<li><a href="#exercises-8" id="toc-exercises-8"><span class="toc-section-number">12.4</span> Exercises</a></li>
</ul></li>
<li><a href="#case-study-comparing-different-estimators" id="toc-case-study-comparing-different-estimators"><span class="toc-section-number">13</span> Case study: Comparing different estimators</a>
<ul>
<li><a href="#the-data-generating-process" id="toc-the-data-generating-process"><span class="toc-section-number">13.1</span> The data generating process</a></li>
<li><a href="#the-data-analysis-methods" id="toc-the-data-analysis-methods"><span class="toc-section-number">13.2</span> The data analysis methods</a></li>
<li><a href="#the-simulation-itself" id="toc-the-simulation-itself"><span class="toc-section-number">13.3</span> The simulation itself</a></li>
<li><a href="#calculating-performance-measures-for-all-our-estimators" id="toc-calculating-performance-measures-for-all-our-estimators"><span class="toc-section-number">13.4</span> Calculating performance measures for all our estimators</a></li>
<li><a href="#improving-the-visualization-of-the-results" id="toc-improving-the-visualization-of-the-results"><span class="toc-section-number">13.5</span> Improving the visualization of the results</a></li>
<li><a href="#extension-the-bias-variance-tradeoff" id="toc-extension-the-bias-variance-tradeoff"><span class="toc-section-number">13.6</span> Extension: The Bias-variance tradeoff</a></li>
</ul></li>
<li><a href="#presentation-of-simulation-results" id="toc-presentation-of-simulation-results"><span class="toc-section-number">14</span> Presentation of simulation results</a>
<ul>
<li><a href="#tabulation" id="toc-tabulation"><span class="toc-section-number">14.1</span> Tabulation</a></li>
<li><a href="#visualization" id="toc-visualization"><span class="toc-section-number">14.2</span> Visualization</a>
<ul>
<li><a href="#example-1-biserial-correlation-estimation" id="toc-example-1-biserial-correlation-estimation"><span class="toc-section-number">14.2.1</span> Example 1: Biserial correlation estimation</a></li>
<li><a href="#example-2-variance-estimation-and-meta-regression" id="toc-example-2-variance-estimation-and-meta-regression"><span class="toc-section-number">14.2.2</span> Example 2: Variance estimation and Meta-regression</a></li>
<li><a href="#example-heat-maps-of-coverage" id="toc-example-heat-maps-of-coverage"><span class="toc-section-number">14.2.3</span> Example: Heat maps of coverage</a></li>
</ul></li>
<li><a href="#modeling" id="toc-modeling"><span class="toc-section-number">14.3</span> Modeling</a></li>
</ul></li>
<li><a href="#part-computational-considerations" id="toc-part-computational-considerations">(PART) Computational Considerations</a></li>
<li><a href="#optimize-code" id="toc-optimize-code"><span class="toc-section-number">15</span> Optimizing code (and why you often shouldn’t)</a>
<ul>
<li><a href="#hand-building-functions" id="toc-hand-building-functions"><span class="toc-section-number">15.1</span> Hand-building functions</a></li>
<li><a href="#sec_comp_efficiency" id="toc-sec_comp_efficiency"><span class="toc-section-number">15.2</span> Computational efficiency versus simplicity</a></li>
<li><a href="#reusing-code-to-speed-up-computation" id="toc-reusing-code-to-speed-up-computation"><span class="toc-section-number">15.3</span> Reusing code to speed up computation</a></li>
</ul></li>
<li><a href="#error-trapping-and-other-headaches" id="toc-error-trapping-and-other-headaches"><span class="toc-section-number">16</span> Error trapping and other headaches</a>
<ul>
<li><a href="#what-to-do-with-warnings-in-simulations" id="toc-what-to-do-with-warnings-in-simulations"><span class="toc-section-number">16.0.1</span> What to do with warnings in simulations</a></li>
</ul></li>
<li><a href="#saving-files" id="toc-saving-files"><span class="toc-section-number">17</span> Saving files and results</a>
<ul>
<li><a href="#saving-simulations-in-general" id="toc-saving-simulations-in-general"><span class="toc-section-number">17.1</span> Saving simulations in general</a></li>
<li><a href="#saving-simulations-as-you-go" id="toc-saving-simulations-as-you-go"><span class="toc-section-number">17.2</span> Saving simulations as you go</a></li>
<li><a href="#dynamically-making-directories" id="toc-dynamically-making-directories"><span class="toc-section-number">17.3</span> Dynamically making directories</a></li>
<li><a href="#loading-and-combining-files-of-simulation-results" id="toc-loading-and-combining-files-of-simulation-results"><span class="toc-section-number">17.4</span> Loading and combining files of simulation results</a></li>
</ul></li>
<li><a href="#parallel-processing" id="toc-parallel-processing"><span class="toc-section-number">18</span> Parallel Processing</a>
<ul>
<li><a href="#parallel-on-your-computer" id="toc-parallel-on-your-computer"><span class="toc-section-number">18.1</span> Parallel on your computer</a></li>
<li><a href="#parallel-off-your-computer" id="toc-parallel-off-your-computer"><span class="toc-section-number">18.2</span> Parallel off your computer</a>
<ul>
<li><a href="#what-is-a-command-line-interface" id="toc-what-is-a-command-line-interface"><span class="toc-section-number">18.2.1</span> What is a command-line interface?</a></li>
<li><a href="#running-a-job-on-a-cluster" id="toc-running-a-job-on-a-cluster"><span class="toc-section-number">18.2.2</span> Running a job on a cluster</a></li>
<li><a href="#checking-on-a-job" id="toc-checking-on-a-job"><span class="toc-section-number">18.2.3</span> Checking on a job</a></li>
<li><a href="#running-lots-of-jobs-on-a-cluster" id="toc-running-lots-of-jobs-on-a-cluster"><span class="toc-section-number">18.2.4</span> Running lots of jobs on a cluster</a></li>
<li><a href="#resources-for-harvards-odyssey" id="toc-resources-for-harvards-odyssey"><span class="toc-section-number">18.2.5</span> Resources for Harvard’s Odyssey</a></li>
<li><a href="#acknowledgements-1" id="toc-acknowledgements-1"><span class="toc-section-number">18.2.6</span> Acknowledgements</a></li>
</ul></li>
</ul></li>
<li><a href="#simulations-as-evidence" id="toc-simulations-as-evidence"><span class="toc-section-number">19</span> Simulations as evidence</a>
<ul>
<li><a href="#strategies-for-making-relevant-simulations" id="toc-strategies-for-making-relevant-simulations"><span class="toc-section-number">19.1</span> Strategies for making relevant simulations</a>
<ul>
<li><a href="#make-your-simulation-general-with-an-extensive-multi-factor-experiment" id="toc-make-your-simulation-general-with-an-extensive-multi-factor-experiment"><span class="toc-section-number">19.1.1</span> Make your simulation general with an extensive multi-factor experiment</a></li>
<li><a href="#use-previously-published-simulations-to-beat-them-at-their-own-game" id="toc-use-previously-published-simulations-to-beat-them-at-their-own-game"><span class="toc-section-number">19.1.2</span> Use previously published simulations to beat them at their own game</a></li>
<li><a href="#calibrate-simulation-factors-to-real-data" id="toc-calibrate-simulation-factors-to-real-data"><span class="toc-section-number">19.1.3</span> Calibrate simulation factors to real data</a></li>
<li><a href="#use-real-data-to-obtain-directly" id="toc-use-real-data-to-obtain-directly"><span class="toc-section-number">19.1.4</span> Use real data to obtain directly</a></li>
<li><a href="#fully-calibrated-simulations" id="toc-fully-calibrated-simulations"><span class="toc-section-number">19.1.5</span> Fully calibrated simulations</a></li>
</ul></li>
</ul></li>
<li><a href="#part-complex-data-structures" id="toc-part-complex-data-structures">(PART) Complex Data Structures</a></li>
<li><a href="#using-simulation-as-a-power-calculator" id="toc-using-simulation-as-a-power-calculator"><span class="toc-section-number">20</span> Using simulation as a power calculator</a>
<ul>
<li><a href="#getting-design-parameters-from-pilot-data" id="toc-getting-design-parameters-from-pilot-data"><span class="toc-section-number">20.1</span> Getting design parameters from pilot data</a></li>
<li><a href="#the-data-generating-process-1" id="toc-the-data-generating-process-1"><span class="toc-section-number">20.2</span> The data generating process</a></li>
<li><a href="#running-the-simulation-1" id="toc-running-the-simulation-1"><span class="toc-section-number">20.3</span> Running the simulation</a></li>
<li><a href="#evaluating-power" id="toc-evaluating-power"><span class="toc-section-number">20.4</span> Evaluating power</a>
<ul>
<li><a href="#checking-validity-of-our-models" id="toc-checking-validity-of-our-models"><span class="toc-section-number">20.4.1</span> Checking validity of our models</a></li>
<li><a href="#assessing-precision-se" id="toc-assessing-precision-se"><span class="toc-section-number">20.4.2</span> Assessing Precision (SE)</a></li>
<li><a href="#assessing-power" id="toc-assessing-power"><span class="toc-section-number">20.4.3</span> Assessing power</a></li>
<li><a href="#assessing-minimum-detectable-effects" id="toc-assessing-minimum-detectable-effects"><span class="toc-section-number">20.4.4</span> Assessing Minimum Detectable Effects</a></li>
</ul></li>
</ul></li>
<li><a href="#potential-outcomes" id="toc-potential-outcomes"><span class="toc-section-number">21</span> Simulation under the Potential Outcomes Framework</a>
<ul>
<li><a href="#finite-vs.-superpopulation-inference" id="toc-finite-vs.-superpopulation-inference"><span class="toc-section-number">21.1</span> Finite vs. Superpopulation inference</a></li>
<li><a href="#data-generation-processes-for-potential-outcomes" id="toc-data-generation-processes-for-potential-outcomes"><span class="toc-section-number">21.2</span> Data generation processes for potential outcomes</a></li>
<li><a href="#finite-sample-performance-measures" id="toc-finite-sample-performance-measures"><span class="toc-section-number">21.3</span> Finite sample performance measures</a></li>
<li><a href="#nested-finite-simulation-procedure" id="toc-nested-finite-simulation-procedure"><span class="toc-section-number">21.4</span> Nested finite simulation procedure</a></li>
</ul></li>
<li><a href="#the-parametric-bootstrap" id="toc-the-parametric-bootstrap"><span class="toc-section-number">22</span> The Parametric bootstrap</a>
<ul>
<li><a href="#air-conditioners-a-stolen-case-study" id="toc-air-conditioners-a-stolen-case-study"><span class="toc-section-number">22.1</span> Air conditioners: a stolen case study</a></li>
</ul></li>
<li><a href="#appendix-appendices" id="toc-appendix-appendices">(APPENDIX) Appendices</a></li>
<li><a href="#coding-tidbits" id="toc-coding-tidbits"><span class="toc-section-number">23</span> Coding tidbits</a>
<ul>
<li><a href="#more-repeating-oneself" id="toc-more-repeating-oneself"><span class="toc-section-number">23.1</span> How to repeat yourself</a>
<ul>
<li><a href="#using-replicate" id="toc-using-replicate"><span class="toc-section-number">23.1.1</span> Using <code>replicate()</code></a></li>
<li><a href="#using-map" id="toc-using-map"><span class="toc-section-number">23.1.2</span> Using <code>map()</code></a></li>
<li><a href="#map-with-no-inputs" id="toc-map-with-no-inputs"><span class="toc-section-number">23.1.3</span> map with no inputs</a></li>
<li><a href="#other-approaches-for-repetition" id="toc-other-approaches-for-repetition"><span class="toc-section-number">23.1.4</span> Other approaches for repetition</a></li>
</ul></li>
<li><a href="#default-arguments" id="toc-default-arguments"><span class="toc-section-number">23.2</span> Default arguments for functions</a></li>
<li><a href="#about-source-command" id="toc-about-source-command"><span class="toc-section-number">23.3</span> The source command and keeping things organized</a></li>
<li><a href="#about-keeping-tests-with-FALSE" id="toc-about-keeping-tests-with-FALSE"><span class="toc-section-number">23.4</span> Testing and debugging code in your scripts</a></li>
<li><a href="#about-browser-debugging" id="toc-about-browser-debugging"><span class="toc-section-number">23.5</span> Debugging with browser</a></li>
<li><a href="#about-stopifnot" id="toc-about-stopifnot"><span class="toc-section-number">23.6</span> Protecting your functions with “stop”</a></li>
</ul></li>
<li><a href="#further-readings-and-resources" id="toc-further-readings-and-resources"><span class="toc-section-number">24</span> Further readings and resources</a></li>
</ul>
<!--bookdown:toc2:end-->
      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Designing Monte Carlo Simulations in R</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<!--bookdown:toc:end-->
<!--bookdown:body:start-->
<div id="welcome" class="section level1 unnumbered hasAnchor">
<h1 class="unnumbered hasAnchor">Welcome<a href="#welcome" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p>Monte Carlo simulations are a computational technique for investigating how well something works, or for investigating what might happen in a given circumstance.
When we write a simulation, we are able to control how data are generated, which means we can know what the “right answer” is.
Then, by repeatedly generating data and then applying some statistical method that data, we can assess how well a statistical method works in practice.</p>
<p>Monte Carlo simulations are an essential tool of inquiry for quantitative methodologists and students of statistics, useful both for small-scale or informal investigations and for formal methodological research.
Despite the ubiquity of simulation work, most quantitative researchers get little formal training in the design and implementation of Monte Carlo simulations. As a result, the simulation studies presented in academic journal articles are highly variable in terms of their high-level logic, scope, programming, and presentation.
Although there has long been discussion of simulation design and implementation among statisticians and methodologists, the available guidance is scattered across many different disciplines, and much of it is focused on mechanics and computing tools, rather than on principles.</p>
<p>In this monograph, we aim to provide an introduction to the logic and mechanics of designing simulation studies, using the R programming language.
Our focus is on simulation studies for formal research purposes (i.e., as might appear in a journal article or dissertation) and for informing the design of empirical studies (e.g., power analysis).
That being said, the ideas of simulation are used in many different contexts and for many different problems, and we believe the overall concepts illustrated by these “conventional” simulations readily carry over into all sorts of other types of use, even statistical inference!
Our focus is on the best practices of simulation design and how to use simulation to be a more informed and effective quantitative analyst.
In particular, we try to provide a guide to designing simulation studies to answer questions about statistical methodology.</p>
<p>Mainly, this book gives practical tools (i.e., lots of code to simply take and repurpose) along with some thoughts and guidance for writing simulations.
We hope you find it to be a useful handbook to help you with your own projects, whatever they happen to be!</p>
<div id="license" class="section level2 unnumbered hasAnchor">
<h2 class="unnumbered hasAnchor">License<a href="#license" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>This book is licensed to you under <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.</p>
<p>The code samples in this book are licensed under <a href="https://creativecommons.org/publicdomain/zero/1.0/">Creative Commons CC0 1.0 Universal (CC0 1.0)</a>, i.e. public domain.</p>
</div>
<div id="about-the-authors" class="section level2 unnumbered hasAnchor">
<h2 class="unnumbered hasAnchor">About the authors<a href="#about-the-authors" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>We wrote this book in full collaboration, because we thought it would be fun to have some reason to talk about how to write simulations, and we wanted more people to be writing high-quality simulations.
Our author order is alphabetical, but perhaps imagine it as a circle, or something with no start or end:</p>
<p><img src="Designing-Simulations-in-R_files/figure-html/unnamed-chunk-2-1.png" width="75%" style="display: block; margin: auto;" /></p>
<p>But anymore, more about us.</p>
<p><strong>James E. Pustejovsky</strong> is an associate professor at the University of Wisconsin - Madison, where he teaches in the Quantitative Methods Program within the Department of Educational Psychology. He completed a Ph.D. in Statistics at Northwestern University.</p>
<p><strong>Luke Miratrix</strong>: I am currently an associate professor at Harvard University’s Graduate School of Education. I completed a Ph.D. in Statistics at UC Berkeley after having traveled through three different graduate programs (computer science at MIT, education at UC Berkeley, and then finally statistics at UC Berkeley).
I then ended up as an assistant professor in Harvard’s statistics department, and moved (back) to Education a few years later.</p>
<p>Over the years, simulation has become a way for me to think.
This might be because I am fundamentally lazy, and the idea of sitting down and trying to do a bunch of math to figure something out seems less fun than writing up some code “real quick” so I can see how things operate. Of course, “real quick” rarely is that quick – and before I know it I got sucked into trying to learn some esoteric aspect of how to best program something, and then a few rabbit holes later I may have discovered something interesting! I find simulation quite absorbing, and I also find them reassuring (usually with regards to whether I have correctly implemented some statistical method). This book has been a real pleasure to write, because it’s given me actual license to sit down and think about why I do the various things I do, and also which way I actually prefer to approach a problem. And getting to write this book with my co-author has been a particular pleasure, for talking about the business of writing simulations is rarely done in practice. This has been a real gift, and I have learned so much.</p>
</div>
<div id="acknowledgements" class="section level2 unnumbered hasAnchor">
<h2 class="unnumbered hasAnchor">Acknowledgements<a href="#acknowledgements" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>The material in this book was initially developed through courses that we offered at the University of Texas at Austin (James) and Harvard University (Luke) as well as from a series of workshops that we offered through the Society for Research on Educational Effectiveness in June of 2021. We are grateful for feedback, questions, and corrections we have received from many students who participated in these courses. Some parts of this book are based on memos or other writings generated for various purposes, some of which were written by others. This is been attributed throughout.</p>
<!--chapter:end:index.Rmd-->
</div>
</div>
<div id="part-an-introductory-look" class="section level1 unnumbered hasAnchor">
<h1 class="unnumbered hasAnchor">(PART) An Introductory Look<a href="#part-an-introductory-look" class="anchor-section" aria-label="Anchor link to header"></a></h1>
</div>
<div id="introduction" class="section level1 hasAnchor" number="1">
<h1 class="hasAnchor"><span class="header-section-number">1</span> Introduction<a href="#introduction" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p>Monte Carlo simulations are a tool for studying the behavior of random processes, such as the behavior of a statistical estimation procedure when applied to a sample of data.
Within quantitatively oriented fields, researchers developing new statistical methods or evaluating the use of existing methods nearly always use Monte Carlo simulations as part of their research process.
In the context of methodological development, researchers use simulations in a way analogous to how a chef would use their test kitchen to develop new recipes before putting them on the menu, how a manufacturer would use a materials testing laboratory to evaluate the safety and durability of a new consumer good before bringing it to market, or how an astronaut would prepare for a spacewalk by practicing the process in an underwater mock-up.
Simulation studies provide a clean and controlled environment for testing out data analysis approaches before putting them to use with real empirical data.</p>
<p>More broadly, Monte Carlo studies are an essential tool in many different fields of science—climate science, engineering, and education research are three examples—and are used for a variety of different purposes.
Simulations are used to model complex stochastic processes such as weather patterns <span class="citation">(<a href="#ref-jones2012IntroductionScientificProgramming">Jones, Maillardet, and Robinson 2012</a>; <a href="#ref-robert2010IntroducingMonteCarlo">Robert and Casella 2010</a>)</span>;
to generate parameter estimates from complex statistical models, as in Markov Chain Monte Carlo sampling <span class="citation">(<a href="#ref-gelman2013BayesianDataAnalysis">Gelman et al. 2013</a>)</span>;
and even to estimate uncertainty in statistical summaries, as in bootstrapping <span class="citation">(<a href="#ref-davison1997BootstrapMethodsTheir">Davison and Hinkley 1997</a>)</span>.
In this book, we shall focus on using simulation for the development and validation of methods for data analysis, which are everyday concerns within the fields of statistics and quantitative methodology.
However, we also believe that many of the general principles of simulation design and execution that we will discuss are broadly applicable to these other purposes, and we note connections as they occur.</p>
<p>At a very high level, Monte Carlo simulation provides a method for understanding the performance of a statistical model or data analysis method under conditions where the truth is known and can be controlled.
The basic approach for doing so is as follows:</p>
<ol style="list-style-type: decimal">
<li>Create artificial data using random number generators based on a specific statistical model, or more generally, a <em>Data-Generating Process</em> (DGP).</li>
<li>Apply one or more data-analysis procedures to the artificial data. (These procedures might be something as simple as calculating a difference in sample means or fitting a regression model, or it might be an involved, multi-step procedure involving cleansing the data of apparent outliers, imputing missing values, applying a machine-learning algorithm, and carrying out further calculations on the predictions of the algorithm.)</li>
<li>Repeat Steps 1 and 2 many times.</li>
<li>Summarize the results across these repetitions in order to understand the general trends or patterns in how the method works.</li>
</ol>
<p>Simulation is useful because one can control the data-generating process and therefore fully know the truth—something that is almost always uncertain when analyzing real, empirical data.
Having full control of the data-generating process makes it possible to assess how well a procedure works by comparing the estimates produced by the data analysis procedure against this known truth.
For instance, we can see if estimates from a statistical procedure are consistently too high or too low (i.e., whether an estimator is systematically biased).
We can also compare multiple data analysis procedures by assessing the degree of error in each set of results to determine which procedure is generally more accurate when applied to the same collection of artificial datasets.</p>
<p>This basic process of simulation can be used to investigate an array of different questions that arise in statistics and quantitative methodology.
To seed the field, we now give a high-level overview of some of the major use cases. We then discuss some of the major limitations and common pitfalls of simulation studies, which are important to keep in mind as we proceed.</p>
<div id="some-of-simulations-many-uses" class="section level2 hasAnchor" number="1.1">
<h2 class="hasAnchor"><span class="header-section-number">1.1</span> Some of simulation’s many uses<a href="#some-of-simulations-many-uses" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Monte Carlo simulations allow for rapid exploration of different data analysis procedures and, even more broadly, different approaches to designing studies and collecting measurements. Simulations are especially useful because they provide a means to answer questions that are difficult or impossible to answer by other means.
Many statistical models and estimation methods <em>can</em> be analyzed mathematically, but only by using asymptotic approximations that describe how the methods work as sample size increases towards infinity.
In contrast, simulation methods provide answers for specific, finite sample sizes.
Thus, they allow researchers to study models and estimation methods where relevant mathematical formulas are not available, not easily applied, or not sufficiently accurate.</p>
<p>Circumstances where simulations are helpful—or even essential—occur in a range of different situations within quantitative research.
To set the stage for our subsequent presentation, consider the following areas where one might find need of simulation.</p>
<div id="comparing-statistical-approaches" class="section level3 hasAnchor" number="1.1.1">
<h3 class="hasAnchor"><span class="header-section-number">1.1.1</span> Comparing statistical approaches<a href="#comparing-statistical-approaches" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>One of the more common uses of Monte Carlo simulation is to compare alternative statistical approaches to analyzing the same type of data.
In the academic literature on statistical methodology, authors frequently report simulation studies comparing a newly proposed method against more traditional approaches, to make a case for the utility of their method.
A classic example of such work is <span class="citation">Brown and Forsythe (<a href="#ref-brown1974SmallSampleBehavior">1974</a>)</span>, who compared four different procedures for conducting a hypothesis test for equality of means in several populations (i.e., one-way ANOVA) when the population variances are not equal.
A subsequent study by <span class="citation">Mehrotra (<a href="#ref-mehrotra1997ImprovingBrownforsytheSolution">1997</a>)</span> built on Brown and Forsythe’s work, proposing a more refined method and using simulations to demonstrate that it is superior to the existing methods.
We explore the <span class="citation">Brown and Forsythe (<a href="#ref-brown1974SmallSampleBehavior">1974</a>)</span> study in the case study of Chapter @ref(case-ANOVA).</p>
<p>Comparative simulation can also have a practical application: In many situations, more than one data analysis approach is possible for addressing a given research question (or estimating a specified target parameter).
Simulations comparing multiple approaches can be quite informative and can help to guide the design of an analytic plan (such as plans included in a pre-registered study protocol).
For instance, researchers designing a multi-site randomized experiment might wonder whether they should use an analytic model that allows for variation in the site-specific impact estimates <span class="citation">(<a href="#ref-miratrix2021applied">Miratrix, Weiss, and Henderson 2021</a>)</span> or a simpler model that treats the impact as homogeneous across sites.
What are the practical benefits and costs of using the more complex model?
In the ideal case, simulations can identify best practices for how to approach analysis of a certain type of data and can surface trade-offs between competing approaches that occur in practice.</p>
</div>
<div id="assessing-performance-of-complex-pipelines" class="section level3 hasAnchor" number="1.1.2">
<h3 class="hasAnchor"><span class="header-section-number">1.1.2</span> Assessing performance of complex pipelines<a href="#assessing-performance-of-complex-pipelines" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>In practice, statistical methods are often used as part of a multi-step workflow.
For instance, in a regression model, one might first use a statistical test for heteroskedasticity (e.g., the White test or the Breusch-Pagan test) and then determine whether to use conventional or heteroskedasticity-robust standard errors depending on the result of the test.
This combination of an initial diagnostic test followed by contingent use of different statistical procedures is quite difficult to analyze mathematically, but it is straight-forward to simulate <span class="citation">(see, for example, <a href="#ref-longUsingHeteroscedasticityConsistent2000">Long and Ervin 2000</a>)</span>.
In particular, simulations are a straight-foward way to assess whether a proposed workflow is <em>valid</em>—that is, whether the conclusions from a pipeline are correct at a given level of certainty.</p>
<p>Beyond just evaluating the performance characteristics of a workflow, simulating a multi-step workflow can actually be used as a technique for <em>conducting</em> statistical inference with real data.
Data analysis approaches such as randomization inference and bootstrapping involve repeatedly simulating data and putting it through an analytic pipeline, in order to assess the uncertainty of the original estimate based on real data.
In bootstrapping, the variation in a point estimate across replications of the simulation is used as the standard error for the context being simulated;
an argument by analogy (the bootstrap analogy) is what connects this to inference on the original data and point estimate.
See the first few chapters of <span class="citation">Davison and Hinkley (<a href="#ref-davison1997BootstrapMethodsTheir">1997</a>)</span> or <span class="citation">Efron (<a href="#ref-efron2000BootstrapModernStatistics">2000</a>)</span> for further discussion of bootstrapping, and see <span class="citation">Good (<a href="#ref-good2013permutation">2013</a>)</span> or <span class="citation">Lehmann et al. (<a href="#ref-lehmann1975statistical">1975</a>)</span> for more on permutation inference.</p>
</div>
<div id="assessing-performance-under-misspecification" class="section level3 hasAnchor" number="1.1.3">
<h3 class="hasAnchor"><span class="header-section-number">1.1.3</span> Assessing performance under misspecification<a href="#assessing-performance-under-misspecification" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Many statistical estimation procedures are known to perform well when the assumptions they entail are correct.
However, data analysts must also be concerned with the <em>robustness</em> of estimation procedures—that is, their performance when one or more of the assumptions is violated to some degree.
For example, in a multilevel model, how important is the assumption that the random effects are normally distributed? What about normality of the individual-level error terms? What about homoskedasticity of the individual-level error terms?
Quantitative researchers routinely contend with such questions when analyzing empirical data, and simulation can provide some answers.</p>
<p>Similar concerns arise for researchers considering the trade-offs between methods that make relatively stringent assumptions versus methods that are more flexible or adaptive. When the true data-generating process meets stringent assumptions (e.g., a treatment effect that is constant across the population of participants), what are the potential gain of exploiting such structure in the estimation process?
Conversely, what are the costs (in terms of computation time or precision) of using more flexible methods that do not impose strong assumptions?
A researcher designing an analytic plan would want to be well-informed of such trade-offs and, ideally, would want to situate their understanding in the context of the empirical phenomena that they study.
Simulation allows for such investigation and comparison.</p>
</div>
<div id="assessing-the-finite-sample-performance-of-a-statistical-approach" class="section level3 hasAnchor" number="1.1.4">
<h3 class="hasAnchor"><span class="header-section-number">1.1.4</span> Assessing the finite-sample performance of a statistical approach<a href="#assessing-the-finite-sample-performance-of-a-statistical-approach" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Many statistical estimation procedures can be shown (through mathematical analysis) to work well <em>asymptotically</em>—that is, given an infinite amount of data—but their performance for data of a given, finite size is more difficult to quantify.
Although mathematical theory can inform us about “asymptopia,” empirical researchers live in a world of finite sample sizes, where it can be difficult to gauge if one’s real data is large enough that the asymptotic approximations apply.
For example, this is of particular concern with hierarchical data structures that include only 20 to 40 clusters—a common circumstance in many randomized field trials in education research.
<!-- JEP: Citation for this? -->
<!-- LWM: I will have one in 6 months?  But I don't know of one off the top of my head. -->
Simulation is a tractable approach for assessing the small-sample performance of such estimation methods or for determining minimum required sample sizes for adequate performance.</p>
<p>One example of a simulation investigating questions of finite-sample behavior comes from <span class="citation">Long and Ervin (<a href="#ref-longUsingHeteroscedasticityConsistent2000">2000</a>)</span>, whose evaluated the performance of heteroskedasticity-robust standard errors (HRSE) in linear regression models.
Asymptotic analysis indicates that HRSEs work well (in the sense of providing correct assessments of uncertainty) in sufficiently large samples (<span class="citation">White (<a href="#ref-White1980heteroskedasticity">1980</a>)</span>), but what about in realistic contexts where small samples occur?
<span class="citation">Long and Ervin (<a href="#ref-longUsingHeteroscedasticityConsistent2000">2000</a>)</span> use extensive simulations to investigate the properties of different versions of HRSEs for linear regression across a range of sample sizes, demonstrating that the most commonly used form of these estimators often does <em>not</em> work well with sample sizes found in typical social science applications.
Via simulation, they provided compelling evidence about a problem without having to wade into a technical (and potentially inaccessible) mathematical analysis of the problem.</p>
<!-- LWM: Do we need another example or are we good as it stands, do you think? -->
<!-- JEP: Would be nice to have another example at some point, about something other than heteroskedasticity. -->
</div>
<div id="conducting-power-analyses" class="section level3 hasAnchor" number="1.1.5">
<h3 class="hasAnchor"><span class="header-section-number">1.1.5</span> Conducting Power Analyses<a href="#conducting-power-analyses" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>During the process of proposing, seeking funding for, and planning an empirical research study, researchers need to justify the design of the study, including the size of the sample that they aim to collect.
Part of such justifications may involve a <em>power analysis</em>, or an approximation of the probability that the study will show a statistically significant effect, given assumptions about the magnitude of true effects and other aspects of the data-generating process.
Researchers may also wish to compare the power of different possible designs in order to inform decisions about how to carry out the proposed study given a set of monetary and temporal constraints.</p>
<p>Many guidelines and tools are available for conducting power analysis for various research designs, including software such as <a href="https://www.causalevaluation.org/power-analysis.html">PowerUp!</a> <span class="citation">(<a href="#ref-dong2013PowerUpToolCalculating">Dong and Maynard 2013</a>)</span>, <a href="https://www.thegeneralizer.org/">the Generalizer</a> <span class="citation">(<a href="#ref-tipton2014stratified">Tipton 2013</a>)</span>, <a href="https://www.psychologie.hhu.de/arbeitsgruppen/allgemeine-psychologie-und-arbeitspsychologie/gpower">G*Power</a> <span class="citation">(<a href="#ref-faul2009StatisticalPowerAnalyses">Faul et al. 2009</a>)</span>, and <a href="https://cran.r-project.org/web//packages/PUMP/index.html">PUMP</a> <span class="citation">(<a href="#ref-hunter2023PowerMultiplicityProject">Hunter, Miratrix, and Porter 2024</a>)</span>.
These tools use analytic formulas for power, which are often derived using approximations and simplifying assumptions about a planned design. Simulation provides a very general-purpose alternative for power calculations, which can avoid such approximations and simplifications.
By repeatedly simulating data based on a hypothetical process and then analyzing data following a specific protocol, one can <em>computationally</em> approximate the power to detect an effect of a specified size.</p>
<p>Using simulation instead of analytic formulas allows for power analyses that are more nuanced and more tailored to the researcher’s circumstance than what can be obtained from available software.
For example, simulation can be useful for the following:</p>
<ul>
<li><p>When estimating power in multi-site, block- or cluster-randomized trials, the formulas implemented in available software assume that sites are of equal size and that outcome distributions are unrelated to the size of each site.
Small deviations from these assumptions are unlikely to change the results, but in practice, researchers may face situations where sites vary quite widely in size or where site-level outcomes are related to site size.
Simulation can estimate power in this case.</p></li>
<li><p>Available software such as <a href="https://www.causalevaluation.org/power-analysis.html">PowerUp!</a> allows investigators to build in assumptions about anticipated rates of attrition in cluster-randomized trials, under the assumption that attrition is completely at random and unrelated to anything.
However, researchers might anticipate that, in practice, attrition will be related to baseline characteristics.
Simulation can be used to assess how this might affect the power of a planned study.</p></li>
<li><p>There are some closed-form expressions for power to test mediational relations (i.e., indirect and direct effects) in a variety of different experimental designs, and these formulas are now available in <a href="https://www.causalevaluation.org/power-analysis.html">PowerUp!</a>.
However, the formulas involve a large number of parameters (including some where it may be difficult to develop credible assumptions) and they apply only to a specific analytic model for the mediating relationships.
Researchers planning a study to investigate mediation might therefore find it useful to generate realistic data structures and conduct power analysis via simulation.</p></li>
</ul>
</div>
<div id="simulating-processess" class="section level3 hasAnchor" number="1.1.6">
<h3 class="hasAnchor"><span class="header-section-number">1.1.6</span> Simulating processess<a href="#simulating-processess" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Yet another common use for Monte Carlo simulation is as a way to emulate a complex process as a means to better understand it or to evaluate the consequences of modifying it.
A famous area of process simulation are climate models, where researchers simulate the process of climate change.
These physical simulations mimic very complex systems to try and understand how perturbations (e.g., more carbon release) will impact downstream trends.</p>
<p>Another example of process simulation arises in education research.
Some large school districts such as New York City have centralized lotteries for school assignment, which entail having families rank schools by order of preference.
The central office then assigns students to schools via a lottery procedure where each student gets a lottery number that breaks ties when there are too many students desiring to go to certain schools.
Students’ school assignments are therefore based in part on random chance, but the the process is quite complex: each student has some probability of assignment to each school on their list, but the probabilities depend on their choices and the choices of other students.</p>
<p>The school lottery process creates a natural experiment, based on which researchers can estimate the causal impact of being assigned to one school vs. another.
A defensible analysis of the process requires knowing the probabilities of school assignment. <span class="citation">Abdulkadiroğlu et al. (<a href="#ref-abdulkadirouglu2017research">2017</a>)</span> conducted such an evaluation using the school lottery process in New York City.
They calculated school assignment probabilities via simulation, by running the school lottery over and over, changing only students’ lottery numbers, and recording students’ school assignments in each repetition of the process.
Simulating the lottery process a large number of times provided precise estimates of each students’ assignment probabilities, based on which <span class="citation">Abdulkadiroğlu et al. (<a href="#ref-abdulkadirouglu2017research">2017</a>)</span> were able to estimate causal impacts of school assignment.</p>
<p>For another example, one that possibly illustrates the perils of simulation as taking us away from results that pass face validity, <span class="citation">Staiger and Rockoff (<a href="#ref-staiger2010searching">2010</a>)</span> simulated the process of firing teachers depending on their estimated value-added scores.
Based on their simulations, which model firing different proportions of teachers, they suggest that firing substantial portions of the teacher workforce annually would substantially improve student test scores.
Their work offers a clear illustration of how simulations can be used to examine the potential consequences of various policy decisions, assuming the underlying assumptions hold true.
This example also brings home a core concern of simulation: we only learn about the world we are simulating, and the relevance of simulation evidence to the real world is by no means guaranteed.</p>
</div>
</div>
<div id="the-perils-of-simulation-as-evidence" class="section level2 hasAnchor" number="1.2">
<h2 class="hasAnchor"><span class="header-section-number">1.2</span> The perils of simulation as evidence<a href="#the-perils-of-simulation-as-evidence" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Simulation has the potential to be a powerful tool for investigating quantitative methods.
However, evidence from simulation studies is also fundamentally limited in certain ways, and thus very susceptible to critique.
The core advantage of simulation studies is that they allow for evaluation of data analysis methods under <em>specific and exact conditions</em>, avoiding the need for approximation.
The core limitation of simulations stems from this same property: they provide information about the performance of data analysis methods under specified conditions, but provide no guarantee that patterns of performance hold in general.
One can partially address questions of generalization by examining a wide range of conditions, looking to see whether a pattern holds consistently or changes depending on features of the data-generating process.
Even this strategy has limitations, though.
Except for very simple processes, we can seldom consider every possible set of conditions.</p>
<p>As we will see in later chapters, the design of a simulation study typically entails making choices over very large spaces of possibility.
This flexibility leaves lots of room for discretion and judgement, and even for personal or professional biases <span class="citation">(<a href="#ref-boulesteix2020Replicationa">Boulesteix et al. 2020</a>)</span>.
Due to this flexibility, simulation findings are held in great skepticism by many.
The following motto summarizes the skeptic’s concern:</p>
<blockquote>
<p>Simulations are doomed to succeed.</p>
</blockquote>
<p>As this motto captures, simulations are alluring: once a simulation framework is set up, it is easy to tweak and adjust.
It is natural for us all to continue to do this until the simulation works “as it should.”
If our goal is to show something that we already believe is correct (e.g., that our fancy new estimation procedure is better than existing methods), we could probably find a way to align our simulation with our intuition.<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></p>
<p>Critiques of simulation studies often revolve around the <em>realism</em>, <em>relevance</em>, or <em>generality</em> of the data generating process.
Are the simulated data realistic, in the sense that they follow similar patterns to what one would see in real empirical data?
Are the explored aspects of the simulation relevant to what we would expect to find in practice?
Was the simulation systematic in exploring a wide variety of scenarios, so that general conclusions are warranted?</p>
<p>We see at least three principles for addressing such questions in one’s own work.
Perhaps most fundamental is to be transparent in one’s methods and reasoning:
explicitly state what was done, and provide code so that others can reproduce one’s results or tweak them to test variations of the data-generating process or alternative analysis strategies.
Another important component of a robust argument is to systematically vary the conditions under examination.
This is facilitated by writing code in a way to make it easy to simulate across a range of different data-generating scenarios.
Once that is in place, one can systematically explore myriad scenarios and report all of the results.
An aspiration of the simulation architect should be to explore the boundary conditions that separate where preferred methods work and where they break or fail.
Finally, one can draw on relevant statistical theory to support the design of a simulation and interpretation of its results.
Mathematical analysis might indicate that some features of a data-generating process will have a strong influence on the performance of a method, while other features will not matter at all when sample sizes are sufficiently large.
Well designed simulations will examine conditions that are motivated by or complement what is known based on existing statistical theory.</p>
<p>In addition to these principles, methodologists have proposed broader changes in practice to counter the potential for bias in methodological simulation studies.
<span class="citation">Morris, White, and Crowther (<a href="#ref-morris2019UsingSimulationStudies">2019</a>)</span> introduced a formal framework, called ADEMP, to guide the reporting of methodological simulations.
<span class="citation">Boulesteix, Lauer, and Eugster (<a href="#ref-boulesteix2013Plea">2013</a>)</span> argued for greater use of neutral comparison studies, in which the performance of alternative statistical methods are compared under a range of relevant conditions by methodological researchers who do not have vested interests in any specific method <span class="citation">(see also <a href="#ref-boulesteix2017evidencebased">Boulesteix, Wilson, and Hapfelmeier 2017</a>)</span>.
Further, <span class="citation">Siepe et al. (<a href="#ref-siepe2024SimulationStudiesMethodological">2024</a>)</span> argue for more routine pre-registration of methodological simulations to bring greater transparency and reduce the possibility of bias arising from flexibility in their design.</p>
</div>
<div id="simulating-to-learn" class="section level2 hasAnchor" number="1.3">
<h2 class="hasAnchor"><span class="header-section-number">1.3</span> Simulating to learn<a href="#simulating-to-learn" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Most of the examples of Monte Carlo simulation that we have mentioned thus far are drawn from formal methodological research, published in methodologically focused research journals.
If you do not identify as a methodologist, you may be wondering whether there is any benefit to learning how to do simulations—what’s the point, if you are never going to conduct methodological research studies or use simulation to aid in planning an empirical study?
However, we believe that simulation is an incredibly useful tool—and well worth learning, even outside the context of formal methodological research—for at least two reasons.</p>
<p>First, in order to do any sort of quantitative data analysis, you will need to make decisions about what methods to use.
Across fields, existing guidance about data analysis practice is almost certainly informed by simulation research of some form, whether well-designed and thorough or haphazard and poorly reasoned.
Consequently, having a high-level understanding of the logic and limitations of simulation will help you to be a critical consumer of methods research, even if you do not intend to conduct methods research of your own.</p>
<p>Second, we believe conducting simulations deepens one’s understanding of the logic of statistical modeling and statistical inference.
Learning a new statistical model (such as generalized linear mixed models) or analytic technique (such as multiple imputation by chained equations) requires taking in <em>a lot</em> of detailed information, from the assumptions of the model to the interpretation of parameter estimates to the best practices for estimation and what to do if some part of the process goes off.
To thoroughly digest all these details, we have found it invaluable to <em>simulate</em> data based on the model under consideration.
This usually requires translating mathematical notation into computer code, an exercise which makes the components of the model more tangible than just a jumble of Greek letters.
The simulated data is then available for inspection, summarizing, graphing, and further calculation, all of which can aid comprehension and interpretation.
Moreover, the process of simulating yields a dataset which can then be used to practice implementing the analysis procedure and interpreting the results.
We have found that building a habit of simulating is a highly effective way to learn new models and methods, worthwhile even if one has no intention of carrying out methodological research.
We might even go so far as to argue that <em>whatever you might think, you don’t really understand a statistical model until you’ve done a simulation of it.</em></p>
</div>
<div id="why-r" class="section level2 hasAnchor" number="1.4">
<h2 class="hasAnchor"><span class="header-section-number">1.4</span> Why R?<a href="#why-r" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>This book aims not only to introduce the conceptual principles of Monte Carlo simulation, but also to provide a practical guide to actually <em>conducting</em> simulation studies (whether for personal learning purposes or for formal methodological research).
And conducting simulations requires writing computer code (sometimes, lots of code!).
The computational principles and practices that we will describe are very general, not specific to any particular programming language, but for purposes of demonstrating, presenting examples, and practicing the process of developing a simulation, it helps to be specific.
To that end, we will be using R, a popular programming language that is widely used among statisticians, quantitative methodologists, and data scientists.
Our presentation will assume that readers are comfortable with writing R scripts to carry out tasks such as cleaning variables, summarizing data, creating data-based graphics, and running regression models (or more generally, estimating statistical models).</p>
<p>We have chosen to focus on R (rather than some other programming language) because both of us are intimately familiar with R and use it extensively in our day-to-day work.
Simply put, it is much easier to write in your native language than in one in which you are less fluent.
But beyond our own habits and preferences, there are several more principled reasons for using R.
<!-- TRIM? Subsequent paragraphs could probably be shortened into a single paragraph or maybe removed all together.--></p>
<p>R is free and open source software, which can be run under many different operating systems (Windows, Mac, Linux, etc.).
This is advantageous not only because of the cost, but also because it means that anyone with a computer—anywhere in the world—can access the software and could, if they wanted, re-run our provided code for themselves.
This makes R a good choice for practicing transparent and open science processes.</p>
<p>There is a very large, active, and diverse community of people who use, teach, and develop R.
It is used widely for applied data analysis and statistical work in such fields as education, psychology, economics, epidemiology, public health, and political science,
and is widely taught in quantitative methods and applied statistics courses.
Integral to the appeal of R is that it includes tens of thousands of contributed packages, which extend the core functionality of the language in myriad ways.
New statistical techniques are often quickly available in R, or can be accessed through R interfaces.
Increasingly, R can also be used to interface with other languages and platforms, such as running Python code via the <a href="https://rstudio.github.io/reticulate/"><code>reticulate</code></a> package, running Stan programs for Bayesian modeling via <a href="https://mc-stan.org/users/interfaces/rstan"><code>RStan</code></a>, or calling the h2o machine learning library using the <a href="https://cran.r-project.org/package=h2o"><code>h2o</code> package</a> <span class="citation">(<a href="#ref-fryda2014H2oInterfaceH2O">Fryda et al. 2014</a>)</span>.
The huge variety of statistical tools available in R makes it a fascinating place to learn and practice.</p>
<p>R does have a persistent reputation as being a challenging and difficult language to use.
This reputation might be partly attributable to its early roots, having been developed by highly technical statisticians who did not necessarily prioritize accessibility, legibility of code, or ease of use.
However, as the R community has grown, the availability of introductory documentation and learning materials has improved drastically, so that it is now much easier to access pedagogical materials and find help.</p>
<p>R’s reputation also probably partly stems from being a decentralized, open source project with many, many contributors.
Contributed R packages vary hugely in quality and depth of development; there are some amazingly powerful tools available but also much that is half-baked, poorly executed, or flat out wrong.
Because there is no central oversight or quality control, the onus is on the user to critically evaluate the packages that they use.
For newer users especially, we recommend focusing on more established and widely used packages, seeking input and feedback from more knowledgeable users, and taking time to validate functionality against other packages or software when possible.</p>
<p>A final contributor to R’s intimidating reputation might be its extreme flexibility.
As both a statistical analysis package and a fully functional programming language, R can do many things that other software packages cannot, but this also means that there are often many different ways to accomplish the same task.
In light of this situation, it is good to keep in mind that knowing a single way to do something is usually adequate—there is no need to learn six different words for hello, when one is enough to start a conversation.</p>
<p>On balance, we think that the many strengths of R make it worthwhile to learn and continue exploring. For simulation, in particular, R’s facility to easily write functions (bundles of commands that you can easily call in different manners), to work with multiple datasets in play at the same time, and to leverage the vast array of other people’s work all make it a very attractive language.</p>
</div>
<div id="organization-of-the-text" class="section level2 hasAnchor" number="1.5">
<h2 class="hasAnchor"><span class="header-section-number">1.5</span> Organization of the text<a href="#organization-of-the-text" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>We think of simulation studies as falling on a spectrum of formality.
On the least formal end, we may use simulations to learn a statistical model, investigating questions purely to satisfy our own curiosity.
On the most formal end, we may conduct carefully designed, pre-registered simulations that compare the performance of competing statistical methods across an array of data-generating conditions designed to inform practice in a particular research area.</p>
<p>Our central goal is to help you learn to work anywhere along this spectrum, from the most casual to the most principled.
To support that goal, the book is designed with a spiral structure, where we first present simpler and less formal examples that illustrate high-level principles, then revisit the component pieces, dissecting and exploring them in greater depth.
We defer discussion of concepts that are relevant only to more formal use-cases (such as the ADEMP framework of <span class="citation">Morris, White, and Crowther (<a href="#ref-morris2019UsingSimulationStudies">2019</a>)</span>) until later chapters.
We have also included many case studies throughout the book; these are designed to make the topics under discussion tangible, and are also designed to provide chunks of code that you emulate or even directly copy and use for your own purposes.</p>
<p>We divided the book into several parts.
In Part I (which you are reading now), we lay out our case for learning simulation, introduces some guidance on programming, and presents an initial, very simple simulation to set the stage for later discussion of design principles.
Part II lays out the core components (generating artificial data, applying analytic procedures, executing the simulations, and analyzing the simulation results) for simulating a single scenario. It then presents some more involved case studies that illustrate the principles of modular, tidy simulation design.
<!-- Need to define modular, tidy simulation design. -->
Part III moves to multifactor simulations, meaning simulations that look at more than one scenario or context.
Multifactor simulation is central to the design of more formal simulation studies because it is only by evaluating or comparing estimation procedures across multiple scenarios that we can begin to understand their general properties.</p>
<p>The book closes with two final parts.
Part IV covers some technical challenges that are commonly encountered when programming simulations, including reproducibility, parallel computing, and error handling.
Part V covers three extensions to specialized forms of simulation: simulating to calculate power, simulating within a potential outcomes framework for causal inference, and the parametric bootstrap. The specialized applications underscore how simulation can be used to answer a wide variety of questions across a range of contexts, thus connecting back to the broader purposes discussed above.
The book also includes appendices with some further guidance on writing R code and pointers to further resources.</p>
<!--chapter:end:001-introduction.Rmd-->
</div>
</div>
<div id="programming-preliminaries" class="section level1 hasAnchor" number="2">
<h1 class="hasAnchor"><span class="header-section-number">2</span> Programming Preliminaries<a href="#programming-preliminaries" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p>In this chapter, we introduce some essential programming concepts that may be less familiar to readers, but which are central to how we approach writing code for simulation studies.
We also explain some of the rationale and reasoning behind how we present example code throughout the book.</p>
<div id="welcome-to-the-tidyverse" class="section level2 hasAnchor" number="2.1">
<h2 class="hasAnchor"><span class="header-section-number">2.1</span> Welcome to the tidyverse<a href="#welcome-to-the-tidyverse" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Layered on top of R are a collection of contributed packages that make data wrangling and management much, much easier.
This collection is called <code>tidyverse</code> and it includes popular packages such as <code>dplyr</code>, <code>tidyr</code>, and <code>ggplot2</code>.
We use methods from the “tidyverse” throughout the book because it facilitates writing clean, concise code.
In particular, we make heavy use of the <code>dplyr</code> package for group-wise data manipulation, the <code>purrr</code> package for functional programming, and the <code>ggplot2</code> package for statistical graphics.
The <a href="https://r4ds.had.co.nz/">1st edition</a> or <a href="https://r4ds.hadley.nz/">2nd edition</a> of the free online textbook <em>R for Data Science</em> provide an excellent, thorough introduction to these packages, along with much more background on the tidyverse.
We will cite portions of this text throughout the book.</p>
<p>Loading the tidyverse packages is straightforward:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">library</span>( tidyverse )</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="fu">options</span>(<span class="fu">list</span>(<span class="at">dplyr.summarise.inform =</span> <span class="cn">FALSE</span>))</span></code></pre></div>
<p>(The second line is to turn off some of the persistent warnings generated by the <code>dplyr</code> function <code>summarize()</code>.)
These lines of code appear in the header of nearly every script we use.</p>
</div>
<div id="functions" class="section level2 hasAnchor" number="2.2">
<h2 class="hasAnchor"><span class="header-section-number">2.2</span> Functions<a href="#functions" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>If you are comfortable using R for data analysis tasks, you will be familiar with many of R’s functions.
R has function to do things like calculate a summary statistic from a list of numbers (e.g., <code>mean()</code>, <code>median()</code>, or <code>sd()</code>), calculate linear regression coefficient estimates from a dataset (<code>lm()</code>), or count the number of rows in a dataset (<code>nrow()</code>).
In the abstract, a function is a little machine for transforming ingredients into outputs, like a microwave (put a bag of kernels in and it will return hot, crunchy popcorn), a cheese shredder (put a block of mozzarella in and it transforms it into topping for your pizza), or a washing machine (put in dirty clothes and detergent and it will return clean but damp clothes).
A function takes in pieces of information specified by the user (the inputs), follows a set of instructions for transforming or summarizing those inputs, and then returns the result of the calculations (the outputs).</p>
<!--
![A function as a machine](image/function-machine.png){ width=50% }
LWM: Is this worth updating and including?  If included, cite in the text.
-->
<p>A function can do nearly anything as long as the calculation can be expressed in code—it can even produce output that is random.
For example, the <code>rnorm()</code> function takes as input a number <code>n</code> and returns that many random numbers, drawn from a standard normal distribution:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="fu">rnorm</span>(<span class="dv">3</span>)</span></code></pre></div>
<pre><code>## [1] 0.2462086 1.4243864 0.5022062</code></pre>
<p>Each time the function is called, it returns a different set of numbers:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="fu">rnorm</span>(<span class="dv">3</span>)</span></code></pre></div>
<pre><code>## [1]  1.1907636  0.7442724 -0.2877388</code></pre>
<p>The <code>rnorm()</code> function also has further input arguments that let the user specify the mean and standard deviation of the distribution from which numbers are drawn:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="fu">rnorm</span>(<span class="dv">3</span>, <span class="at">mean =</span> <span class="dv">10</span>, <span class="at">sd =</span> <span class="fl">0.5</span>)</span></code></pre></div>
<pre><code>## [1] 10.449196 10.277117  9.887358</code></pre>
<p>In writing code for simulations, we will make extensive use of this particular function and other functions that produce sequences of random numbers.
We will have more to say about random number generation later.</p>
<div id="rolling-your-own" class="section level3 hasAnchor" number="2.2.1">
<h3 class="hasAnchor"><span class="header-section-number">2.2.1</span> Rolling your own<a href="#rolling-your-own" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>In R, you can create your own function by specifying the pieces of input information, the steps to follow in transforming the inputs, and the result to return as output.
Learning to write your own functions to carry out calculations is an immensely useful skill that will greatly enhance your ability to accomplish a range of tasks.
Writing custom functions is also central to our approach to coding Monte Carlo simulations, and so we highlight some of the key considerations here.
<a href="https://r4ds.had.co.nz/functions.html">Chapter 19 of R for Data Science (1st edition)</a> provides an in-depth discussion of how to write your own functions.</p>
<p>Here is an example of a custom function called <code>one_run()</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>one_run <span class="ot">&lt;-</span> <span class="cf">function</span>( N, mn, sd ) {</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>  vals <span class="ot">&lt;-</span> <span class="fu">rnorm</span>( N, <span class="at">mean =</span> mn, <span class="at">sd =</span> sd )</span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>  tt <span class="ot">&lt;-</span> <span class="fu">t.test</span>( vals )</span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a>  pvalue <span class="ot">&lt;-</span> tt<span class="sc">$</span>p.value</span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a>  <span class="fu">return</span>(pvalue)</span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a>}</span></code></pre></div>
<p>The first line specifies that we are creating a function that takes inputs <code>N</code>, <code>mn</code>, and <code>sd</code>. These are called the <em>parameters</em>, <em>inputs</em>, or <em>arguments</em> of the function. The remaining lines inside the curly brackets are called the <em>body</em> of the function. These lines specify the instructions to follow in transforming the inputs into an output:</p>
<ol style="list-style-type: decimal">
<li>Generate a random sample of <code>N</code> observations from a normal distribution with mean <code>mn</code> and store the result in <code>vals</code>.</li>
<li>Use the built-in function <code>t.test()</code> to compute a one-sample t-test for the null hypothesis that the population mean is zero, then store the result in <code>tt</code>.</li>
<li>Extract the p-value from the t-test store the result in <code>pvalue</code>.</li>
<li>Return <code>pvalue</code> as output.</li>
</ol>
<p>Having created the function, we can then use it with any inputs that we like:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="fu">one_run</span>( <span class="dv">100</span>, <span class="dv">5</span>, <span class="dv">1</span> )</span></code></pre></div>
<pre><code>## [1] 2.681939e-69</code></pre>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="fu">one_run</span>( <span class="dv">10</span>, <span class="fl">0.3</span>, <span class="dv">1</span> )</span></code></pre></div>
<pre><code>## [1] 0.7671967</code></pre>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="fu">one_run</span>( <span class="dv">10</span>, <span class="fl">0.3</span>, <span class="fl">0.2</span> )</span></code></pre></div>
<pre><code>## [1] 8.683372e-05</code></pre>
<p>In each case, the output of the function is a p-value from a simulated sample of data. The function produces a different answer each time because its instructions involve generating random numbers each time it is called.
In essence, our custom function is just a short-cut for carrying out its instructions.
Writing it saves us from having to repeatedly write or copy-paste the lines of code inside its body.</p>
</div>
<div id="a-dangerous-function" class="section level3 hasAnchor" number="2.2.2">
<h3 class="hasAnchor"><span class="header-section-number">2.2.2</span> A dangerous function<a href="#a-dangerous-function" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Writing custom functions will prove to be crucial for effectively implementing Monte Carlo simulations.
However, designing custom functions does take practice to master.
It also requires a degree of care above and beyond what is needed just to use R’s built-in functions.</p>
<p>One of the common mistakes encountered in writing custom functions is to let the function depend on information that is not part of the input arguments.
For example, consider the following script, which includes a nonsensical custom function called <code>funky()</code>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>secret <span class="ot">&lt;-</span> <span class="dv">3</span></span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a>funky <span class="ot">&lt;-</span> <span class="cf">function</span>(input1, input2, input3) {</span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a>  </span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a>  <span class="co"># do funky stuff</span></span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a>  ratio <span class="ot">&lt;-</span> input1 <span class="sc">/</span> (input2 <span class="sc">+</span> <span class="dv">4</span>)</span>
<span id="cb15-7"><a href="#cb15-7" tabindex="-1"></a>  funky_output <span class="ot">&lt;-</span> input3 <span class="sc">*</span> ratio <span class="sc">+</span> secret</span>
<span id="cb15-8"><a href="#cb15-8" tabindex="-1"></a>  </span>
<span id="cb15-9"><a href="#cb15-9" tabindex="-1"></a>  <span class="fu">return</span>(funky_output)  </span>
<span id="cb15-10"><a href="#cb15-10" tabindex="-1"></a>}</span>
<span id="cb15-11"><a href="#cb15-11" tabindex="-1"></a></span>
<span id="cb15-12"><a href="#cb15-12" tabindex="-1"></a><span class="fu">funky</span>(<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">5</span>)</span></code></pre></div>
<pre><code>## [1] 5.5</code></pre>
<p><code>funky</code> takes inputs <code>input1</code>, <code>input2</code>, and <code>input3</code>, but its instructions also depend on the quantity <code>secret</code>.
What happens if we change the value of <code>secret</code>?</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a>secret <span class="ot">&lt;-</span> <span class="dv">100</span></span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a><span class="fu">funky</span>(<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">5</span>)</span></code></pre></div>
<pre><code>## [1] 102.5</code></pre>
<p>Even though we give it the same arguments as previously, the output of the function is different.
This sort of behavior is confusing.
Unless the function involves generating random numbers, we would generally expect it to return the exact same output if we give it the same inputs.
Even worse, we get a rather cryptic error if the value of <code>secret</code> is not compatible with what the function expects:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a>secret <span class="ot">&lt;-</span> <span class="st">&quot;A&quot;</span></span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a><span class="fu">funky</span>(<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">5</span>)</span></code></pre></div>
<pre><code>## Error in input3 * ratio + secret: non-numeric argument to binary operator</code></pre>
<p>If we are not careful, we will end up with very confusing code that can very easily lead to unintended results and errors.</p>
<p>To avoid this issue, it is important for functions to only use information that is explicitly provided to it through its arguments.
This is the principle of <em>isolating the inputs</em>.
If the result of a function is supposed to depend on a quantity, then we should include that quantity among the input arguments.
We can fix our example function by including <code>secret</code> as an argument:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a>secret <span class="ot">&lt;-</span> <span class="dv">3</span></span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" tabindex="-1"></a>funkier <span class="ot">&lt;-</span> <span class="cf">function</span>(input1, input2, input3, secret) {</span>
<span id="cb21-4"><a href="#cb21-4" tabindex="-1"></a>  </span>
<span id="cb21-5"><a href="#cb21-5" tabindex="-1"></a>  <span class="co"># do funky stuff</span></span>
<span id="cb21-6"><a href="#cb21-6" tabindex="-1"></a>  ratio <span class="ot">&lt;-</span> input1 <span class="sc">/</span> (input2 <span class="sc">+</span> <span class="dv">4</span>)</span>
<span id="cb21-7"><a href="#cb21-7" tabindex="-1"></a>  funky_output <span class="ot">&lt;-</span> input3 <span class="sc">*</span> ratio <span class="sc">+</span> secret</span>
<span id="cb21-8"><a href="#cb21-8" tabindex="-1"></a>  </span>
<span id="cb21-9"><a href="#cb21-9" tabindex="-1"></a>  <span class="fu">return</span>(funky_output)  </span>
<span id="cb21-10"><a href="#cb21-10" tabindex="-1"></a>}</span>
<span id="cb21-11"><a href="#cb21-11" tabindex="-1"></a></span>
<span id="cb21-12"><a href="#cb21-12" tabindex="-1"></a><span class="fu">funkier</span>(<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">3</span>)</span></code></pre></div>
<pre><code>## [1] 5.5</code></pre>
<p>Now the output of the function is always the same, regardless of the value of other objects in R:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a>secret <span class="ot">&lt;-</span> <span class="dv">100</span></span>
<span id="cb23-2"><a href="#cb23-2" tabindex="-1"></a><span class="fu">funkier</span>(<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">3</span>)</span></code></pre></div>
<pre><code>## [1] 5.5</code></pre>
<p>The <em>input parameter</em> <code>secret</code> holds sway here, even though there is also an object with the same name.<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> If we want to try 100, we have to do so <em>explicitly</em>:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a><span class="fu">funkier</span>(<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">100</span>)</span></code></pre></div>
<pre><code>## [1] 102.5</code></pre>
<p>When writing your own functions, it may not be obvious that your function depends on external quantities and does not isolate the inputs.
In our experience, one of the best ways to detect this issue is to clear the R environment and start from a fresh palette, run the code to create the function, and call the function (perhaps more than once) to ensure that it works as expected.
Here is an illustration of what happens when we follow this process with our problematic custom function:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" tabindex="-1"></a><span class="co"># clear environment</span></span>
<span id="cb27-2"><a href="#cb27-2" tabindex="-1"></a><span class="fu">rm</span>(<span class="at">list=</span><span class="fu">ls</span>()) </span>
<span id="cb27-3"><a href="#cb27-3" tabindex="-1"></a></span>
<span id="cb27-4"><a href="#cb27-4" tabindex="-1"></a><span class="co"># create function</span></span>
<span id="cb27-5"><a href="#cb27-5" tabindex="-1"></a>funky <span class="ot">&lt;-</span> <span class="cf">function</span>(input1, input2, input3) {</span>
<span id="cb27-6"><a href="#cb27-6" tabindex="-1"></a>  </span>
<span id="cb27-7"><a href="#cb27-7" tabindex="-1"></a>  <span class="co"># do funky stuff</span></span>
<span id="cb27-8"><a href="#cb27-8" tabindex="-1"></a>  ratio <span class="ot">&lt;-</span> input1 <span class="sc">/</span> (input2 <span class="sc">+</span> <span class="dv">4</span>)</span>
<span id="cb27-9"><a href="#cb27-9" tabindex="-1"></a>  funky_output <span class="ot">&lt;-</span> input3 <span class="sc">*</span> ratio <span class="sc">+</span> secret</span>
<span id="cb27-10"><a href="#cb27-10" tabindex="-1"></a>  </span>
<span id="cb27-11"><a href="#cb27-11" tabindex="-1"></a>  <span class="fu">return</span>(funky_output)  </span>
<span id="cb27-12"><a href="#cb27-12" tabindex="-1"></a>}</span>
<span id="cb27-13"><a href="#cb27-13" tabindex="-1"></a></span>
<span id="cb27-14"><a href="#cb27-14" tabindex="-1"></a><span class="co"># test the function</span></span>
<span id="cb27-15"><a href="#cb27-15" tabindex="-1"></a><span class="fu">funky</span>(<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">5</span>)</span></code></pre></div>
<pre><code>## Error in funky(3, 2, 5): object &#39;secret&#39; not found</code></pre>
<p>We get an error because the external quantity is not available.
Here is the same process using our corrected function:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" tabindex="-1"></a><span class="co"># clear environment</span></span>
<span id="cb29-2"><a href="#cb29-2" tabindex="-1"></a><span class="fu">rm</span>(<span class="at">list=</span><span class="fu">ls</span>()) </span>
<span id="cb29-3"><a href="#cb29-3" tabindex="-1"></a></span>
<span id="cb29-4"><a href="#cb29-4" tabindex="-1"></a><span class="co"># create function</span></span>
<span id="cb29-5"><a href="#cb29-5" tabindex="-1"></a>funkier <span class="ot">&lt;-</span> <span class="cf">function</span>(input1, input2, input3, secret) {</span>
<span id="cb29-6"><a href="#cb29-6" tabindex="-1"></a>  </span>
<span id="cb29-7"><a href="#cb29-7" tabindex="-1"></a>  <span class="co"># do funky stuff</span></span>
<span id="cb29-8"><a href="#cb29-8" tabindex="-1"></a>  ratio <span class="ot">&lt;-</span> input1 <span class="sc">/</span> (input2 <span class="sc">+</span> <span class="dv">4</span>)</span>
<span id="cb29-9"><a href="#cb29-9" tabindex="-1"></a>  funky_output <span class="ot">&lt;-</span> input3 <span class="sc">*</span> ratio <span class="sc">+</span> secret</span>
<span id="cb29-10"><a href="#cb29-10" tabindex="-1"></a>  </span>
<span id="cb29-11"><a href="#cb29-11" tabindex="-1"></a>  <span class="fu">return</span>(funky_output)  </span>
<span id="cb29-12"><a href="#cb29-12" tabindex="-1"></a>}</span>
<span id="cb29-13"><a href="#cb29-13" tabindex="-1"></a></span>
<span id="cb29-14"><a href="#cb29-14" tabindex="-1"></a></span>
<span id="cb29-15"><a href="#cb29-15" tabindex="-1"></a><span class="co"># test the function</span></span>
<span id="cb29-16"><a href="#cb29-16" tabindex="-1"></a><span class="fu">funkier</span>(<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="at">secret =</span> <span class="dv">3</span>)</span></code></pre></div>
<pre><code>## [1] 5.5</code></pre>
</div>
<div id="using-named-arguments" class="section level3 hasAnchor" number="2.2.3">
<h3 class="hasAnchor"><span class="header-section-number">2.2.3</span> Using Named Arguments<a href="#using-named-arguments" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>When calling a function (whether it is a built-in function or a custom function that you developed), you can specify which values correspond to which arguments using argument names.
Using argument names greatly enhances the readability and flexibility of function calls.
When you specify inputs by name, R matches the values to the arguments based on the names rather than the order in which they appear.
This feature is particularly useful in complex functions with many optional arguments.</p>
<p>For example, consider the function <code>one_run()</code> from @ref(rolling-your-own):</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" tabindex="-1"></a>one_run <span class="ot">&lt;-</span> <span class="cf">function</span>( N, mn, sd ) {</span>
<span id="cb31-2"><a href="#cb31-2" tabindex="-1"></a>  vals <span class="ot">&lt;-</span> <span class="fu">rnorm</span>( N, <span class="at">mean =</span> mn, <span class="at">sd =</span> sd )</span>
<span id="cb31-3"><a href="#cb31-3" tabindex="-1"></a>  tt <span class="ot">&lt;-</span> <span class="fu">t.test</span>( vals )</span>
<span id="cb31-4"><a href="#cb31-4" tabindex="-1"></a>  pvalue <span class="ot">&lt;-</span> tt<span class="sc">$</span>p.value</span>
<span id="cb31-5"><a href="#cb31-5" tabindex="-1"></a>  <span class="fu">return</span>(pvalue)</span>
<span id="cb31-6"><a href="#cb31-6" tabindex="-1"></a>}</span></code></pre></div>
<p>You could call <code>one_run()</code> with <em>named</em> arguments in any order:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" tabindex="-1"></a>result <span class="ot">&lt;-</span> <span class="fu">one_run</span>(<span class="at">sd =</span> <span class="fl">0.5</span>, <span class="at">mn =</span> <span class="dv">2</span>, <span class="at">N =</span> <span class="dv">500</span>)</span></code></pre></div>
<p>In this call, R knows which value to assign to each argument, so we could list the arguments however we like.</p>
<p>Without naming, we would have to specify the arguments in the exact order that they appear in the function definition:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" tabindex="-1"></a>result <span class="ot">&lt;-</span> <span class="fu">one_run</span>( <span class="dv">500</span>, <span class="dv">2</span>, <span class="fl">0.5</span> )</span></code></pre></div>
<p>Without the argument names, this line of code is harder to follow—you have to know more about the design of the function to understand how it is being used in this instance.</p>
<p>Getting in the habit of using named arguments will help you avoid errors.
If you pass arguments without naming, and in the wrong order, you can end up with very strange results that are hard to diagnose.
Even if you get it right, if someone later changes the function (say by adding a new argument in the middle of the list), your code will suddenly break with no explanation.</p>
</div>
<div id="argument-defaults" class="section level3 hasAnchor" number="2.2.4">
<h3 class="hasAnchor"><span class="header-section-number">2.2.4</span> Argument Defaults<a href="#argument-defaults" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Default arguments allow you to specify typical values for parameters that a user might not need to change every time they use the function.
This can make the function easier to use and less error-prone because the defaults ensure that the function behaves sensibly even when some arguments are not explicitly provided. For example, let us revise the <code>one_run()</code> function from above to use default arguments:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" tabindex="-1"></a>one_run <span class="ot">&lt;-</span> <span class="cf">function</span>( <span class="at">N =</span> <span class="dv">10</span>, <span class="at">mn =</span> <span class="dv">0</span>, <span class="at">sd =</span> <span class="dv">1</span> ) {</span>
<span id="cb34-2"><a href="#cb34-2" tabindex="-1"></a>  vals <span class="ot">&lt;-</span> <span class="fu">rnorm</span>( N, <span class="at">mean =</span> mn, <span class="at">sd =</span> sd )</span>
<span id="cb34-3"><a href="#cb34-3" tabindex="-1"></a>  tt <span class="ot">&lt;-</span> <span class="fu">t.test</span>( vals )</span>
<span id="cb34-4"><a href="#cb34-4" tabindex="-1"></a>  pvalue <span class="ot">&lt;-</span> tt<span class="sc">$</span>p.value</span>
<span id="cb34-5"><a href="#cb34-5" tabindex="-1"></a>  <span class="fu">return</span>(pvalue)</span>
<span id="cb34-6"><a href="#cb34-6" tabindex="-1"></a>}</span></code></pre></div>
<p>Now our function has a default for <code>N</code> of 10, for <code>mn</code> of 0, and for <code>s</code> of 1.
This means a user can run the function simply by calling <code>one_run()</code> without any inputs. Doing so will generate a p-value from a sample of 10 observations with a mean of zero and a standard deviation of 1.</p>
<p>Once we have our function with defaults, we can call the function while specifying only the inputs that differ from the default values:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" tabindex="-1"></a>bigger_sample <span class="ot">&lt;-</span> <span class="fu">one_run</span>( <span class="at">N =</span> <span class="dv">50</span> )</span></code></pre></div>
<p>The function will use its default values for <code>mn</code> and <code>s</code>.
Using defaults lets the user call the function more succinctly.</p>
<p>Later chapters will have much more to say about the process of writing custom functions, as well as many further illustrations and examples.</p>
</div>
<div id="function-skeletons" class="section level3 hasAnchor" number="2.2.5">
<h3 class="hasAnchor"><span class="header-section-number">2.2.5</span> Function skeletons<a href="#function-skeletons" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>In discussing how to write functions for simulations, we will often present <em>function skeletons</em>. By a skeleton, we mean code that creates a function with a specific set of input arguments, but where the body is left partially or fully unspecified.
Here is a cursory example of a function skeleton:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" tabindex="-1"></a>run_simulation <span class="ot">&lt;-</span> <span class="cf">function</span>( N, J, mu, sigma, tau ) {</span>
<span id="cb36-2"><a href="#cb36-2" tabindex="-1"></a>  <span class="co"># simulate data</span></span>
<span id="cb36-3"><a href="#cb36-3" tabindex="-1"></a>  <span class="co"># apply estimation procedure</span></span>
<span id="cb36-4"><a href="#cb36-4" tabindex="-1"></a>  <span class="co"># repeat</span></span>
<span id="cb36-5"><a href="#cb36-5" tabindex="-1"></a>  <span class="co"># summarize results</span></span>
<span id="cb36-6"><a href="#cb36-6" tabindex="-1"></a>  <span class="fu">return</span>(results)</span>
<span id="cb36-7"><a href="#cb36-7" tabindex="-1"></a>}</span></code></pre></div>
<p>In subsequent chapters, we will use function skeletons to outline the organization of code for simulation studies.
The skeleton headers make clear what the inputs to the function need to be.
Sometimes, we will leave comments in the body of the skeleton to sketch out the general flow of calculations that need to happen.
Depending on the details of the simulation, the specifics of these steps might be quite different, but the general structure will often be quite consistent.
Finally, the last line of the skeleton indicates the value that should be returned as output of the function.
Thus, skeletons are kind of like <a href="https://www.madlibs.com/">Mad Libs</a>, but with R code instead of parts of speech.</p>
</div>
</div>
<div id="pipe-dreams" class="section level2 hasAnchor" number="2.3">
<h2 class="hasAnchor"><span class="header-section-number">2.3</span> <code>\&gt;</code> (Pipe) dreams<a href="#pipe-dreams" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Many of the functions from <code>tidyverse</code> packages are designed to make it easy to use them in sequence via the <code>|&gt;</code> symbol, or <em>pipe</em>.<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>
The pipe allows us to <em>compose</em> several functions, meaning to write a chain of several functions as a sequence, where the result of each function becomes the first input to the next function.
In code written with the pipe, the order of function calls follows like a story book or cake recipe, making it easier to see what is happening at each step in the sequence.</p>
<p>Consider the hypothetical functions <code>f()</code>, <code>g()</code>, and <code>h()</code>, and suppose we want to do a calculation that involves composing all three functions.
One way to write this calculation is</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" tabindex="-1"></a>res1 <span class="ot">&lt;-</span> <span class="fu">f</span>(my_data, <span class="at">a =</span> <span class="dv">4</span>)</span>
<span id="cb37-2"><a href="#cb37-2" tabindex="-1"></a>res2 <span class="ot">&lt;-</span> <span class="fu">g</span>(res1, <span class="at">b =</span> <span class="cn">FALSE</span>)</span>
<span id="cb37-3"><a href="#cb37-3" tabindex="-1"></a>result <span class="ot">&lt;-</span> <span class="fu">h</span>(res2, <span class="at">c =</span> <span class="st">&quot;hot sauce&quot;</span>)</span></code></pre></div>
<p>We have to store the result of each intermediate step in an object, and it takes a careful read of the code to see that we are using <code>res1</code> as input to <code>g()</code> and <code>res2</code> as input to <code>h()</code>.</p>
<p>Alternately, we could try to write all the calculations as one line:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" tabindex="-1"></a>result <span class="ot">&lt;-</span> <span class="fu">h</span>( <span class="fu">g</span>( <span class="fu">f</span>( my_data, <span class="at">a =</span> <span class="dv">4</span> ), <span class="at">b =</span> <span class="cn">FALSE</span> ), <span class="at">c =</span> <span class="st">&quot;hot sauce&quot;</span> )</span></code></pre></div>
<p>This is a mess. It takes very careful parsing to see that the <code>b</code> argument is called as part of <code>g()</code> and the <code>c</code> argument is part of h()`, and the order in which the functions appear is not the same as the order in which they are calculated.</p>
<p>With the pipe we can write the same calculation as</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" tabindex="-1"></a>result <span class="ot">&lt;-</span> </span>
<span id="cb39-2"><a href="#cb39-2" tabindex="-1"></a>  my_data <span class="sc">|&gt;</span>         <span class="co"># initial dataset</span></span>
<span id="cb39-3"><a href="#cb39-3" tabindex="-1"></a>  <span class="fu">f</span>(<span class="at">a =</span> <span class="dv">4</span>) <span class="sc">|&gt;</span>        <span class="co"># do f() to it</span></span>
<span id="cb39-4"><a href="#cb39-4" tabindex="-1"></a>  <span class="fu">g</span>(<span class="at">b =</span> <span class="cn">FALSE</span>) <span class="sc">|&gt;</span>    <span class="co"># then do g()</span></span>
<span id="cb39-5"><a href="#cb39-5" tabindex="-1"></a>  <span class="fu">h</span>(<span class="at">c =</span> <span class="st">&quot;hot sauce&quot;</span>) <span class="co"># then do h()</span></span></code></pre></div>
<p>This addresses the all the issues with our previous attempts:
the order in which the functions appear is the same as the order in which they are executed;
the additional arguments are clearly associated with the relevant functions;
and there is only a single object holding the results of the calculations.
Pipes are a very nice technique for writing clear code that is easy for others to follow.<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a></p>
<!-- Should we add a section on tibbles, since using tibbles is a major design principle? -->
</div>
<div id="recipes-versus-patterns" class="section level2 hasAnchor" number="2.4">
<h2 class="hasAnchor"><span class="header-section-number">2.4</span> Recipes versus Patterns<a href="#recipes-versus-patterns" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>As we will elaborate in subsequent chapters, we follow a modular approach to writing simulations, in which each component of the simulation is represented by its own custom function or its own object in R.
This modular approach leads to code that always has the same broad structure and where the process of implementing the simulation follows a set sequence of steps.
We start by coding a data-generating process, then write one or more data-analysis methods, then determine how to evaluate the performance of the methods, and finally implement an experimental design to examine the performance of the methods across multiple scenarios.
Over the next several chapters, we will walk through this process several times.</p>
<p>Although we always follow the same broad process, the case studies that we will present are <em>not</em> intended as a cookbook that must be rigidly followed.
In our experience, the specific features of a data-generating model, estimator, or research question sometimes require tweaking the template or switching up how we implement some aspect of the simulation.
And sometimes, it might just be a question of style or preference.
Because of this, we have purposely constructed the examples presented throughout the book to use different variations of our central theme rather than always following the exact same style and structure.
We hope that presenting these variants and adaptations will both expand your sense of what is possible and also help you to recognize the core design principles—in other words, to distinguish the forest from the trees.
Of course, we would welcome and encourage you to take any of the code verbatim, tweak and adapt it for your own purposes, and use it however you see fit.
Adapting a good example is usually much easier than starting from a blank screen.</p>
</div>
<div id="exercises" class="section level2 hasAnchor" number="2.5">
<h2 class="hasAnchor"><span class="header-section-number">2.5</span> Exercises<a href="#exercises" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<ol style="list-style-type: decimal">
<li><p>Revise the <code>one_run()</code> function to use <code>|&gt;</code> instead of storing the simulated sample in <code>vals</code>.</p></li>
<li><p>Modify the <code>one_run()</code> function to return a <code>tibble()</code> that includes separate columns for the test statistic (called <code>tt$statistic</code>), the p-value, and the lower and upper end-points of the confidence interval (called <code>tt$conf.int</code>).</p></li>
<li><p>Modify the <code>one_run()</code> function so that the sample of data is generated from a non-central t distribution by substituting R’s <code>rt()</code> function in place of <code>rnorm()</code>. Make sure to modify the arguments (and argument names) of <code>one_run()</code> to allow the user to specify the non-centrality and degrees of freedom parameters of the non-central t distribution.</p></li>
<li><p>The non-central t distribution is usually parameterized in terms of non-centrality parameter <span class="math inline">\(\delta\)</span> and degrees of freedom <span class="math inline">\(\nu\)</span>, and these parameters determine the mean and spread of the distribution. Specifically, the mean of the non-central t distribution is
<span class="math display">\[\text{E}(T) = \delta \times \sqrt{\frac{\nu}{2}} \times \frac{\Gamma((\nu - 1) / 2)}{\Gamma(\nu / 2)},\]</span>
where <span class="math inline">\(\Gamma()\)</span> is the gamma function (called <code>gamma()</code> in R). Create a version of the <code>one_run()</code> function that generates data based on a non-central t distribution, but where the input arguments are <code>mn</code> for the mean and <code>df</code> for the degrees of freedom. Here is a function skeleton to get started:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" tabindex="-1"></a>one_run <span class="ot">&lt;-</span> <span class="cf">function</span>( <span class="at">N =</span> <span class="dv">10</span>, <span class="at">mn =</span> <span class="dv">5</span>, <span class="at">df =</span> <span class="dv">4</span>) {</span>
<span id="cb40-2"><a href="#cb40-2" tabindex="-1"></a></span>
<span id="cb40-3"><a href="#cb40-3" tabindex="-1"></a>  <span class="co"># generate data from non-central t distribution</span></span>
<span id="cb40-4"><a href="#cb40-4" tabindex="-1"></a>  <span class="co"># vals &lt;- </span></span>
<span id="cb40-5"><a href="#cb40-5" tabindex="-1"></a></span>
<span id="cb40-6"><a href="#cb40-6" tabindex="-1"></a>  <span class="co"># calculate one-sample t-test</span></span>
<span id="cb40-7"><a href="#cb40-7" tabindex="-1"></a>  tt <span class="ot">&lt;-</span> <span class="fu">t.test</span>( vals )</span>
<span id="cb40-8"><a href="#cb40-8" tabindex="-1"></a></span>
<span id="cb40-9"><a href="#cb40-9" tabindex="-1"></a>  <span class="co"># compile results into a tibble and return</span></span>
<span id="cb40-10"><a href="#cb40-10" tabindex="-1"></a>  <span class="co"># res &lt;- </span></span>
<span id="cb40-11"><a href="#cb40-11" tabindex="-1"></a></span>
<span id="cb40-12"><a href="#cb40-12" tabindex="-1"></a>  <span class="fu">return</span>(res)</span>
<span id="cb40-13"><a href="#cb40-13" tabindex="-1"></a>}</span></code></pre></div></li>
<li><p>Modify <code>one_run()</code> to allow the user to specify a hypothesized value for the population mean, to use when calculating the one-sample t-test results.</p></li>
</ol>
<!--chapter:end:003-programming-preliminaries.Rmd-->
</div>
</div>
<div id="t-test-simulation" class="section level1 hasAnchor" number="3">
<h1 class="hasAnchor"><span class="header-section-number">3</span> An initial simulation<a href="#t-test-simulation" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p>To begin learning about simulation, a good starting place is to examine a small, concrete example.
This example illustrates how simulation involves replicating the data-generating and data-analysis processes, followed by aggregating the results across replications.
Our little example encapsulates the bulk of our approach to Monte Carlo simulation, touching on all the main components involved.
In subsequent chapters we will look at each of these components in greater detail.
But first, let us look at a simulation of a very simple statistical problem.</p>
<p>The one-sample <span class="math inline">\(t\)</span>-test is one of the most basic methods in the statistics literature.
It tests a null hypothesis that a population mean of some variable is equal to a specific value by comparing the mean of a sample of data to the hypothesized value.
If the sample average is discrepant (very different) from the null value, relative to how uncertain we are about our estimate, then the hypothesis is rejected.
The test can also be used to generate a confidence interval for the population mean.
If the sample consists of independent observations and the variable is normally distributed in the population, then the confidence interval will have exact coverage, in the sense that 95% intervals will include the population mean in 95 out of 100 tries.
But what if the population variable is not normally distributed?</p>
<p>To find out, let us look at the coverage of the <span class="math inline">\(t\)</span>-test’s 95% confidence interval for the population mean when the method’s normality assumption is violated.
<em>Coverage</em> is the chance of a confidence interval capturing the true parameter value.
To examine coverage, we will simulate many samples from a non-normal population with a specified mean, calculate a confidence interval based on each sample, and see how many of the confidence intervals cover the known true population mean.</p>
<p>Before getting to the simulation, let’s look at the data-analysis procedure we will be investigating.
Here is the result of conducting a <span class="math inline">\(t\)</span>-test on some fake data, generated from a normal distribution:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" tabindex="-1"></a><span class="co"># make fake data</span></span>
<span id="cb41-2"><a href="#cb41-2" tabindex="-1"></a>dat <span class="ot">&lt;-</span> <span class="fu">rnorm</span>( <span class="at">n =</span> <span class="dv">10</span>, <span class="at">mean =</span> <span class="dv">4</span>, <span class="at">sd =</span> <span class="dv">2</span> )</span>
<span id="cb41-3"><a href="#cb41-3" tabindex="-1"></a></span>
<span id="cb41-4"><a href="#cb41-4" tabindex="-1"></a><span class="co"># conduct the test</span></span>
<span id="cb41-5"><a href="#cb41-5" tabindex="-1"></a>tt <span class="ot">&lt;-</span> <span class="fu">t.test</span>( dat )</span>
<span id="cb41-6"><a href="#cb41-6" tabindex="-1"></a>tt</span></code></pre></div>
<pre><code>## 
##  One Sample t-test
## 
## data:  dat
## t = 6.0878, df = 9, p-value = 0.0001819
## alternative hypothesis: true mean is not equal to 0
## 95 percent confidence interval:
##  2.164025 4.723248
## sample estimates:
## mean of x 
##  3.443636</code></pre>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" tabindex="-1"></a><span class="co"># examine the confidence interval</span></span>
<span id="cb43-2"><a href="#cb43-2" tabindex="-1"></a>tt<span class="sc">$</span>conf.int</span></code></pre></div>
<pre><code>## [1] 2.164025 4.723248
## attr(,&quot;conf.level&quot;)
## [1] 0.95</code></pre>
<p>We generated data with a true (population) mean of 4. Did we capture it? To check, we can use the <code>findInterval()</code> function, which checks to see where the first number lies relative to the range given in the second argument.
Here is an illustration of the syntax:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1" tabindex="-1"></a><span class="fu">findInterval</span>( <span class="dv">1</span>, <span class="fu">c</span>(<span class="dv">20</span>, <span class="dv">30</span>) )</span></code></pre></div>
<pre><code>## [1] 0</code></pre>
<div class="sourceCode" id="cb47"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1" tabindex="-1"></a><span class="fu">findInterval</span>( <span class="dv">25</span>, <span class="fu">c</span>(<span class="dv">20</span>, <span class="dv">30</span>) )</span></code></pre></div>
<pre><code>## [1] 1</code></pre>
<div class="sourceCode" id="cb49"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1" tabindex="-1"></a><span class="fu">findInterval</span>( <span class="dv">40</span>, <span class="fu">c</span>(<span class="dv">20</span>, <span class="dv">30</span>) )</span></code></pre></div>
<pre><code>## [1] 2</code></pre>
<p>The <code>findInterval()</code> returns a <code>1</code> if the value of the first argument value is in the interval specified in the second argument.</p>
<p>We can apply it to check whether our estimated CI covers the true population mean:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1" tabindex="-1"></a><span class="fu">findInterval</span>( <span class="dv">4</span>, tt<span class="sc">$</span>conf.int )</span></code></pre></div>
<pre><code>## [1] 1</code></pre>
<p>In this instance, <code>findInterval()</code> is equal to <code>1</code>, which means our CI captured the true population mean of 4.</p>
<p>Here is the full code for simulating data, computing the data-analysis procedure, and evaluating the result:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1" tabindex="-1"></a><span class="co"># make fake data</span></span>
<span id="cb53-2"><a href="#cb53-2" tabindex="-1"></a>dat <span class="ot">&lt;-</span> <span class="fu">rnorm</span>( <span class="at">n =</span> <span class="dv">10</span>, <span class="at">mean =</span> <span class="dv">4</span>, <span class="at">sd =</span> <span class="dv">2</span> )</span>
<span id="cb53-3"><a href="#cb53-3" tabindex="-1"></a></span>
<span id="cb53-4"><a href="#cb53-4" tabindex="-1"></a><span class="co"># conduct the test</span></span>
<span id="cb53-5"><a href="#cb53-5" tabindex="-1"></a>tt <span class="ot">&lt;-</span> <span class="fu">t.test</span>( dat )</span>
<span id="cb53-6"><a href="#cb53-6" tabindex="-1"></a></span>
<span id="cb53-7"><a href="#cb53-7" tabindex="-1"></a><span class="co"># evaluate the results</span></span>
<span id="cb53-8"><a href="#cb53-8" tabindex="-1"></a><span class="fu">findInterval</span>( <span class="dv">4</span>, tt<span class="sc">$</span>conf.int ) <span class="sc">==</span> <span class="dv">1</span></span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>The above code captures the basic form of a single simulation trial: make the data, analyze the data, decide how well we did.
The code also illustrates a good way to figure out the details of a simulation: start by figuring out what a single iteration of the simulation might look like.
Starting by mucking about this way also allows us to test and develop our code in an interactive, exploratory fashion. For instance, we can play with <code>findInterval()</code> to figure out how to use it to determine whether our confidence interval captured the truth.
Once we have arrived at working code for a single iteration, we are in a good position to start writing functions to implement the actual simulation.
For now, we have generated data from a normal distribution; we will later revise the code to generate data from a non-normal population distribution.</p>
<div id="simulating-a-single-scenario" class="section level2 hasAnchor" number="3.1">
<h2 class="hasAnchor"><span class="header-section-number">3.1</span> Simulating a single scenario<a href="#simulating-a-single-scenario" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>We can estimate the coverage of the confidence interval by repeating the above data-generating and data-analysis processes many, many times.
R’s <code>replicate()</code> function is a handy way to repeatedly call a line of code.
Its first input argument is <code>n</code>, the number of times to repeat the calculation, followed by <code>expr</code>, which is one or more lines of code to be called.
We can use <code>replicate</code> to repeat our simulation process 1000 times in a row, each time generating a new sample of 10 observations from a normal distribution with mean of 4 and a standard deviation of 2.
For each replication, we store the result of using <code>findInterval()</code> to check whether the confidence interval includes the population mean of 4.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb55-1"><a href="#cb55-1" tabindex="-1"></a>rps <span class="ot">&lt;-</span> <span class="fu">replicate</span>( <span class="dv">1000</span>, {</span>
<span id="cb55-2"><a href="#cb55-2" tabindex="-1"></a>  dat <span class="ot">&lt;-</span> <span class="fu">rnorm</span>( <span class="at">n =</span> <span class="dv">10</span>, <span class="at">mean =</span> <span class="dv">4</span>, <span class="at">sd =</span> <span class="dv">2</span> )</span>
<span id="cb55-3"><a href="#cb55-3" tabindex="-1"></a>  tt <span class="ot">&lt;-</span> <span class="fu">t.test</span>( dat )</span>
<span id="cb55-4"><a href="#cb55-4" tabindex="-1"></a>  <span class="fu">findInterval</span>( <span class="dv">4</span>, tt<span class="sc">$</span>conf.int )</span>
<span id="cb55-5"><a href="#cb55-5" tabindex="-1"></a>})</span>
<span id="cb55-6"><a href="#cb55-6" tabindex="-1"></a></span>
<span id="cb55-7"><a href="#cb55-7" tabindex="-1"></a><span class="fu">head</span>(rps, <span class="dv">20</span>)</span></code></pre></div>
<pre><code>##  [1] 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1</code></pre>
<p>To see how well we did, we can look at a table of the results stored in <code>rps</code> and calculate the proportion of replications that the interval covered the population mean:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb57-1"><a href="#cb57-1" tabindex="-1"></a><span class="fu">table</span>( rps )</span></code></pre></div>
<pre><code>## rps
##   0   1   2 
##  27 957  16</code></pre>
<div class="sourceCode" id="cb59"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1" tabindex="-1"></a><span class="fu">mean</span>( rps <span class="sc">==</span> <span class="dv">1</span> )</span></code></pre></div>
<pre><code>## [1] 0.957</code></pre>
<p>We got about 95% coverage, which is good news. In 27 out of the 1000 replications, the interval was too high (so the population mean was below the interval) and in 16 out of the 1000 replications, the interval was too low (so the population mean was above the interval).</p>
<p>It is important to recognize that this set of simulations results, and our coverage rate of 95.7%, itself has some uncertainty in it.
Because we only repeated the simulation 1000 times, what we really have is a <em>sample</em> of 1000 independent replications, out of an infinite number of possible simulation runs.
Our coverage of 95.7% is an <em>estimate</em> of what the true coverage would be, if we ran more and more replications.
The source of uncertainty of our estimate is called <em>Monte Carlo simulation error (MCSE)</em>.
We can actually assess the Monte Carlo simulation error in our simulation results using standard statistical procedures for independent and identically distributed data.
Here we use a proportion test to check whether the estimated coverage rate is consistent with a true coverage rate of 95%:</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb61-1"><a href="#cb61-1" tabindex="-1"></a>covered <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>( rps <span class="sc">==</span> <span class="dv">1</span> )</span>
<span id="cb61-2"><a href="#cb61-2" tabindex="-1"></a><span class="fu">prop.test</span>( <span class="fu">sum</span>(covered), <span class="fu">length</span>(covered), <span class="at">p =</span> <span class="fl">0.95</span> )</span></code></pre></div>
<pre><code>## 
##  1-sample proportions test with continuity
##  correction
## 
## data:  sum(covered) out of length(covered), null probability 0.95
## X-squared = 0.88947, df = 1, p-value =
## 0.3456
## alternative hypothesis: true p is not equal to 0.95
## 95 percent confidence interval:
##  0.9420144 0.9683505
## sample estimates:
##     p 
## 0.957</code></pre>
<p>The test indicates that our estimate is consistent with the possibility that the true coverage rate is 95%, just as it should be.
Things working out should hardly be surprising.
Mathematical theory tells us that the <span class="math inline">\(t\)</span>-test is exact for normally distributed population variables, and we generated data from a normal distribution.
In other words, all we have found so far is that the confidence intervals follow theory when the assumptions of the method are met.</p>
</div>
<div id="a-non-normal-population-distribution" class="section level2 hasAnchor" number="3.2">
<h2 class="hasAnchor"><span class="header-section-number">3.2</span> A non-normal population distribution<a href="#a-non-normal-population-distribution" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>To see what happens when the normality assumption is violated, let us now look at a scenario where the population variable follows a geometric distribution.
The geometric distribution is usually written in terms of a probability parameter <span class="math inline">\(p\)</span>, so that the distribution has a mean of <span class="math inline">\((1 - p) / p\)</span>.
We will use a geometric distribution with a mean of 4 by setting <span class="math inline">\(p = 1/5\)</span>.
Here is the population distribution of the variable:
<img src="Designing-Simulations-in-R_files/figure-html/unnamed-chunk-35-1.png" width="75%" style="display: block; margin: auto;" /></p>
<p>The distribution is highly right-skewed, which suggests that the normal confidence interval might not work very well.</p>
<p>Now let’s revise our previous simulation code to use the geometric distribution:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb63-1"><a href="#cb63-1" tabindex="-1"></a>rps <span class="ot">&lt;-</span> <span class="fu">replicate</span>( <span class="dv">1000</span>, {</span>
<span id="cb63-2"><a href="#cb63-2" tabindex="-1"></a>  dat <span class="ot">&lt;-</span> <span class="fu">rgeom</span>( <span class="at">n =</span> <span class="dv">10</span>, <span class="at">prob =</span> <span class="dv">1</span><span class="sc">/</span><span class="dv">5</span> )</span>
<span id="cb63-3"><a href="#cb63-3" tabindex="-1"></a>  tt <span class="ot">&lt;-</span> <span class="fu">t.test</span>( dat )</span>
<span id="cb63-4"><a href="#cb63-4" tabindex="-1"></a>  <span class="fu">findInterval</span>( <span class="dv">4</span>, tt<span class="sc">$</span>conf.int )</span>
<span id="cb63-5"><a href="#cb63-5" tabindex="-1"></a>})</span>
<span id="cb63-6"><a href="#cb63-6" tabindex="-1"></a><span class="fu">table</span>( rps )</span></code></pre></div>
<pre><code>## rps
##   0   1   2 
##   8 892 100</code></pre>
<p>Our confidence interval is often entirely too low (such that the population mean is above the interval) and very rarely does our interval fall fully above the population mean.
Furthermore, our coverage rate is not the desired 95%:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb65-1"><a href="#cb65-1" tabindex="-1"></a><span class="fu">mean</span>( rps <span class="sc">==</span> <span class="dv">1</span> )</span></code></pre></div>
<pre><code>## [1] 0.892</code></pre>
<p>To take account of Monte Carlo error, we will again do a proportion test.
The following test result calculates a confidence interval for the true coverage rate under the scenario we are examining:</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb67-1"><a href="#cb67-1" tabindex="-1"></a>covered <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>( rps <span class="sc">==</span> <span class="dv">1</span> )</span>
<span id="cb67-2"><a href="#cb67-2" tabindex="-1"></a><span class="fu">prop.test</span>( <span class="fu">sum</span>(covered), <span class="fu">length</span>(covered), <span class="at">p =</span> <span class="fl">0.95</span>)</span></code></pre></div>
<pre><code>## 
##  1-sample proportions test with continuity
##  correction
## 
## data:  sum(covered) out of length(covered), null probability 0.95
## X-squared = 69.605, df = 1, p-value &lt;
## 2.2e-16
## alternative hypothesis: true p is not equal to 0.95
## 95 percent confidence interval:
##  0.8707042 0.9102180
## sample estimates:
##     p 
## 0.892</code></pre>
<p>Our coverage is <em>too low</em>; the confidence interval based on the <span class="math inline">\(t\)</span>-test misses the the true value more often than it should.
We have learned that the <span class="math inline">\(t\)</span>-test can fail when applied to non-normal (skewed) data.</p>
</div>
<div id="simulating-across-different-scenarios" class="section level2 hasAnchor" number="3.3">
<h2 class="hasAnchor"><span class="header-section-number">3.3</span> Simulating across different scenarios<a href="#simulating-across-different-scenarios" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>So far, we have looked at coverage rates of the confidence interval under a single, specific scenario, with a sample size of 10, a population mean of 4, and a geometrically distributed variable.
We know from statistical theory (specifically, the central limit theorem) that the confidence interval should work better if the sample size is big enough.
But how big does it have to get?
One way to examine this question is to expand the simulation to look at several different scenarios involving different sample sizes.
We can think of this as a one-factor experiment, where we manipulate sample size and use simulation to estimate how confidence interval coverage rates change.</p>
<p>To implement such an experiment, we first write our own function that executes the full simulation process for a given sample size:</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb69-1"><a href="#cb69-1" tabindex="-1"></a>ttest_CI_experiment <span class="ot">=</span> <span class="cf">function</span>( n ) {</span>
<span id="cb69-2"><a href="#cb69-2" tabindex="-1"></a>  </span>
<span id="cb69-3"><a href="#cb69-3" tabindex="-1"></a>  rps <span class="ot">&lt;-</span> <span class="fu">replicate</span>( <span class="dv">1000</span>, {</span>
<span id="cb69-4"><a href="#cb69-4" tabindex="-1"></a>    dat <span class="ot">&lt;-</span> <span class="fu">rgeom</span>( <span class="at">n =</span> n, <span class="at">prob =</span> <span class="dv">1</span><span class="sc">/</span><span class="dv">5</span> ) <span class="co"># simulate data</span></span>
<span id="cb69-5"><a href="#cb69-5" tabindex="-1"></a>    tt <span class="ot">&lt;-</span> <span class="fu">t.test</span>( dat )               <span class="co"># analyze data</span></span>
<span id="cb69-6"><a href="#cb69-6" tabindex="-1"></a>    <span class="fu">findInterval</span>( <span class="dv">4</span>, tt<span class="sc">$</span>conf.int )    <span class="co"># evaluate coverage</span></span>
<span id="cb69-7"><a href="#cb69-7" tabindex="-1"></a>  })</span>
<span id="cb69-8"><a href="#cb69-8" tabindex="-1"></a></span>
<span id="cb69-9"><a href="#cb69-9" tabindex="-1"></a>  coverage <span class="ot">&lt;-</span> <span class="fu">mean</span>( rps <span class="sc">==</span> <span class="dv">1</span> )       <span class="co"># summarize results</span></span>
<span id="cb69-10"><a href="#cb69-10" tabindex="-1"></a>  </span>
<span id="cb69-11"><a href="#cb69-11" tabindex="-1"></a>  <span class="fu">return</span>(coverage)</span>
<span id="cb69-12"><a href="#cb69-12" tabindex="-1"></a>}</span></code></pre></div>
<p>The code inside the body of the function is identical to what we have used above, with the sample size as a function argument, <code>n</code>, which enables us to easily run the code for different sample sizes.
With our function in hand, we can now run the simulation for a single scenario just by calling it:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb70-1"><a href="#cb70-1" tabindex="-1"></a><span class="fu">ttest_CI_experiment</span>(<span class="at">n =</span> <span class="dv">10</span>)</span></code></pre></div>
<pre><code>## [1] 0.885</code></pre>
<p>Even though the sample size is still <code>n = 10</code>, the simulated coverage rate is a little bit different from what we found previously.
That is because there is some Monte Carlo error in each simulated coverage rate.</p>
<p>Our task is now to use this function for several different values of <span class="math inline">\(n\)</span>. We could just do this by copy-pasting and changing the value of <code>n</code>:</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb72-1"><a href="#cb72-1" tabindex="-1"></a><span class="fu">ttest_CI_experiment</span>(<span class="at">n =</span> <span class="dv">10</span>)</span></code></pre></div>
<pre><code>## [1] 0.922</code></pre>
<div class="sourceCode" id="cb74"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb74-1"><a href="#cb74-1" tabindex="-1"></a><span class="fu">ttest_CI_experiment</span>(<span class="at">n =</span> <span class="dv">20</span>)</span></code></pre></div>
<pre><code>## [1] 0.91</code></pre>
<div class="sourceCode" id="cb76"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb76-1"><a href="#cb76-1" tabindex="-1"></a><span class="fu">ttest_CI_experiment</span>(<span class="at">n =</span> <span class="dv">30</span>)</span></code></pre></div>
<pre><code>## [1] 0.914</code></pre>
<p>However, this will quickly get cumbersome if we want to evaluate many different sample sizes.
A better approach is to use a mapping function from the <code>purrr</code> package.<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a>
The <code>map_dbl()</code> function takes a list of values and calls a function for each value in the list.
This accomplishes the same thing as using a <code>for</code> loop to iterate through a list of items (if you happen to be familiar with these), but is more succinct.
See Appendix chapter @ref(repeating-oneself) for more on <code>map()</code>.<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a></p>
<p>To proceed, we first create a list of sample sizes to test out:</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb78-1"><a href="#cb78-1" tabindex="-1"></a>ns <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">30</span>, <span class="dv">40</span>, <span class="dv">60</span>, <span class="dv">80</span>, <span class="dv">100</span>, <span class="dv">120</span>, <span class="dv">160</span>, <span class="dv">200</span>, <span class="dv">300</span>)</span></code></pre></div>
<p>Now we can use <code>map_dbl()</code> to evaluate the coverage rate for each sample size:</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb79-1"><a href="#cb79-1" tabindex="-1"></a>coverage_est <span class="ot">&lt;-</span> <span class="fu">map_dbl</span>( ns, ttest_CI_experiment)</span></code></pre></div>
<p>This code will run our experiment for each value in <code>ns</code>, and then return a vector of the estimated coverage rates for each of the sample sizes.</p>
<p>We advocate for depicting simulation results graphically.
To do so, we store the simulation results in a dataset and then create a line plot using a log scale for the horizontal axis:</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb80-1"><a href="#cb80-1" tabindex="-1"></a>res <span class="ot">&lt;-</span> <span class="fu">tibble</span>( </span>
<span id="cb80-2"><a href="#cb80-2" tabindex="-1"></a>  <span class="at">n =</span> ns, </span>
<span id="cb80-3"><a href="#cb80-3" tabindex="-1"></a>  <span class="at">coverage =</span> <span class="dv">100</span> <span class="sc">*</span> coverage_est </span>
<span id="cb80-4"><a href="#cb80-4" tabindex="-1"></a>)</span>
<span id="cb80-5"><a href="#cb80-5" tabindex="-1"></a></span>
<span id="cb80-6"><a href="#cb80-6" tabindex="-1"></a><span class="fu">ggplot</span>( res, <span class="fu">aes</span>( <span class="at">x =</span> n, <span class="at">y =</span> coverage ) ) <span class="sc">+</span></span>
<span id="cb80-7"><a href="#cb80-7" tabindex="-1"></a>  <span class="fu">geom_hline</span>( <span class="at">yintercept=</span><span class="dv">95</span>, <span class="at">col=</span><span class="st">&quot;red&quot;</span> ) <span class="sc">+</span>  </span>
<span id="cb80-8"><a href="#cb80-8" tabindex="-1"></a>  <span class="co"># A reference line for nominal coverage rate</span></span>
<span id="cb80-9"><a href="#cb80-9" tabindex="-1"></a>  <span class="fu">geom_line</span>() <span class="sc">+</span> </span>
<span id="cb80-10"><a href="#cb80-10" tabindex="-1"></a>  <span class="fu">geom_point</span>( <span class="at">size =</span> <span class="dv">4</span> ) <span class="sc">+</span></span>
<span id="cb80-11"><a href="#cb80-11" tabindex="-1"></a>  <span class="fu">scale_x_log10</span>( <span class="at">breaks =</span> ns, <span class="at">minor_breaks =</span> <span class="cn">NULL</span>) <span class="sc">+</span></span>
<span id="cb80-12"><a href="#cb80-12" tabindex="-1"></a>  <span class="fu">labs</span>( </span>
<span id="cb80-13"><a href="#cb80-13" tabindex="-1"></a>    <span class="at">title=</span><span class="st">&quot;Coverage rates for t-test on exponential data&quot;</span>,</span>
<span id="cb80-14"><a href="#cb80-14" tabindex="-1"></a>    <span class="at">x =</span> <span class="st">&quot;n (sample size)&quot;</span>, </span>
<span id="cb80-15"><a href="#cb80-15" tabindex="-1"></a>    <span class="at">y =</span> <span class="st">&quot;coverage (%)&quot;</span> </span>
<span id="cb80-16"><a href="#cb80-16" tabindex="-1"></a>  ) <span class="sc">+</span></span>
<span id="cb80-17"><a href="#cb80-17" tabindex="-1"></a>  <span class="fu">coord_cartesian</span>(<span class="at">xlim =</span> <span class="fu">c</span>(<span class="dv">9</span>,<span class="dv">320</span>), <span class="at">ylim=</span><span class="fu">c</span>(<span class="dv">85</span>,<span class="dv">100</span>), <span class="at">expand =</span> <span class="cn">FALSE</span>) <span class="sc">+</span> </span>
<span id="cb80-18"><a href="#cb80-18" tabindex="-1"></a>  <span class="fu">theme_minimal</span>()</span></code></pre></div>
<p><img src="Designing-Simulations-in-R_files/figure-html/ttest_result_figure-1.png" width="75%" style="display: block; margin: auto;" /></p>
<p>We can see from the graph that the confidence interval’s coverage rate improves as sample size gets larger. For sample sizes over 100, the interval appears to have coverage quite close to the nominal 95% level.
Although the general trend is pretty clear, the graph is still a bit messy because each point is an <em>estimated</em> coverage rate, with some Monte Carlo error baked in.</p>
</div>
<div id="extending-the-simulation-design" class="section level2 hasAnchor" number="3.4">
<h2 class="hasAnchor"><span class="header-section-number">3.4</span> Extending the simulation design<a href="#extending-the-simulation-design" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>So far, we have executed a simple simulation to assess how well a statistical method works in a given circumstance, then expanded the simulation by running a single-factor experiment in which we varied the sample size to see how the method’s performance changes.
In our example, we found that coverage is below what it should be for small sample sizes, but improves for sample sizes in the 100’s.</p>
<p>This example captures all the major steps of a simulation study, which we outlined at the start of Chapter @ref(introduction).
We generated some hypothetical data according to a fully-specified data-generating process: we did both a normal distribution and a geometric distribution, each with a mean of 4.
We applied a defined data-analysis procedure to the simulated data: we used a confidence interval based on the <span class="math inline">\(t\)</span> distribution.
We assessed how well the procedure worked across replications of the data-generating and data-analysis processes: in this case we focused on the coverage rate of the confidence interval.
After creating a function to implement this whole process for a single scenario, we investigated how the performance of the confidence interval changed depending on sample size.</p>
<p>In simulations of more complex models and data-analysis methods, some or all of the steps in the process might have more moving pieces or entail more complex calculations.
For instance, we might want to compare the performance of different approaches to calculating a confidence interval.
We might also want to examine how coverage rates are affected by other aspects of the data-generating process, such as looking at different population mean values for the geometric distribution—or even entirely different distributions.
With such additional layers of complexity, we will need to think systematically about each of the component parts of the simulation.
In the next chapter, we introduce an abstract, general framework for simulations that is helpful for guiding simulation design and managing all the considerations involved.</p>
</div>
<div id="exercises-1" class="section level2 hasAnchor" number="3.5">
<h2 class="hasAnchor"><span class="header-section-number">3.5</span> Exercises<a href="#exercises-1" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<ol style="list-style-type: decimal">
<li><p>The simulation function we developed in this chapter uses 1000 replications of the data-generating and data-analysis process, which leads to some Monte Carlo error in the simulation results. Modify the <code>ttest_CI_experiment()</code> function to make the number of replications an input argument, then re-run the simulation and re-create the graph of the results with <span class="math inline">\(R=10,000\)</span> or even <span class="math inline">\(R=100,000\)</span>. Is the graph more regular than the one in the text, above?
Use your improved results to determine what sample size is large enough to give coverage of at least 94% (so only 1% off of desired).</p></li>
<li><p>Modify the <code>ttest_CI_experiment()</code> function to make the <span class="math inline">\(p\)</span> parameter an input argument. Repeat the one-factor simulation, but use <span class="math inline">\(p = 1/10\)</span> so that the population mean is <span class="math inline">\((1 - p) / p = 9\)</span>. How do the coverage rates change?</p></li>
</ol>
<p><strong>More challenging problems</strong></p>
<ol start="3" style="list-style-type: decimal">
<li><p>Below is a modified version of the <code>ttest_CI_experiment()</code> function that creates a tibble with lower and upper end-points of the simulated confidence intervals:</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb81-1"><a href="#cb81-1" tabindex="-1"></a>lotsa_CIs_experiment <span class="ot">=</span> <span class="cf">function</span>( n ) {</span>
<span id="cb81-2"><a href="#cb81-2" tabindex="-1"></a></span>
<span id="cb81-3"><a href="#cb81-3" tabindex="-1"></a>  lotsa_CIs <span class="ot">&lt;-</span> <span class="fu">replicate</span>( <span class="dv">1000</span>, {</span>
<span id="cb81-4"><a href="#cb81-4" tabindex="-1"></a>    <span class="co"># simulate data</span></span>
<span id="cb81-5"><a href="#cb81-5" tabindex="-1"></a>    dat <span class="ot">&lt;-</span> <span class="fu">rgeom</span>( <span class="at">n =</span> n, <span class="at">prob =</span> <span class="dv">1</span><span class="sc">/</span><span class="dv">5</span>)                            </span>
<span id="cb81-6"><a href="#cb81-6" tabindex="-1"></a>    <span class="co"># analyze data</span></span>
<span id="cb81-7"><a href="#cb81-7" tabindex="-1"></a>    tt <span class="ot">&lt;-</span> <span class="fu">t.test</span>( dat )                                       </span>
<span id="cb81-8"><a href="#cb81-8" tabindex="-1"></a>    <span class="co"># return CI</span></span>
<span id="cb81-9"><a href="#cb81-9" tabindex="-1"></a>    <span class="fu">tibble</span>(<span class="at">lower =</span> tt<span class="sc">$</span>conf.int[<span class="dv">1</span>], <span class="at">upper =</span> tt.conf.int[<span class="dv">2</span>])</span>
<span id="cb81-10"><a href="#cb81-10" tabindex="-1"></a>  })</span>
<span id="cb81-11"><a href="#cb81-11" tabindex="-1"></a></span>
<span id="cb81-12"><a href="#cb81-12" tabindex="-1"></a>  <span class="co"># summarize results</span></span>
<span id="cb81-13"><a href="#cb81-13" tabindex="-1"></a>  <span class="co"># &lt;fill in the rest&gt;</span></span>
<span id="cb81-14"><a href="#cb81-14" tabindex="-1"></a></span>
<span id="cb81-15"><a href="#cb81-15" tabindex="-1"></a>  <span class="fu">return</span>(coverage)</span>
<span id="cb81-16"><a href="#cb81-16" tabindex="-1"></a>}</span></code></pre></div>
<p>Complete the function by writing code to compute the estimated coverage rate and average confidence interval length. Also calculate a 95% confidence interval for the true coverage rate (you can use <code>prop.test()</code> on your set of simulation coverage indicators to obtain this, treating your <span class="math inline">\(R\)</span> simulation replicates as a random sample in its own right). Your modified function should return a one-row tibble with the coverage rate, average confidence interval length, and a CI for the true coverage rate.</p></li>
<li><p>Modify the <code>ttest_CI_experiment()</code> function to include the extensions of the prior problem. Then re-run the simulations with your modified function, obtaining a data frame with each row being a simulation scenario and columns of sample size, estimated coverage, low end of the estimate’s confidence interval, and high end of the interval. You will likely want to use <code>map()</code> and then <code>bind_rows()</code> on your list of results; see Chapter @ref(repeating-oneself) for more information about these techniques.
Use these data to create a graph that depicts the estimated coverage rates. Try creating a graph that includes the 95% confidence intervals also, so that the Monte Carlo simulation error in the estimated coverage rates is represented in the graph. We recommend using the <code>ggplot2</code> function <code>geom_pointrange()</code> to represent the confidence intervals.</p></li>
<li><p>Modify <code>ttest_CI_experiment()</code> or <code>lotsa_CIs_experiment()</code> so that the user can specify the population mean of the data-generating process. Also let the user specify the number of replications to use. Here is a function skeleton to use as a starting point:</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb82-1"><a href="#cb82-1" tabindex="-1"></a>ttest_CI_experiment <span class="ot">&lt;-</span> <span class="cf">function</span>( n, pop_mean, reps) {</span>
<span id="cb82-2"><a href="#cb82-2" tabindex="-1"></a></span>
<span id="cb82-3"><a href="#cb82-3" tabindex="-1"></a>  pop_prob <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">/</span> (pop_mean <span class="sc">+</span> <span class="dv">1</span>)</span>
<span id="cb82-4"><a href="#cb82-4" tabindex="-1"></a></span>
<span id="cb82-5"><a href="#cb82-5" tabindex="-1"></a>  <span class="co"># &lt;fill in the rest&gt;</span></span>
<span id="cb82-6"><a href="#cb82-6" tabindex="-1"></a></span>
<span id="cb82-7"><a href="#cb82-7" tabindex="-1"></a>  <span class="fu">return</span>(coverage)</span>
<span id="cb82-8"><a href="#cb82-8" tabindex="-1"></a>}</span></code></pre></div></li>
<li><p>Using the modified function from the previous problem, implement a two-factor simulation study for several different values of <code>n</code> and several different population means.
One way to do this is to run a few simulations with different population means, storing them in a series of datasets, <code>res1</code>, <code>res2</code>, <code>res3</code>, etc.
Then use <code>bind_rows( size1 = res1, ..., .id = "mean" )</code> to combine the datasets into a single dataset.
Make a plot of your results, with <code>n</code> on the x-axis, coverage on the <span class="math inline">\(y\)</span>-axis, and different lines for different population means.</p></li>
</ol>
<!--chapter:end:005-initial-t-test-simulation.Rmd-->
</div>
</div>
<div id="part-structure-and-mechanics-of-a-simulation-study" class="section level1 unnumbered hasAnchor">
<h1 class="unnumbered hasAnchor">(PART) Structure and Mechanics of a Simulation Study<a href="#part-structure-and-mechanics-of-a-simulation-study" class="anchor-section" aria-label="Anchor link to header"></a></h1>
</div>
<div id="simulation-structure" class="section level1 hasAnchor" number="4">
<h1 class="hasAnchor"><span class="header-section-number">4</span> Structure of a simulation study<a href="#simulation-structure" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p>Monte Carlo simulation is a very flexible tool that researchers use to study a vast array of different models and topics.
Within the realm of methodological research, most simulations share a common structure, nearly always involving the same set of steps or component pieces.
In learning to design your own simulations, it is very useful to recognize the core components that most simulation studies share.
Identifying these components will help you to organize your work and structure the coding tasks involved in writing a simulation.</p>
<p>In this chapter, we outline the component structure of a methodological simulation study, highlighting the four steps involved in a simulation of a single scenario and the three additional steps involved in multifactor simulations.
We then describe a strategy for implementing simulations that mirrors the same component structure, where each step in the simulation is represented by a separate function or object.
We call this strategy <strong><em>tidy, modular simulation</em></strong>.
Finally, we show how the tidy, modular simulation strategy informs the structure and organization of code for a simulation study, walking through basic code skeletons (cf. @ref(function-skeletons)) for each of the steps in a single-scenario simulation.</p>
<div id="general-structure-of-a-simulation" class="section level2 hasAnchor" number="4.1">
<h2 class="hasAnchor"><span class="header-section-number">4.1</span> General structure of a simulation<a href="#general-structure-of-a-simulation" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>The four main steps involved in a simulation study, introduced in Chapter @ref(introduction), are summarized in the top portion of Table @ref(tab:simulation).</p>
<table>
<caption>(#tab:simulation) Steps in the Simulation Process</caption>
<colgroup>
<col width="10%" />
<col width="46%" />
<col width="43%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>Step</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><strong>Generate</strong></td>
<td>Generate a sample of artificial data based on a specific statistical model or data-generating process.</td>
</tr>
<tr class="even">
<td>2</td>
<td><strong>Analyze</strong></td>
<td>Apply one or more data-analysis procedures, estimators, or workflows to the artificial data.</td>
</tr>
<tr class="odd">
<td>3</td>
<td><strong>Repeat</strong></td>
<td>Repeat steps (1) &amp; (2) <span class="math inline">\(R\)</span> times, recording <span class="math inline">\(R\)</span> sets of results.</td>
</tr>
<tr class="even">
<td>4</td>
<td><strong>Summarize</strong></td>
<td>Assess the performance of the procedure across the <span class="math inline">\(R\)</span> replications.</td>
</tr>
<tr class="odd">
<td>5</td>
<td><strong>Design</strong></td>
<td>Specify a set of conditions to examine</td>
</tr>
<tr class="even">
<td>6</td>
<td><strong>Execute</strong></td>
<td>Run the simulation for each condition in the design.</td>
</tr>
<tr class="odd">
<td>7</td>
<td><strong>Synthesize</strong></td>
<td>Compare performance across conditions.</td>
</tr>
</tbody>
</table>
<p>In the simple <span class="math inline">\(t\)</span>-test example presented in Chapter @ref(t-test-simulation), we put each of these steps into action with R code:</p>
<ul>
<li>We used the geometric distribution as a data-generating process;</li>
<li>We used the confidence interval from a one-sample <span class="math inline">\(t\)</span>-test as the data-analysis procedure;</li>
<li>We repeatedly simulated the confidence intervals with R’s <code>replicate()</code> function; and</li>
<li>We summarized the results by estimating the fraction of the intervals that covered the population mean.</li>
</ul>
<p>We also saw that it was helpful to wrap all of these steps up into a single function, so that we could run the simulation across multiple sample sizes.</p>
<p>These four initial steps are common and shared across nearly all simulations.
In our first example, each of the steps was fairly simple, sometimes involving only a single line of code.
More generally, each of the steps might be quite a bit more complex. The data-generating process might involve a more complex model with multiple variables or multilevel structure.
The data analysis procedure might involve solving a multidimensional optimization problem to get parameter estimates, or might involve a data analysis workflow with multiple steps or contingencies.
Further, we might use more than one metric for summarizing the results across replications and describing the performance of the data analysis procedure.
Because each of the four steps involves its own set of choices, it will useful to recognize them as distinct from one another.</p>
<p>In methodological research projects, we usually want to examine simulation results across an array of different conditions that differ not only in terms of sample size, but also in other parameters or features of the data-generating process.
Running a simulation study across multiple conditions entails several further steps, which are summarized in the bottom portion of Table @ref(tab:simulation). We will first need to specify the factors and specific conditions to be examined in our experimental design. We will then need to execute the simulation for each of the conditions and store all the results for further analysis. Finally, we will need to find ways to synthesize or make sense of the main patterns in the results across all of the conditions in the design.</p>
<p>Just as with the first four steps, it is useful to recognize these further steps as distinct from one another, each involving its own set of choices and techniques.
The design step requires choosing which parameters and features of the data-generating process to vary, as well as which specific values to use for each factor that is varied.
Executing a simulation might require a lot of computing power, especially if the simulation design has many conditions or the data analysis procedure takes a long time to compute.
How to effectively implement the execution step will therefore depend on the computing requirements and available resources.
Finally, many different techniques can be used to synthesizing findings from a multifactor simulation.
Which ones are most useful will depend on your research questions and the choices you make in each of the preceeding steps.</p>
<!--Across all seven steps, recognizing the distinct pieces will let us more effectively tackle the many decisions involved in designing and running a simulation.-->
</div>
<div id="tidy-modular-simulations" class="section level2 hasAnchor" number="4.2">
<h2 class="hasAnchor"><span class="header-section-number">4.2</span> Tidy, modular simulations<a href="#tidy-modular-simulations" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>It is apparent from Table @ref(tab:simulation) that writing a simulation in R involves a large space of possibilities and will requiring making a bunch of decisions.
Considering the number of choices to be made, it is critical to stay organized and to approach the process systematically.
Recognizing the components of a simulation is the starting point.
Next is to see how to translate the components into R code.</p>
<p>In our own methodological work, we have found it very useful to always follow the same approach to writing code for a simulation.
We call this approach <em>tidy, modular simulation</em>. It involves two simple principles:</p>
<ol style="list-style-type: decimal">
<li>Implement each component of a simulation as a distinct function or object.</li>
<li>Store all results in rectangular data sets.</li>
</ol>
<p>Writing separate functions for each component step of a simulation has several benefits.
The first is the practical benefit of turning the coding process from a monolithic (and potentially daunting) activity into a set of smaller, discrete tasks.
This lets us focus on one task at a time and makes it easier to see progress.
Second, following this principle makes for code that is easier to read, test, and debug.
Rather than having to scan through an entire code file to understand how the data analysis procedure is implemented, we can quickly identify the function that implements it, then focus on understanding the workings of that function.
Likewise, if another researcher wanted to test out the data analysis procedure on a dataset of their own, they could do so by running the corresponding function rather than having to dissect an entire script.
Third, writing separate code for each component makes it possible to tweak the code or swap out pieces of the simulation, such as by adding additional estimation methods or trying out a data-generating process involving different distributional assumptions.
We already saw this in Chapter @ref(t-test-simulation), where we modified our initial data-generating process to use a geometric distribution rather than a normal distribution.
In short, following the first principle makes for simpler, more robust code that is easier to navigate, easier to test, and easier to extend.</p>
<p>The second principle of tidy, modular simulation is to store all results in rectangular datasets, such as the base R <code>data.frame</code> object or the tidyverse <code>tibble</code> object.<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a>
This principle applies to any and all output, including the simulated data from Step 1, the results of data analysis procedures from Step 2, full sets of replicated simulation results from Step 3, and summarized results from Step 4.
A primary benefit of following this principle is that it facilitates working with the output of each stage in the simulation process.
If you are comfortable using R to analyze real data, you you can use the same skills and tools to examine simulation output as long as it is in tabular form.
Many of the data processing and data analysis tools available in R work with—or even require—rectangular datasets.
Thus, using rectangular datasets makes it easier to inspect, summarize, and visualize the output.</p>
</div>
<div id="skeleton-of-a-simulation-study" class="section level2 hasAnchor" number="4.3">
<h2 class="hasAnchor"><span class="header-section-number">4.3</span> Skeleton of a simulation study<a href="#skeleton-of-a-simulation-study" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>The principles of tidy simulation imply that code for a simulation study should usually follow the same broad outline and organization of Table @ref(tab:simulation), with custom functions for each step in process.
We will describe the outlines of simulation code using function skeletons to illustrate the inputs and outputs of each component.
These skeletons skip over all the specific details, so that we can see the structure more clearly.
We will first examine the structure of the code for simulating one specific scenario, then consider how to extend the code to systematically explore a variety of scenarios, as in a multifactor simulation.</p>
<p>In code skeletons, the structure of the first four steps in a simulation looks like this:</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb83-1"><a href="#cb83-1" tabindex="-1"></a><span class="co"># Generate (data-generating process)</span></span>
<span id="cb83-2"><a href="#cb83-2" tabindex="-1"></a></span>
<span id="cb83-3"><a href="#cb83-3" tabindex="-1"></a>generate_data <span class="ot">&lt;-</span> <span class="cf">function</span>( model_params ) {</span>
<span id="cb83-4"><a href="#cb83-4" tabindex="-1"></a>  <span class="co"># stuff</span></span>
<span id="cb83-5"><a href="#cb83-5" tabindex="-1"></a>  <span class="fu">return</span>(data)</span>
<span id="cb83-6"><a href="#cb83-6" tabindex="-1"></a>}</span>
<span id="cb83-7"><a href="#cb83-7" tabindex="-1"></a></span>
<span id="cb83-8"><a href="#cb83-8" tabindex="-1"></a><span class="co"># Analyze (data-analysis procedure)</span></span>
<span id="cb83-9"><a href="#cb83-9" tabindex="-1"></a></span>
<span id="cb83-10"><a href="#cb83-10" tabindex="-1"></a>analyze <span class="ot">&lt;-</span> <span class="cf">function</span>( data ) {</span>
<span id="cb83-11"><a href="#cb83-11" tabindex="-1"></a>  <span class="co"># stuff</span></span>
<span id="cb83-12"><a href="#cb83-12" tabindex="-1"></a>  <span class="fu">return</span>(one_result)</span>
<span id="cb83-13"><a href="#cb83-13" tabindex="-1"></a>}</span>
<span id="cb83-14"><a href="#cb83-14" tabindex="-1"></a></span>
<span id="cb83-15"><a href="#cb83-15" tabindex="-1"></a><span class="co"># Repeat</span></span>
<span id="cb83-16"><a href="#cb83-16" tabindex="-1"></a></span>
<span id="cb83-17"><a href="#cb83-17" tabindex="-1"></a>one_run <span class="ot">&lt;-</span> <span class="cf">function</span>( model_params ) {</span>
<span id="cb83-18"><a href="#cb83-18" tabindex="-1"></a>  dat <span class="ot">&lt;-</span> <span class="fu">generate_data</span>( model_params )</span>
<span id="cb83-19"><a href="#cb83-19" tabindex="-1"></a>  one_result <span class="ot">&lt;-</span> <span class="fu">analyze</span>(dat)</span>
<span id="cb83-20"><a href="#cb83-20" tabindex="-1"></a>  <span class="fu">return</span>(one_result)</span>
<span id="cb83-21"><a href="#cb83-21" tabindex="-1"></a>}</span>
<span id="cb83-22"><a href="#cb83-22" tabindex="-1"></a></span>
<span id="cb83-23"><a href="#cb83-23" tabindex="-1"></a>results <span class="ot">&lt;-</span> <span class="fu">replicate</span>(R, <span class="fu">one_run</span>( params ))</span>
<span id="cb83-24"><a href="#cb83-24" tabindex="-1"></a></span>
<span id="cb83-25"><a href="#cb83-25" tabindex="-1"></a><span class="co"># Summarize (calculate performance measures)</span></span>
<span id="cb83-26"><a href="#cb83-26" tabindex="-1"></a></span>
<span id="cb83-27"><a href="#cb83-27" tabindex="-1"></a>assess_performance <span class="ot">&lt;-</span> <span class="cf">function</span>( results, model_params ) {</span>
<span id="cb83-28"><a href="#cb83-28" tabindex="-1"></a>  <span class="co"># stuff</span></span>
<span id="cb83-29"><a href="#cb83-29" tabindex="-1"></a>  <span class="fu">return</span>(performance_measures)</span>
<span id="cb83-30"><a href="#cb83-30" tabindex="-1"></a>}</span>
<span id="cb83-31"><a href="#cb83-31" tabindex="-1"></a></span>
<span id="cb83-32"><a href="#cb83-32" tabindex="-1"></a><span class="fu">assess_performance</span>(results, model_params)</span></code></pre></div>
<p>The code above shows the full skeleton of a simulation.
It involves four functions, where the outputs of one function get used as inputs in subsequent functions.
We will now look at the inputs and outputs of each function to see how they align with the four steps in the simulation process.
Subsequent chapters examine each piece in much greater detail—putting meat on the bones of each function skeleton, to torture our metaphor—and discuss specific statistical issues and programming techniques that are useful for designing each component.</p>
<p>Besides illustrating the skeletal framework of a simulation, readers might find it useful to use it as a template from which to start writing their own code.
The <code>simhelpers</code> package includes the function <code>create_skeleton()</code>, which will open a new R script that contains a template for a simulation study, with sections corresponding to each component:</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb84-1"><a href="#cb84-1" tabindex="-1"></a>simhelpers<span class="sc">::</span><span class="fu">create_skeleton</span>()</span></code></pre></div>
<p>The template that appears is a slightly more elaborate version of the code above, with the main difference being that it also includes some additional lines of code to wire the pieces together for a multifactor simulation.
Starting from this template, you will already be on the road to writing a tidy, modular simulation.</p>
<div id="data-generating-process" class="section level3 hasAnchor" number="4.3.1">
<h3 class="hasAnchor"><span class="header-section-number">4.3.1</span> Data-Generating Process<a href="#data-generating-process" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>The first step in a simulation is specifying a data-generating process. This is a hypothetical model for how data might arise, involving measurements or observations of one or more variables. The bare-bones skeleton of a data-generating function looks like the following:</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb85-1"><a href="#cb85-1" tabindex="-1"></a>generate_data <span class="ot">&lt;-</span> <span class="cf">function</span>( model_params ) {</span>
<span id="cb85-2"><a href="#cb85-2" tabindex="-1"></a>  <span class="co"># stuff</span></span>
<span id="cb85-3"><a href="#cb85-3" tabindex="-1"></a>  <span class="fu">return</span>(data)</span>
<span id="cb85-4"><a href="#cb85-4" tabindex="-1"></a>}</span></code></pre></div>
<p>The function takes as input a set of model parameter values, denoted here as <code>model_params</code>.
Based on those model parameters, the function generates a hypothetical dataset as output.
Generating our own data based on a model allows us to know what the answer is (e.g., the true population mean or the true average effect of an intervention), so that we have benchmark against which to compare the results of a data analysis procedure that generates noisy estimates of the true value.</p>
<p>In practice, <code>model_params</code> will usually not be just one input but rather multiple arguments.
These arguments might include inputs such as the population mean for a variable, the standard deviation of a distribution of treatment effects, or a parameter controlling the degree of skewness in the population distribution.
Many data-generating processes involving multiple variables, such as the response variable and predictor variables in a regression model.
In such instances, the inputs of <code>generate_data()</code> might also include parameters that determine the degree of dependence or correlation between variables.
Further, the <code>generate_data()</code> inputs will also usually include arguments relating to the sample size and structure of the hypothetical dataset.
For instance, in a simulation of a multilevel dataset where individuals are nested within clusters, the inputs might include an arguments to specify the total number of clusters and the average number of individuals per cluster.
We discuss the inputs and form of the data-generating function further in Chapter @ref(data-generating-processes).</p>
</div>
<div id="data-analysis-procedure" class="section level3 hasAnchor" number="4.3.2">
<h3 class="hasAnchor"><span class="header-section-number">4.3.2</span> Data Analysis Procedure<a href="#data-analysis-procedure" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>The second step in a simulation is specifying a data analysis procedure or set of procedures.
The bare-bones skeleton of a data-generating function looks like the following:</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb86-1"><a href="#cb86-1" tabindex="-1"></a>analyze <span class="ot">&lt;-</span> <span class="cf">function</span>( data ) {</span>
<span id="cb86-2"><a href="#cb86-2" tabindex="-1"></a>  <span class="co"># stuff</span></span>
<span id="cb86-3"><a href="#cb86-3" tabindex="-1"></a>  <span class="fu">return</span>(one_result)</span>
<span id="cb86-4"><a href="#cb86-4" tabindex="-1"></a>}</span></code></pre></div>
<p>The function should take a single dataset as input and produce a set of estimates or results (e.g., point estimates, standard errors, confidence intervals, p-values, predictions, etc.).
Because we will be using the function to analyze hypothetical datasets simulated from the data-generating process, the <code>analyze()</code> function needs to work with <code>data</code> inputs that are produced by the <code>generate_data()</code> function.
Thus, the code in the body of <code>analyze()</code> can assume that <code>data</code> will include relevant variables with specific names.</p>
<p>Inside the body of the function, <code>analyze()</code> includes code to carry out a data analysis procedure.
This might involve generating a confidence interval, as in the example from Chapter @ref(t-test-simulation).
In another context, it might involve estimating an average growth rate along with a standard error, given a dataset with longitudinal repeated measurements from multiple individuals.
In still another context, it might involve generating individual-level predictions from a machine learning algorithm.
In simulations that involve comparing multiple analysis methods, we might write an <code>analyze()</code> function for each of the methods of interest, or (generally less preferred because it is less modular) we might write one function that does the calculations for all of the methods together.</p>
<p>A well-written estimation method should, in principle, work not only on a simulated, hypothetical dataset but also on a real empirical dataset that has the same format (i.e., appropriate variable names and structure).
Because of this, the inputs of the <code>analyze()</code> function should not typically include any information about the parameters of the data-generating process.
To be realistic, the code for our simulated data-analysis procedure should not make use of anything that the analyst could not know when analyzing a real dataset.
Thus, <code>analyze()</code> has an argument for the sample dataset but not for <code>model_params</code>.
We discuss the form and content of the data analysis function further in Chapter @ref(data-analysis-procedures).</p>
</div>
<div id="repetition" class="section level3 hasAnchor" number="4.3.3">
<h3 class="hasAnchor"><span class="header-section-number">4.3.3</span> Repetition<a href="#repetition" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>The third step in a simulation is to repeatedly evaluate the data-generating process and data analysis procedure.
In practice, this amounts to repeatedly calling <code>generate_data()</code> and then calling <code>analyze()</code> on the result.
Here is the skeleton from our simulation template:</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb87-1"><a href="#cb87-1" tabindex="-1"></a>one_run <span class="ot">&lt;-</span> <span class="cf">function</span>( model_params ) {</span>
<span id="cb87-2"><a href="#cb87-2" tabindex="-1"></a>  dat <span class="ot">&lt;-</span> <span class="fu">generate_data</span>( model_params )</span>
<span id="cb87-3"><a href="#cb87-3" tabindex="-1"></a>  one_result <span class="ot">&lt;-</span> <span class="fu">analyze</span>(dat)</span>
<span id="cb87-4"><a href="#cb87-4" tabindex="-1"></a>  <span class="fu">return</span>(one_result)</span>
<span id="cb87-5"><a href="#cb87-5" tabindex="-1"></a>}</span>
<span id="cb87-6"><a href="#cb87-6" tabindex="-1"></a></span>
<span id="cb87-7"><a href="#cb87-7" tabindex="-1"></a>results <span class="ot">&lt;-</span> simhelpers<span class="sc">::</span><span class="fu">repeat_and_stack</span>(R, <span class="fu">one_run</span>( params ))</span></code></pre></div>
<p>We first create a helper function called <code>one_run()</code>, which takes <code>model_params</code> as input.
Inside the body of the function, we call the <code>generate_data()</code> function to simulate a hypothetical dataset.
We pass this dataset to <code>analyze()</code> and return a small dataset containing the results of the data-analysis procedure.
The <code>one_run()</code> method is like a coordinator or dispatcher of the system: it generates the data, calls all the evaluation methods we want to call, combines all the results, and hands them back for recording.
Making a helper method such as <code>one_run()</code> can be useful because it facilitates debugging.</p>
<p>Once we have the <code>one_run()</code> helper function, we need a way to call it repeatedly. As with many things in R, there are a variety of different ways to do something over and over.
In the above skeleton, we use the <code>repeat_and_stack()</code> function from <code>simhelpers</code>.<a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a>
In the first argument, we specify the number of times to repeat the process.
In the second argument, we specify an expression that evaluates <code>one_run()</code> for specified values of the model parameters stored in <code>params</code>.
The <code>repeat_and_stack()</code> function then evaluates the expression repeatedly, <code>R</code> times in all, and then stacks up all of the replications into a big dataset, with one or more rows per replication.<a href="#fn9" class="footnote-ref" id="fnref9"><sup>9</sup></a></p>
<p>We go into further detail about how to approach running the simulation process in Chapter @ref(running-the-simulation-process).
Among other things, we will illustrate how to use the <code>bundle_sim()</code> function from the <code>simhelpers</code> package to automate the process of coding this step, thereby avoiding the need to write a <code>one_run()</code> helper function.</p>
</div>
<div id="performance-summaries" class="section level3 hasAnchor" number="4.3.4">
<h3 class="hasAnchor"><span class="header-section-number">4.3.4</span> Performance summaries<a href="#performance-summaries" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>The fourth step in a simulation is to summarize the distribution of simulation results across replications.
Here is the skeleton from our simulation template:</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb89-1"><a href="#cb89-1" tabindex="-1"></a>assess_performance <span class="ot">&lt;-</span> <span class="cf">function</span>( results, model_params ) {</span>
<span id="cb89-2"><a href="#cb89-2" tabindex="-1"></a>  <span class="co"># stuff</span></span>
<span id="cb89-3"><a href="#cb89-3" tabindex="-1"></a>  <span class="fu">return</span>(performance_measures)</span>
<span id="cb89-4"><a href="#cb89-4" tabindex="-1"></a>}</span>
<span id="cb89-5"><a href="#cb89-5" tabindex="-1"></a></span>
<span id="cb89-6"><a href="#cb89-6" tabindex="-1"></a><span class="fu">assess_performance</span>(results, params)</span></code></pre></div>
<p>The <code>assess_performance()</code> function takes <code>results</code> as input.
<code>results</code> should be a dataset containing all of the replications of the data-generating and analysis process.
In contrast to the <code>analyze()</code> function, <code>assess_performance()</code> also needs to know the true parameter values of the data-generating process, so it needs to have <code>model_params</code> as its other input.
The function then uses both of these inputs to calculate performance measures and returns a summary of the performance measures in a dataset.</p>
<p>Performance measures are the metrics or criteria used to assess the performance of a statistical method across repeated samples from the data-generating process.
For example, we might want to know how close an estimator gets to the target parameter, on average.
We might want to know if a confidence interval captures the true parameter the right proportion of the time, as in the simulation from Chapter @ref(t-test-simulation).
Performance is defined in terms of the sampling distribution of estimators or analysis results, across an infinite number of replications of the data-generating process.
In practice, we use many replications of the process, but still only a finite number. Consequently, we actually <em>estimate</em> the performance measures and need to attend to the Monte Carlo error in the estimates.
We discuss the specifics of different performance measures and assessment of Monte Carlo error in Chapter @ref(performance-criteria).</p>
</div>
<div id="multifactor-simulations" class="section level3 hasAnchor" number="4.3.5">
<h3 class="hasAnchor"><span class="header-section-number">4.3.5</span> Multifactor simulations<a href="#multifactor-simulations" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Thus far, we have sketched out the structure of a modular, tidy simulation for a single context.
In our <span class="math inline">\(t\)</span>-test case study, for example, we might ask how well the <span class="math inline">\(t\)</span>-test works when we have <span class="math inline">\(n=100\)</span> units and the observations follow geometric distribution.
However, we rarely want to examine a method only in a single context.
Typically, we want to explore how well a procedure works across a range of different contexts.
If we choose conditions in a structured and thoughtful manner, we will be able to examine broad trends and potentially make more general claims about the behaviors of the data-analysis procedures under investigation.
Thus, it is helpful to think of simulations as akin to a designed experiment: in seeking to understand the properties of one or more procedures, we test them under a variety of different scenarios to see how they perform, then seek to identify more general patterns that hold beyond the specific scenarios examined.
This is the heart of simulation for methodological evaluation.</p>
<p>To implement a multifactor simulation, we will follows the same principles of modular, tidy simulation.
In particular, we will take the code developed for simulating a single context and bundle it into a function that can be evaluated for any and all scenarios of interest.
Simulation studies often follow a full factorial design, in which each level of a factor (something we vary, such as sample size, true treatment effect, or residual variance) is crossed with every other level.
The experimental design then consists of sets of parameter values (including design parameters, such as sample sizes), and these too can be represented in an object, distinct from the other components of the simulation.
We will discuss multiple-scenario simulations in Part III (starting with Chapter @ref(exp-design)), after we more fully develop the core concepts and techniques involved in simulating a single context.</p>
</div>
</div>
<div id="exercises-2" class="section level2 hasAnchor" number="4.4">
<h2 class="hasAnchor"><span class="header-section-number">4.4</span> Exercises<a href="#exercises-2" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<ol style="list-style-type: decimal">
<li>Look back at the <span class="math inline">\(t\)</span>-test simulation presented in Chapter @ref(t-test-simulation). The code presented there did not entirely follow the formal structure outlined in this chapter. Revise the code by creating separate functions for each of four components in the simulation skeleton. Using the functions, re-run the simulation and recreate one or more graphs from the exercises in the previous chapter.</li>
</ol>
<!--chapter:end:010-Simulation-structure.Rmd-->
</div>
</div>
<div id="case-ANOVA" class="section level1 hasAnchor" number="5">
<h1 class="hasAnchor"><span class="header-section-number">5</span> Case Study: Heteroskedastic ANOVA<a href="#case-ANOVA" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p>In this chapter, we present another detailed example of a simulation study to demonstrate how to put the principles of tidy, modular simulation into practice.
To illustrate the process of programming a simulation, we reconstruct the simulations from <span class="citation">Brown and Forsythe (<a href="#ref-brown1974SmallSampleBehavior">1974</a>)</span>.
We will also use this case study as a recurring example in some of the following chapters.</p>
<p><span class="citation">Brown and Forsythe (<a href="#ref-brown1974SmallSampleBehavior">1974</a>)</span> studied methods for null hypothesis testing in studies that measure a characteristic <span class="math inline">\(X\)</span> on samples from each of several groups. They consider a population consisting of <span class="math inline">\(G\)</span> separate groups, with population means <span class="math inline">\(\mu_1,...,\mu_G\)</span> and population variances <span class="math inline">\(\sigma_1^2,...,\sigma_G^2\)</span> for the characteristic <span class="math inline">\(X\)</span>.
A researcher obtains samples of size <span class="math inline">\(n_1,...,n_G\)</span> from each of the groups and takes measurements of the characteristic for each sampled unit.
Let <span class="math inline">\(x_{ig}\)</span> denote the measurement from unit <span class="math inline">\(i\)</span> in group <span class="math inline">\(g\)</span>, for <span class="math inline">\(i = 1,...,n_g\)</span> for each <span class="math inline">\(j = 1,..., G\)</span>.
The researcher’s goal is to use the sample data to test the hypothesis that the population means are all equal
<span class="math display">\[
H_0: \mu_1 = \mu_2 = \cdots = \mu_G.
\]</span></p>
<p>If the population <em>variances</em> were all equal (so <span class="math inline">\(\sigma_1^2 = \sigma_2^2 = \cdots = \sigma_G^2\)</span>), we could use a conventional one-way analysis of variance (ANOVA) to conduct this test.
However, one-way ANOVA might not work well if the variances are not equal.
The question is then: what are best practices for testing the null of equal group means, allowing for the possibility that variances could differ across groups?</p>
<p>To tackle this question, Brown and Forsythe evaluated two different hypothesis testing procedures, developed by <span class="citation">James (<a href="#ref-james1951ComparisonSeveralGroups">1951</a>)</span> and <span class="citation">Welch (<a href="#ref-welch1951ComparisonSeveralMean">1951</a>)</span>, both of which avoid the assumption that all groups have equal equality of variances.
Brown and Forsythe also evaluated the conventional one-way ANOVA F-test as a benchmark, even though this procedure maintains the assumption of equal variances.
They also proposed and evaluated a new procedure of their own devising.<a href="#fn10" class="footnote-ref" id="fnref10"><sup>10</sup></a>
Their simulation involved comparing the performance of these different hypothesis testing procedures (the methods) under a range of conditions (different data generating processes) with different sample sizes and different degrees of heteroskedasticity.
They looked at the different scenarios shown as Table @ref(tab:BF-Scenarios), varying number of groups, group size, and amount of variation within each group.
In all, there are a total of 20 scenarios, covering conditions with between 10 and 6 groups.</p>
<table class="table table-striped table-hover" style="width: auto !important; margin-left: auto; margin-right: auto;">
<caption>
(#tab:BF-Scenarios)Simulation scenarios explored by Brown and Forsythe (1974)
</caption>
<thead>
<tr>
<th style="text-align:left;">
Scenario
</th>
<th style="text-align:left;">
Groups
</th>
<th style="text-align:left;">
Sample Sizes
</th>
<th style="text-align:left;">
Standard Deviations
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
A
</td>
<td style="text-align:left;">
4
</td>
<td style="text-align:left;">
4,4,4,4
</td>
<td style="text-align:left;">
1,1,1,1
</td>
</tr>
<tr>
<td style="text-align:left;">
B
</td>
<td style="text-align:left;">
4
</td>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
1,2,2,3
</td>
</tr>
<tr>
<td style="text-align:left;">
C
</td>
<td style="text-align:left;">
4
</td>
<td style="text-align:left;">
4,8,10,12
</td>
<td style="text-align:left;">
1,1,1,1
</td>
</tr>
<tr>
<td style="text-align:left;">
D
</td>
<td style="text-align:left;">
4
</td>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
1,2,2,3
</td>
</tr>
<tr>
<td style="text-align:left;">
E
</td>
<td style="text-align:left;">
4
</td>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
3,2,2,1
</td>
</tr>
<tr>
<td style="text-align:left;">
F
</td>
<td style="text-align:left;">
4
</td>
<td style="text-align:left;">
11,11,11,11
</td>
<td style="text-align:left;">
1,1,1,1
</td>
</tr>
<tr>
<td style="text-align:left;">
G
</td>
<td style="text-align:left;">
4
</td>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
1,2,2,3
</td>
</tr>
<tr>
<td style="text-align:left;">
H
</td>
<td style="text-align:left;">
4
</td>
<td style="text-align:left;">
11,16,16,21
</td>
<td style="text-align:left;">
1,1,1,1
</td>
</tr>
<tr>
<td style="text-align:left;">
I
</td>
<td style="text-align:left;">
4
</td>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
3,2,2,1
</td>
</tr>
<tr>
<td style="text-align:left;">
J
</td>
<td style="text-align:left;">
4
</td>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
1,2,2,3
</td>
</tr>
<tr>
<td style="text-align:left;">
K
</td>
<td style="text-align:left;">
6
</td>
<td style="text-align:left;">
4,4,4,4,4,4
</td>
<td style="text-align:left;">
1,1,1,1,1,1
</td>
</tr>
<tr>
<td style="text-align:left;">
L
</td>
<td style="text-align:left;">
6
</td>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
1,1,2,2,3,3
</td>
</tr>
<tr>
<td style="text-align:left;">
M
</td>
<td style="text-align:left;">
6
</td>
<td style="text-align:left;">
4,6,6,8,10,12
</td>
<td style="text-align:left;">
1,1,1,1,1,1
</td>
</tr>
<tr>
<td style="text-align:left;">
N
</td>
<td style="text-align:left;">
6
</td>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
1,1,2,2,3,3
</td>
</tr>
<tr>
<td style="text-align:left;">
O
</td>
<td style="text-align:left;">
6
</td>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
3,3,2,2,1,1
</td>
</tr>
<tr>
<td style="text-align:left;">
P
</td>
<td style="text-align:left;">
6
</td>
<td style="text-align:left;">
6,6,6,6,6,6
</td>
<td style="text-align:left;">
1,1,2,2,3,3
</td>
</tr>
<tr>
<td style="text-align:left;">
Q
</td>
<td style="text-align:left;">
6
</td>
<td style="text-align:left;">
11,11,11,11,11,11
</td>
<td style="text-align:left;">
1,1,2,2,3,3
</td>
</tr>
<tr>
<td style="text-align:left;">
R
</td>
<td style="text-align:left;">
6
</td>
<td style="text-align:left;">
16,16,16,16,16,16
</td>
<td style="text-align:left;">
1,1,2,2,3,3
</td>
</tr>
<tr>
<td style="text-align:left;">
S
</td>
<td style="text-align:left;">
6
</td>
<td style="text-align:left;">
21,21,21,21,21,21
</td>
<td style="text-align:left;">
1,1,2,2,3,3
</td>
</tr>
<tr>
<td style="text-align:left;">
T
</td>
<td style="text-align:left;">
10
</td>
<td style="text-align:left;">
20,20,20,20,20,20,20,20,20,20
</td>
<td style="text-align:left;">
1,1,1.5,1.5,2,2,2.5,2.5,3,3
</td>
</tr>
</tbody>
</table>
<p>When evaluating hypothesis testing procedures, there are two main performance metrics of interest: type-I error rate and power.
The type-I error rate is the rate at which a test rejects the null hypothesis when the null hypothesis is actually true.
To apply a hypothesis testing procedure, one has to specify a desired, or nominal, type-I error rate, often denoted as the <span class="math inline">\(\alpha\)</span>-level.
For a specified <span class="math inline">\(\alpha\)</span>, a valid or well-calibrated test should have an actual type-I error rate less than or equal to the nominal level, and ideally should be very close to nominal.
<!-- JEP: Do you have a source for the terminology of a _valid_ test? I'm kind of wary of calling it the validity of a test because validity is already such an overloaded term. In some of my work, I've written about type-I error as measuring whether the test is appropriately _calibrated_, which lines up with the idea of calibrating physical measurement instruments like scales or temperature gauges. -->
<!-- LWM: I poked around and valid seems to be common usage.  (Lot of papers talk about valid testing, for example).  Not sure we would want to cite that term here?  But i am content with calibrated only if you prefer. -->
Power is how often a test correctly rejects the null when it is indeed false.
It is a measure of how sensitive a method is to violations of the null.</p>
<p>Brown and Forsythe estimated error rates and power for nominal <span class="math inline">\(\alpha\)</span>-levels of 1%, 5%, and 10%.
Table 1 of their paper reports the simulation results for type-I error (labeled as “size”).
Our Table @ref(tab:BF-table1) reports some of their results with respect to Type I error.
For a well-calibrated hypothesis testing method, the reported numbers should be very close to the desired alpha levels, as listed at the top of the table.
We can compare the four tests to each other across each row, where each row is a specific scenario defined by a specific data generating process.
Looking at ANOVA, for example, we see some scenarios with very elevated rates. For instance, in Scenario E, the ANOVA F-test has 21.9% rejection when it should only have 10%.
In contrast, the ANOVA F works fine under scenario A, which is what one would expect because all the groups have the same variance.
Brown and Forsythe’s choice of scenarios here illustrates a broader design principle: to provide a full picture of the performance of a method or set of methods, it is wise to always evaluate them under conditions where we expect things to work, as well as conditions where we expect them to not work well.</p>
<table class="table table-striped table-hover" style="width: auto !important; margin-left: auto; margin-right: auto;">
<caption>
(#tab:BF-table1)Portion of “Table 1” reproduced from Brown and Forsythe (1974)
</caption>
<thead>
<tr>
<th style="empty-cells: hide;border-bottom:hidden;" colspan="1">
</th>
<th style="border-bottom:hidden;padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; " colspan="3">
<div style="border-bottom: 1px solid #ddd; padding-bottom: 5px; ">
ANOVA F test
</div>
</th>
<th style="border-bottom:hidden;padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; " colspan="3">
<div style="border-bottom: 1px solid #ddd; padding-bottom: 5px; ">
B &amp; F’s F* test
</div>
</th>
<th style="border-bottom:hidden;padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; " colspan="3">
<div style="border-bottom: 1px solid #ddd; padding-bottom: 5px; ">
Welch’s test
</div>
</th>
<th style="border-bottom:hidden;padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; " colspan="3">
<div style="border-bottom: 1px solid #ddd; padding-bottom: 5px; ">
James’ test
</div>
</th>
</tr>
<tr>
<th style="text-align:left;">
Scenario
</th>
<th style="text-align:right;">
10%
</th>
<th style="text-align:right;">
5%
</th>
<th style="text-align:right;">
1%
</th>
<th style="text-align:right;">
10%
</th>
<th style="text-align:right;">
5%
</th>
<th style="text-align:right;">
1%
</th>
<th style="text-align:right;">
10%
</th>
<th style="text-align:right;">
5%
</th>
<th style="text-align:right;">
1%
</th>
<th style="text-align:right;">
10%
</th>
<th style="text-align:right;">
5%
</th>
<th style="text-align:right;">
1%
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
A
</td>
<td style="text-align:right;">
10.2
</td>
<td style="text-align:right;">
4.9
</td>
<td style="text-align:right;">
0.9
</td>
<td style="text-align:right;">
7.8
</td>
<td style="text-align:right;">
3.4
</td>
<td style="text-align:right;">
0.5
</td>
<td style="text-align:right;">
9.6
</td>
<td style="text-align:right;">
4.5
</td>
<td style="text-align:right;">
0.8
</td>
<td style="text-align:right;">
13.3
</td>
<td style="text-align:right;">
7.9
</td>
<td style="text-align:right;">
2.4
</td>
</tr>
<tr>
<td style="text-align:left;">
B
</td>
<td style="text-align:right;">
12.0
</td>
<td style="text-align:right;">
6.7
</td>
<td style="text-align:right;">
1.7
</td>
<td style="text-align:right;">
8.9
</td>
<td style="text-align:right;">
4.1
</td>
<td style="text-align:right;">
0.7
</td>
<td style="text-align:right;">
10.3
</td>
<td style="text-align:right;">
4.7
</td>
<td style="text-align:right;">
0.8
</td>
<td style="text-align:right;">
13.8
</td>
<td style="text-align:right;">
8.1
</td>
<td style="text-align:right;">
2.7
</td>
</tr>
<tr>
<td style="text-align:left;">
C
</td>
<td style="text-align:right;">
9.9
</td>
<td style="text-align:right;">
5.1
</td>
<td style="text-align:right;">
1.1
</td>
<td style="text-align:right;">
9.5
</td>
<td style="text-align:right;">
4.8
</td>
<td style="text-align:right;">
1.0
</td>
<td style="text-align:right;">
10.8
</td>
<td style="text-align:right;">
5.7
</td>
<td style="text-align:right;">
1.6
</td>
<td style="text-align:right;">
12.1
</td>
<td style="text-align:right;">
6.7
</td>
<td style="text-align:right;">
2.1
</td>
</tr>
<tr>
<td style="text-align:left;">
D
</td>
<td style="text-align:right;">
5.9
</td>
<td style="text-align:right;">
3.0
</td>
<td style="text-align:right;">
0.6
</td>
<td style="text-align:right;">
10.3
</td>
<td style="text-align:right;">
5.7
</td>
<td style="text-align:right;">
1.4
</td>
<td style="text-align:right;">
9.8
</td>
<td style="text-align:right;">
4.9
</td>
<td style="text-align:right;">
0.9
</td>
<td style="text-align:right;">
10.8
</td>
<td style="text-align:right;">
5.6
</td>
<td style="text-align:right;">
1.3
</td>
</tr>
<tr>
<td style="text-align:left;">
E
</td>
<td style="text-align:right;">
21.9
</td>
<td style="text-align:right;">
14.4
</td>
<td style="text-align:right;">
5.6
</td>
<td style="text-align:right;">
11.0
</td>
<td style="text-align:right;">
6.2
</td>
<td style="text-align:right;">
1.8
</td>
<td style="text-align:right;">
11.3
</td>
<td style="text-align:right;">
6.5
</td>
<td style="text-align:right;">
2.0
</td>
<td style="text-align:right;">
12.9
</td>
<td style="text-align:right;">
7.7
</td>
<td style="text-align:right;">
2.9
</td>
</tr>
<tr>
<td style="text-align:left;">
F
</td>
<td style="text-align:right;">
10.1
</td>
<td style="text-align:right;">
5.1
</td>
<td style="text-align:right;">
1.0
</td>
<td style="text-align:right;">
9.8
</td>
<td style="text-align:right;">
5.7
</td>
<td style="text-align:right;">
1.5
</td>
<td style="text-align:right;">
10.0
</td>
<td style="text-align:right;">
5.0
</td>
<td style="text-align:right;">
0.9
</td>
<td style="text-align:right;">
10.6
</td>
<td style="text-align:right;">
5.5
</td>
<td style="text-align:right;">
1.1
</td>
</tr>
<tr>
<td style="text-align:left;">
G
</td>
<td style="text-align:right;">
11.4
</td>
<td style="text-align:right;">
6.3
</td>
<td style="text-align:right;">
1.8
</td>
<td style="text-align:right;">
10.7
</td>
<td style="text-align:right;">
5.7
</td>
<td style="text-align:right;">
1.5
</td>
<td style="text-align:right;">
10.1
</td>
<td style="text-align:right;">
5.0
</td>
<td style="text-align:right;">
1.1
</td>
<td style="text-align:right;">
10.6
</td>
<td style="text-align:right;">
5.4
</td>
<td style="text-align:right;">
1.3
</td>
</tr>
<tr>
<td style="text-align:left;">
H
</td>
<td style="text-align:right;">
10.3
</td>
<td style="text-align:right;">
4.9
</td>
<td style="text-align:right;">
1.1
</td>
<td style="text-align:right;">
10.3
</td>
<td style="text-align:right;">
5.1
</td>
<td style="text-align:right;">
1.0
</td>
<td style="text-align:right;">
10.2
</td>
<td style="text-align:right;">
5.0
</td>
<td style="text-align:right;">
1.0
</td>
<td style="text-align:right;">
10.5
</td>
<td style="text-align:right;">
5.3
</td>
<td style="text-align:right;">
1.2
</td>
</tr>
<tr>
<td style="text-align:left;">
I
</td>
<td style="text-align:right;">
17.3
</td>
<td style="text-align:right;">
10.8
</td>
<td style="text-align:right;">
3.9
</td>
<td style="text-align:right;">
11.1
</td>
<td style="text-align:right;">
6.2
</td>
<td style="text-align:right;">
1.8
</td>
<td style="text-align:right;">
10.5
</td>
<td style="text-align:right;">
5.5
</td>
<td style="text-align:right;">
1.2
</td>
<td style="text-align:right;">
10.9
</td>
<td style="text-align:right;">
5.8
</td>
<td style="text-align:right;">
1.3
</td>
</tr>
<tr>
<td style="text-align:left;">
J
</td>
<td style="text-align:right;">
7.3
</td>
<td style="text-align:right;">
4.0
</td>
<td style="text-align:right;">
1.0
</td>
<td style="text-align:right;">
11.5
</td>
<td style="text-align:right;">
6.5
</td>
<td style="text-align:right;">
1.8
</td>
<td style="text-align:right;">
10.6
</td>
<td style="text-align:right;">
5.4
</td>
<td style="text-align:right;">
1.1
</td>
<td style="text-align:right;">
10.9
</td>
<td style="text-align:right;">
5.6
</td>
<td style="text-align:right;">
1.1
</td>
</tr>
<tr>
<td style="text-align:left;">
K
</td>
<td style="text-align:right;">
9.6
</td>
<td style="text-align:right;">
4.9
</td>
<td style="text-align:right;">
1.0
</td>
<td style="text-align:right;">
7.3
</td>
<td style="text-align:right;">
3.4
</td>
<td style="text-align:right;">
0.4
</td>
<td style="text-align:right;">
11.4
</td>
<td style="text-align:right;">
6.1
</td>
<td style="text-align:right;">
1.4
</td>
<td style="text-align:right;">
14.7
</td>
<td style="text-align:right;">
9.5
</td>
<td style="text-align:right;">
3.8
</td>
</tr>
</tbody>
</table>
<p>To replicate the Brown and Forsythe simulation, we will first write functions to generate data for a specified scenario and evaluate data of a given structure.
We will then use these functions to evaluate the hypothesis testing procedures in a specific scenario with a particular set of parameters (e.g., sample sizes, number of groups, and so forth). We will then scale up to execute the simulations for a range of scenarios that vary the parameters of the data-generating model, just as reported in Brown and Forsythe’s paper.</p>
<div id="case-anova-DGP" class="section level2 hasAnchor" number="5.1">
<h2 class="hasAnchor"><span class="header-section-number">5.1</span> The data-generating model<a href="#case-anova-DGP" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>In the heteroskedastic one-way ANOVA simulation, there are three sets of parameter values: population means, population variances, and sample sizes.
Rather than attempting to write a general data-generating function immediately, it is often easier to write code for a specific case first and then use that code as a starting point for developing a function.
For example, say that we have four groups with means of 1, 2, 5, 6; variances of 3, 2, 5, 1; and sample sizes of 3, 6, 2, 4:</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb90-1"><a href="#cb90-1" tabindex="-1"></a>mu <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">6</span>)</span>
<span id="cb90-2"><a href="#cb90-2" tabindex="-1"></a>sigma_sq <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">1</span>)</span>
<span id="cb90-3"><a href="#cb90-3" tabindex="-1"></a>sample_size <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">3</span>, <span class="dv">6</span>, <span class="dv">2</span>, <span class="dv">4</span>)</span></code></pre></div>
<p>Following <span class="citation">Brown and Forsythe (<a href="#ref-brown1974SmallSampleBehavior">1974</a>)</span>, we will assume that the measurements are normally distributed within each sub-group of the population. The following code generates a vector of group id’s and a vector of simulated measurements:</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb91-1"><a href="#cb91-1" tabindex="-1"></a>N <span class="ot">&lt;-</span> <span class="fu">sum</span>(sample_size) <span class="co"># total sample size</span></span>
<span id="cb91-2"><a href="#cb91-2" tabindex="-1"></a>G <span class="ot">&lt;-</span> <span class="fu">length</span>(sample_size) <span class="co"># number of groups</span></span>
<span id="cb91-3"><a href="#cb91-3" tabindex="-1"></a></span>
<span id="cb91-4"><a href="#cb91-4" tabindex="-1"></a><span class="co"># group id factor</span></span>
<span id="cb91-5"><a href="#cb91-5" tabindex="-1"></a>group <span class="ot">&lt;-</span> <span class="fu">factor</span>(<span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span>G, <span class="at">times =</span> sample_size))</span>
<span id="cb91-6"><a href="#cb91-6" tabindex="-1"></a></span>
<span id="cb91-7"><a href="#cb91-7" tabindex="-1"></a><span class="co"># mean for each unit of the sample</span></span>
<span id="cb91-8"><a href="#cb91-8" tabindex="-1"></a>mu_long <span class="ot">&lt;-</span> <span class="fu">rep</span>(mu, <span class="at">times =</span> sample_size) </span>
<span id="cb91-9"><a href="#cb91-9" tabindex="-1"></a></span>
<span id="cb91-10"><a href="#cb91-10" tabindex="-1"></a><span class="co"># sd for each unit of the sample</span></span>
<span id="cb91-11"><a href="#cb91-11" tabindex="-1"></a>sigma_long <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="fu">sqrt</span>(sigma_sq), <span class="at">times =</span> sample_size) </span>
<span id="cb91-12"><a href="#cb91-12" tabindex="-1"></a></span>
<span id="cb91-13"><a href="#cb91-13" tabindex="-1"></a><span class="co"># See what we have?</span></span>
<span id="cb91-14"><a href="#cb91-14" tabindex="-1"></a><span class="fu">tibble</span>( <span class="at">group =</span> group, <span class="at">mu =</span> mu_long, <span class="at">sigma =</span> sigma_long )</span></code></pre></div>
<pre><code>## # A tibble: 15 × 3
##    group    mu sigma
##    &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1 1         1  1.73
##  2 1         1  1.73
##  3 1         1  1.73
##  4 2         2  1.41
##  5 2         2  1.41
##  6 2         2  1.41
##  7 2         2  1.41
##  8 2         2  1.41
##  9 2         2  1.41
## 10 3         5  2.24
## 11 3         5  2.24
## 12 4         6  1   
## 13 4         6  1   
## 14 4         6  1   
## 15 4         6  1</code></pre>
<p>Now we have the pieces needed to generate a small dataset consisting of group memberships and the measured characteristic:</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb93-1"><a href="#cb93-1" tabindex="-1"></a><span class="co"># Now make our data</span></span>
<span id="cb93-2"><a href="#cb93-2" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(N, <span class="at">mean =</span> mu_long, <span class="at">sd =</span> sigma_long)</span>
<span id="cb93-3"><a href="#cb93-3" tabindex="-1"></a>dat <span class="ot">&lt;-</span> <span class="fu">tibble</span>(<span class="at">group =</span> group, <span class="at">x =</span> x)</span>
<span id="cb93-4"><a href="#cb93-4" tabindex="-1"></a>dat</span></code></pre></div>
<pre><code>## # A tibble: 15 × 2
##    group      x
##    &lt;fct&gt;  &lt;dbl&gt;
##  1 1      1.24 
##  2 1      3.07 
##  3 1     -0.681
##  4 2      2.43 
##  5 2      2.50 
##  6 2      2.15 
##  7 2      0.612
##  8 2      0.860
##  9 2      2.09 
## 10 3      1.56 
## 11 3      5.08 
## 12 4      5.68 
## 13 4      5.66 
## 14 4      5.92 
## 15 4      4.38</code></pre>
<p>We have followed the strategy of first constructing a dataset with parameters for each observation in each group, making heavy use of base R’s <code>rep()</code> function to repeat values in a list.
We then called <code>rnorm()</code> to generate <code>N</code> observations in all.
This works because <code>rnorm()</code> is <em>vectorized</em>; if you give it a vector (or vectors) of parameter values, it will generate each subsequent observation according to the next entry in the vector. As a result, the first <code>x</code> value is simulated from a normal distribution with mean <code>mu_long[1]</code> and standard deviation <code>sd_long[1]</code>, the second <code>x</code> is simulated using <code>mu_long[2]</code> and <code>sd_long[2]</code>, and so on.</p>
<p>As usual, there are many different and legitimate ways of doing this in R.
For instance, instead of using <code>rep()</code> to do it all at once, we could generate observations for each group separately, then stack the observations into a dataset.
Do not worry about trying to writing code the “best” way—especially when you are initially putting a simulation together.
If you can find a way to accomplish your task at all, then that’s often enough (and you should feel good about it!).</p>
<div id="now-make-a-function" class="section level3 hasAnchor" number="5.1.1">
<h3 class="hasAnchor"><span class="header-section-number">5.1.1</span> Now make a function<a href="#now-make-a-function" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Because we will need to generate datasets over and over, we will wrap our code in a function.
The inputs to the function will be the parameters of the model that we specified at the very beginning: the set of population means <code>mu</code>, the population variances <code>sigma_sq</code>, and sample sizes <code>sample_size</code>. We make these quantities arguments of the data-generating function so that we can make datasets of different sizes and shapes:</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb95-1"><a href="#cb95-1" tabindex="-1"></a>generate_ANOVA_data <span class="ot">&lt;-</span> <span class="cf">function</span>(mu, sigma_sq, sample_size) {</span>
<span id="cb95-2"><a href="#cb95-2" tabindex="-1"></a>  </span>
<span id="cb95-3"><a href="#cb95-3" tabindex="-1"></a>  N <span class="ot">&lt;-</span> <span class="fu">sum</span>(sample_size)</span>
<span id="cb95-4"><a href="#cb95-4" tabindex="-1"></a>  G <span class="ot">&lt;-</span> <span class="fu">length</span>(sample_size)</span>
<span id="cb95-5"><a href="#cb95-5" tabindex="-1"></a>  </span>
<span id="cb95-6"><a href="#cb95-6" tabindex="-1"></a>  group <span class="ot">&lt;-</span> <span class="fu">factor</span>(<span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span>G, <span class="at">times =</span> sample_size))</span>
<span id="cb95-7"><a href="#cb95-7" tabindex="-1"></a>  mu_long <span class="ot">&lt;-</span> <span class="fu">rep</span>(mu, <span class="at">times =</span> sample_size)</span>
<span id="cb95-8"><a href="#cb95-8" tabindex="-1"></a>  sigma_long <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="fu">sqrt</span>(sigma_sq), <span class="at">times =</span> sample_size)</span>
<span id="cb95-9"><a href="#cb95-9" tabindex="-1"></a>  </span>
<span id="cb95-10"><a href="#cb95-10" tabindex="-1"></a>  x <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(N, <span class="at">mean =</span> mu_long, <span class="at">sd =</span> sigma_long)</span>
<span id="cb95-11"><a href="#cb95-11" tabindex="-1"></a>  sim_data <span class="ot">&lt;-</span> <span class="fu">tibble</span>(<span class="at">group =</span> group, <span class="at">x =</span> x)</span>
<span id="cb95-12"><a href="#cb95-12" tabindex="-1"></a>  </span>
<span id="cb95-13"><a href="#cb95-13" tabindex="-1"></a>  <span class="fu">return</span>(sim_data)</span>
<span id="cb95-14"><a href="#cb95-14" tabindex="-1"></a>}</span></code></pre></div>
<p>The function is simply the code we built previously, all bundled up.
We developed the function by first writing code to make the data-generating process to work once, the way we want, and only then turning the final code into a function for later reuse.</p>
<p>Once we have turned the code into a function, we can call it to get a new set of simulated data.
For example, to generate a dataset with the same parameters as before, we can do:</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb96-1"><a href="#cb96-1" tabindex="-1"></a>sim_data <span class="ot">&lt;-</span> <span class="fu">generate_ANOVA_data</span>(</span>
<span id="cb96-2"><a href="#cb96-2" tabindex="-1"></a>  <span class="at">mu =</span> mu, </span>
<span id="cb96-3"><a href="#cb96-3" tabindex="-1"></a>  <span class="at">sigma_sq =</span> sigma_sq,</span>
<span id="cb96-4"><a href="#cb96-4" tabindex="-1"></a>  <span class="at">sample_size =</span> sample_size</span>
<span id="cb96-5"><a href="#cb96-5" tabindex="-1"></a>)</span>
<span id="cb96-6"><a href="#cb96-6" tabindex="-1"></a></span>
<span id="cb96-7"><a href="#cb96-7" tabindex="-1"></a><span class="fu">str</span>(sim_data)</span></code></pre></div>
<pre><code>## tibble [15 × 2] (S3: tbl_df/tbl/data.frame)
##  $ group: Factor w/ 4 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;: 1 1 1 2 2 2 2 2 2 3 ...
##  $ x    : num [1:15] 0.777 2.115 1.31 1.848 3.041 ...</code></pre>
<p>To generate one with population means of zero in all the groups, but the same group variances and sample sizes as before, we can do:</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb98-1"><a href="#cb98-1" tabindex="-1"></a>sim_data_null <span class="ot">&lt;-</span> <span class="fu">generate_ANOVA_data</span>(</span>
<span id="cb98-2"><a href="#cb98-2" tabindex="-1"></a>  <span class="at">mu =</span> <span class="fu">c</span>( <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span> ),</span>
<span id="cb98-3"><a href="#cb98-3" tabindex="-1"></a>  <span class="at">sigma_sq =</span> sigma_sq, </span>
<span id="cb98-4"><a href="#cb98-4" tabindex="-1"></a>  <span class="at">sample_size =</span> sample_size</span>
<span id="cb98-5"><a href="#cb98-5" tabindex="-1"></a>)</span>
<span id="cb98-6"><a href="#cb98-6" tabindex="-1"></a></span>
<span id="cb98-7"><a href="#cb98-7" tabindex="-1"></a><span class="fu">str</span>(sim_data)</span></code></pre></div>
<pre><code>## tibble [15 × 2] (S3: tbl_df/tbl/data.frame)
##  $ group: Factor w/ 4 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;: 1 1 1 2 2 2 2 2 2 3 ...
##  $ x    : num [1:15] 0.777 2.115 1.31 1.848 3.041 ...</code></pre>
<p>Following the principles of tidy, modular simulation, we have written a function that returns a rectangular dataset for further analysis.
Also note that the dataset returned by <code>generate_ANOVA_data()</code> only includes the variables <code>group</code> and <code>x</code>, but not <code>mu_long</code> or <code>sd_long</code>.
This is by design.
Including <code>mu_long</code> or <code>sd_long</code> would amount to making the population parameters available for use in the data analysis procedures, which is not something that happens when analyzing real data.</p>
</div>
<div id="cautious-coding" class="section level3 hasAnchor" number="5.1.2">
<h3 class="hasAnchor"><span class="header-section-number">5.1.2</span> Cautious coding<a href="#cautious-coding" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>In the above, we built some sample code, and then bundled it into a function by literally cutting and pasting the initial work we did into a function skeleton.
In the process, we shifted from having variables in our workspace with different names to using those variable names as parameters in our function call.</p>
<p>Developing code in this way is not without hazards.
In particular, after we have created our function, our workspace is left with a variable <code>mu</code> in it and our function also has a parameter named <code>mu</code>.
Inside the function, R will use the parameter <code>mu</code> first, but this is potentially confusing.
Another potential source of confusion are lines such as <code>mu = mu</code>, which means “set the function’s parameter called <code>mu</code> to the variable called <code>mu</code>.”
These are different things (with the same name).</p>
<p>Once you have built a function, one way to check that it is working properly is to comment out the initial code (or delete it), clear out the workspace (or restart R), and then re-run the code that uses the function.
If things still work, then you can be somewhat confident that you have successfully bundled your code into the function.
Once you bundle your code, you can also do a search and replace to change the variable names inside your function to something more generic, to better clarify the distinction betwen object names and argument names.</p>
</div>
</div>
<div id="the-hypothesis-testing-procedures" class="section level2 hasAnchor" number="5.2">
<h2 class="hasAnchor"><span class="header-section-number">5.2</span> The hypothesis testing procedures<a href="#the-hypothesis-testing-procedures" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Brown and Forsythe considered four different hypothesis testing procedures for heteroskedastic ANOVA, but we will focus on just two of the tests for now.
We start with the conventional one-way ANOVA that mistakenly assumes homoskedasticity.
R’s <code>oneway.test</code> function will calculate this test automatically:</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb100-1"><a href="#cb100-1" tabindex="-1"></a>sim_data <span class="ot">&lt;-</span> <span class="fu">generate_ANOVA_data</span>(</span>
<span id="cb100-2"><a href="#cb100-2" tabindex="-1"></a>  <span class="at">mu =</span> mu, </span>
<span id="cb100-3"><a href="#cb100-3" tabindex="-1"></a>  <span class="at">sigma_sq =</span> sigma_sq,</span>
<span id="cb100-4"><a href="#cb100-4" tabindex="-1"></a>  <span class="at">sample_size =</span> sample_size</span>
<span id="cb100-5"><a href="#cb100-5" tabindex="-1"></a>)</span>
<span id="cb100-6"><a href="#cb100-6" tabindex="-1"></a></span>
<span id="cb100-7"><a href="#cb100-7" tabindex="-1"></a>anova_F <span class="ot">&lt;-</span> <span class="fu">oneway.test</span>(x <span class="sc">~</span> group, <span class="at">data =</span> sim_data, <span class="at">var.equal =</span> <span class="cn">TRUE</span>)</span>
<span id="cb100-8"><a href="#cb100-8" tabindex="-1"></a>anova_F</span></code></pre></div>
<pre><code>## 
##  One-way analysis of means
## 
## data:  x and group
## F = 8.9503, num df = 3, denom df = 11,
## p-value = 0.002738</code></pre>
<p>We can use the same function to calculate Welch’s test by setting <code>var.equal = FALSE</code>:</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb102-1"><a href="#cb102-1" tabindex="-1"></a>Welch_F <span class="ot">&lt;-</span> <span class="fu">oneway.test</span>(x <span class="sc">~</span> group, <span class="at">data =</span> sim_data, <span class="at">var.equal =</span> <span class="cn">FALSE</span>)</span>
<span id="cb102-2"><a href="#cb102-2" tabindex="-1"></a>Welch_F</span></code></pre></div>
<pre><code>## 
##  One-way analysis of means (not assuming
##  equal variances)
## 
## data:  x and group
## F = 22.321, num df = 3.0000, denom df =
## 3.0622, p-value = 0.01399</code></pre>
<p>The main results we need here are the <span class="math inline">\(p\)</span>-values of the tests, which will let us assess Type-I error and power for a given nominal <span class="math inline">\(\alpha\)</span>-level. The following function takes simulated data as input and returns as output the <span class="math inline">\(p\)</span>-values from the one-way ANOVA test and Welch test:</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb104-1"><a href="#cb104-1" tabindex="-1"></a>ANOVA_Welch_F <span class="ot">&lt;-</span> <span class="cf">function</span>(data) {</span>
<span id="cb104-2"><a href="#cb104-2" tabindex="-1"></a>  anova_F <span class="ot">&lt;-</span> <span class="fu">oneway.test</span>(x <span class="sc">~</span> group, <span class="at">data =</span> data, <span class="at">var.equal =</span> <span class="cn">TRUE</span>)</span>
<span id="cb104-3"><a href="#cb104-3" tabindex="-1"></a>  Welch_F <span class="ot">&lt;-</span> <span class="fu">oneway.test</span>(x <span class="sc">~</span> group, <span class="at">data =</span> data, <span class="at">var.equal =</span> <span class="cn">FALSE</span>)</span>
<span id="cb104-4"><a href="#cb104-4" tabindex="-1"></a>  </span>
<span id="cb104-5"><a href="#cb104-5" tabindex="-1"></a>  result <span class="ot">&lt;-</span> <span class="fu">tibble</span>(</span>
<span id="cb104-6"><a href="#cb104-6" tabindex="-1"></a>    <span class="at">ANOVA =</span> anova_F<span class="sc">$</span>p.value,</span>
<span id="cb104-7"><a href="#cb104-7" tabindex="-1"></a>    <span class="at">Welch =</span> Welch_F<span class="sc">$</span>p.value</span>
<span id="cb104-8"><a href="#cb104-8" tabindex="-1"></a>  )</span>
<span id="cb104-9"><a href="#cb104-9" tabindex="-1"></a>  </span>
<span id="cb104-10"><a href="#cb104-10" tabindex="-1"></a>  <span class="fu">return</span>(result)</span>
<span id="cb104-11"><a href="#cb104-11" tabindex="-1"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb105"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb105-1"><a href="#cb105-1" tabindex="-1"></a><span class="fu">ANOVA_Welch_F</span>(sim_data)</span></code></pre></div>
<pre><code>## # A tibble: 1 × 2
##     ANOVA  Welch
##     &lt;dbl&gt;  &lt;dbl&gt;
## 1 0.00274 0.0140</code></pre>
<p>Following our tidy, modular simulation principles, this function returns a small dataset with the p-values from both tests.
Eventually, we might want to use this function on some real data.
Our estimation function does not care if the data are simulated or not; we call the input <code>data</code> rather than <code>sim_data</code> to reflect this.</p>
<p>As an alternative to this function, we could instead write code to implement the ANOVA and Welch tests ourselves.
This has some potential advantages, such as avoiding any extraneous calculations that <code>oneway.test</code> does, which take time and slow down our simulation.
However, there are also drawbacks to doing so, including that writing our own code takes <em>our</em> time and opens up the possibility of errors in our code.
For further discussion of the trade-offs, see Chapter @ref(optimize-code), where we do implement these tests by hand and see what kind of speed-ups we can obtain.</p>
</div>
<div id="running-the-simulation" class="section level2 hasAnchor" number="5.3">
<h2 class="hasAnchor"><span class="header-section-number">5.3</span> Running the simulation<a href="#running-the-simulation" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>We now have functions that implement steps 2 and 3 of the simulation.
Given some parameters, <code>generate_ANOVA_data</code> produces a simulated dataset and, given some data, <code>ANOVA_Welch_F</code> calculates <span class="math inline">\(p\)</span>-values two different ways.
We now want to know which way is better, and by how much.
To answer this question, we will need to repeat the chain of generate-and-analyze calculations a bunch of times.
To facilitate repetition, we first put the components together into a single function:</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb107-1"><a href="#cb107-1" tabindex="-1"></a>one_run <span class="ot">=</span> <span class="cf">function</span>( mu, sigma_sq, sample_size ) {</span>
<span id="cb107-2"><a href="#cb107-2" tabindex="-1"></a>  sim_data <span class="ot">&lt;-</span> <span class="fu">generate_ANOVA_data</span>( <span class="at">mu =</span> mu, <span class="at">sigma_sq =</span> sigma_sq, <span class="at">sample_size =</span> sample_size )</span>
<span id="cb107-3"><a href="#cb107-3" tabindex="-1"></a>  <span class="fu">ANOVA_Welch_F</span>(sim_data)</span>
<span id="cb107-4"><a href="#cb107-4" tabindex="-1"></a>}</span>
<span id="cb107-5"><a href="#cb107-5" tabindex="-1"></a></span>
<span id="cb107-6"><a href="#cb107-6" tabindex="-1"></a><span class="fu">one_run</span>( <span class="at">mu =</span> mu, <span class="at">sigma_sq =</span> sigma_sq, <span class="at">sample_size =</span> sample_size )</span></code></pre></div>
<pre><code>## # A tibble: 1 × 2
##    ANOVA Welch
##    &lt;dbl&gt; &lt;dbl&gt;
## 1 0.0167 0.107</code></pre>
<p>This function implements a single simulation trial by generating artificial data and then analyzing the data, ending with a tidy dataset that has results for the single run.</p>
<p>We next call <code>one_run()</code> over and over; see Appendix @ref(repeating-oneself) for some discussion of options.
The following uses <code>repeat_and_stack()</code> from <code>simhelpers</code> to evaluate <code>one_run()</code> 4 times and then stack the results into a single dataset:</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb109-1"><a href="#cb109-1" tabindex="-1"></a><span class="fu">library</span>(simhelpers)</span>
<span id="cb109-2"><a href="#cb109-2" tabindex="-1"></a></span>
<span id="cb109-3"><a href="#cb109-3" tabindex="-1"></a>sim_data <span class="ot">&lt;-</span> <span class="fu">repeat_and_stack</span>(<span class="dv">4</span>, </span>
<span id="cb109-4"><a href="#cb109-4" tabindex="-1"></a>  <span class="fu">one_run</span>( <span class="at">mu =</span> mu, <span class="at">sigma_sq =</span> sigma_sq, <span class="at">sample_size =</span> sample_size)</span>
<span id="cb109-5"><a href="#cb109-5" tabindex="-1"></a>)</span>
<span id="cb109-6"><a href="#cb109-6" tabindex="-1"></a>sim_data</span></code></pre></div>
<pre><code>## # A tibble: 4 × 2
##     ANOVA  Welch
##     &lt;dbl&gt;  &lt;dbl&gt;
## 1 0.0262  0.0125
## 2 0.00451 0.0698
## 3 0.00229 0.0380
## 4 0.0108  0.0423</code></pre>
<p>Voila! We have simulated <span class="math inline">\(p\)</span>-values!</p>
</div>
<div id="summarizing-test-performance" class="section level2 hasAnchor" number="5.4">
<h2 class="hasAnchor"><span class="header-section-number">5.4</span> Summarizing test performance<a href="#summarizing-test-performance" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>We now have all the pieces in place to reproduce the results from Brown and Forsythe (1974).
We first focus on calculating the actual type-I error rate of these tests—that is, the proportion of the time that they reject the null hypothesis of equal means when that null is actually true—for an <span class="math inline">\(\alpha\)</span>-level of .05.
To evaluate the type-I error rate, we need to simulate data from a process where the population means are indeed all equal.
Arbitrarily, let’s start with <span class="math inline">\(G = 4\)</span> groups and set all of the means equal to zero:</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb111-1"><a href="#cb111-1" tabindex="-1"></a>mu <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="dv">0</span>, <span class="dv">4</span>)</span></code></pre></div>
<p>In the fifth row of Table 1 (Scenario E in our Table @ref(tab:BF-Scenarios)), Brown and Forsythe examine performance for the following parameter values for sample size and population variance:</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb112-1"><a href="#cb112-1" tabindex="-1"></a>sample_size <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">4</span>, <span class="dv">8</span>, <span class="dv">10</span>, <span class="dv">12</span>)</span>
<span id="cb112-2"><a href="#cb112-2" tabindex="-1"></a>sigma_sq <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">1</span>)<span class="sc">^</span><span class="dv">2</span></span></code></pre></div>
<p>With these parameter values, we can use <code>map_dfr</code> to simulate 10,000 <span class="math inline">\(p\)</span>-values:</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb113-1"><a href="#cb113-1" tabindex="-1"></a>p_vals <span class="ot">&lt;-</span> <span class="fu">repeat_and_stack</span>(<span class="dv">10000</span>, </span>
<span id="cb113-2"><a href="#cb113-2" tabindex="-1"></a>  <span class="fu">one_run</span>(</span>
<span id="cb113-3"><a href="#cb113-3" tabindex="-1"></a>    <span class="at">mu =</span> mu,</span>
<span id="cb113-4"><a href="#cb113-4" tabindex="-1"></a>    <span class="at">sigma_sq =</span> sigma_sq,</span>
<span id="cb113-5"><a href="#cb113-5" tabindex="-1"></a>    <span class="at">sample_size =</span> sample_size</span>
<span id="cb113-6"><a href="#cb113-6" tabindex="-1"></a>  ) </span>
<span id="cb113-7"><a href="#cb113-7" tabindex="-1"></a>)</span></code></pre></div>
<p>We can estimate the rejection rates by summarizing across these replicated p-values.
The rule is that the null is rejected if the <span class="math inline">\(p\)</span>-value is less than <span class="math inline">\(\alpha\)</span>.
To get the rejection rate, we calculate the proportion of replications where the null is rejected:</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb114-1"><a href="#cb114-1" tabindex="-1"></a><span class="fu">sum</span>(p_vals<span class="sc">$</span>ANOVA <span class="sc">&lt;</span> <span class="fl">0.05</span>) <span class="sc">/</span> <span class="dv">10000</span></span></code></pre></div>
<pre><code>## [1] 0.1391</code></pre>
<p>This is equivalent to taking the mean of the logical conditions:</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb116-1"><a href="#cb116-1" tabindex="-1"></a><span class="fu">mean</span>(p_vals<span class="sc">$</span>ANOVA <span class="sc">&lt;</span> <span class="fl">0.05</span>)</span></code></pre></div>
<pre><code>## [1] 0.1391</code></pre>
<p>We get a rejection rate that is much larger than <span class="math inline">\(\alpha = .05\)</span>.
We have learned that the ANOVA F-test does not adequately control Type-I error under this set of conditions.</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb118-1"><a href="#cb118-1" tabindex="-1"></a><span class="fu">mean</span>(p_vals<span class="sc">$</span>Welch <span class="sc">&lt;</span> <span class="fl">0.05</span>)</span></code></pre></div>
<pre><code>## [1] 0.0697</code></pre>
<p>The Welch test does much better, although it appears to be a little bit in excess of 0.05.</p>
<p>Note that these two numbers are quite close (though not quite identical) to the corresponding entries in Table 1 of Brown and Forsythe (1974). The difference is due to the fact that both Table 1 and are results are actually <em>estimated</em> rejection rates, because we have not actually simulated an infinite number of replications. The estimation error arising from using a finite number of replications is called <em>simulation error</em> (or <em>Monte Carlo error</em>).
In Chapter @ref(performance-criteria), we will look more at how to estimate and control the Monte Carlo simulation error in performance measures.</p>
<p>So there you have it! Each part of the simulation is a distinct block of code, and together we have a modular simulation that can be easily extended to other scenarios or other tests.
The exercises at the end of this chapter ask you to extend the framework further.
In working through them, you will get to experience first-hand how the modular code that we have started to develop is easier to work with than a single, monolithic block of code.</p>
</div>
<div id="exAnovaExercises" class="section level2 hasAnchor" number="5.5">
<h2 class="hasAnchor"><span class="header-section-number">5.5</span> Exercises<a href="#exAnovaExercises" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>The following exercises involve exploring and tweaking the above simulation code we have developed to replicate the results of Brown and Forsythe (1974).</p>
<ol style="list-style-type: decimal">
<li><p>Table 1 from Brown and Forsythe reported rejection rates for <span class="math inline">\(\alpha = .01\)</span> and <span class="math inline">\(\alpha = .10\)</span> in addition to <span class="math inline">\(\alpha = .05\)</span>. Calculate the rejection rates of the ANOVA F and Welch tests for all three <span class="math inline">\(\alpha\)</span>-levels and compare to the table.</p></li>
<li><p>Try simulating the Type-I error rates for the parameter values in the first two rows of Table 1 of the original paper. Use 10,000 replications. How do your results compare to the report results?</p></li>
<li><p>In the primary paper, Table 1 is about Type I error and Table 2 is about power. A portion of Table 2 follows:</p>
<table>
<caption>
<p>(#tab:BF-power)Portion of “Table 2” reproduced from Brown and Forsythe (1974)</p>
</caption>
<thead>
<tr>
<th style="text-align:left;">
<p>Variances</p>
</th>
<th style="text-align:left;">
<p>Means</p>
</th>
<th style="text-align:right;">
<p>Brown’s F</p>
</th>
<th style="text-align:right;">
<p>B &amp; F’s F*</p>
</th>
<th style="text-align:right;">
<p>Welch’s W</p>
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
<p>1,1,1,1</p>
</td>
<td style="text-align:left;">
<p>0,0,0,0</p>
</td>
<td style="text-align:right;">
<p>4.9</p>
</td>
<td style="text-align:right;">
<p>5.1</p>
</td>
<td style="text-align:right;">
<p>5.0</p>
</td>
</tr>
<tr>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
<p>1,0,0,0</p>
</td>
<td style="text-align:right;">
<p>68.6</p>
</td>
<td style="text-align:right;">
<p>67.6</p>
</td>
<td style="text-align:right;">
<p>65.0</p>
</td>
</tr>
<tr>
<td style="text-align:left;">
<p>3,2,2,1</p>
</td>
<td style="text-align:left;">
<p>0,0,0,0</p>
</td>
<td style="text-align:right;">
<p>NA</p>
</td>
<td style="text-align:right;">
<p>6.2</p>
</td>
<td style="text-align:right;">
<p>5.5</p>
</td>
</tr>
<tr>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
<p>1.3,0,0,1.3</p>
</td>
<td style="text-align:right;">
<p>NA</p>
</td>
<td style="text-align:right;">
<p>42.4</p>
</td>
<td style="text-align:right;">
<p>68.2</p>
</td>
</tr>
</tbody>
</table>
<p>In the table, the sizes of the four groups are 11, 16, 16, and 21, for all the scenarios.
Try simulating the <strong>power levels</strong> for a couple of sets of parameter values from Table @ref(tab:BF-power).
Use 10,000 replications.
How do your results compare to the results reported in the Table?</p></li>
<li><p>Instead of making <code>ANOVA_Welch_F</code> return a single row with the columns for the <span class="math inline">\(p\)</span>-values, one could instead return a dataset with one row for each test. The “long” approach is often nicer when evaluating more than two methods, or when each method returns not just a <span class="math inline">\(p\)</span>-value but other quantities of interest. For our current simulation, we might also want to store the <span class="math inline">\(F\)</span> statistic, for example. The resulting dataset would then look like the following:</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb120-1"><a href="#cb120-1" tabindex="-1"></a><span class="fu">ANOVA_Welch_F_long</span>(sim_data)</span></code></pre></div>
<pre><code>## # A tibble: 2 × 3
##   method Fstat  pvalue
##   &lt;chr&gt;  &lt;dbl&gt;   &lt;dbl&gt;
## 1 ANOVA   8.46 0.00338
## 2 Welch  14.3  0.0241</code></pre>
<p>Modify <code>ANOVA_Welch_F()</code> to return output in this format, update your simulation code, and then use <code>group_by()</code> plus <code>summarise()</code> to calculate rejection rates of both tests.
<code>group_by()</code> is a method for dividing your data into distinct groups and conducting an operation on each.
The classic form of this would be something like the following:</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb122-1"><a href="#cb122-1" tabindex="-1"></a>sres <span class="ot">&lt;-</span> </span>
<span id="cb122-2"><a href="#cb122-2" tabindex="-1"></a>  res <span class="sc">%&gt;%</span> </span>
<span id="cb122-3"><a href="#cb122-3" tabindex="-1"></a>  <span class="fu">group_by</span>( method ) <span class="sc">%&gt;%</span></span>
<span id="cb122-4"><a href="#cb122-4" tabindex="-1"></a>  <span class="fu">summarise</span>( <span class="at">rejection_rate =</span> <span class="fu">mean</span>( pvalue <span class="sc">&lt;</span> <span class="fl">0.05</span> ) )</span></code></pre></div></li>
<li><p>The <code>onewaytests</code> package in R includes functions for calculating Brown and Forsythe’s <span class="math inline">\(F^*\)</span> test and James’ test for differences in population means. Modify the data analysis function <code>ANOVA_Welch_F</code> (or, better yet, <code>ANOVA_Welch_F_long</code> from Exercise 4) to also include results from these hypothesis tests. Re-run the simulation to estimate the type-I error rate of all four tests under Scenarios A and B of Table @ref(tab:BF-Scenarios).</p></li>
</ol>
<!--chapter:end:015-Case-study-ANOVA.Rmd-->
</div>
</div>
<div id="data-generating-processes" class="section level1 hasAnchor" number="6">
<h1 class="hasAnchor"><span class="header-section-number">6</span> Data-generating processes<a href="#data-generating-processes" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p>As we saw in Chapter @ref(simulation-structure), the first step of a simulation is creating artificial data based on some process where we know (and can control) the truth.
This step is what we call the data generating process (DGP).
Think of it as a recipe for cooking up artificial data, which can be applied over and over, any time we’re hungry for a new dataset.
Like a good recipe, a good DGP needs to be complete—it cannot be missing ingredients and it cannot omit any steps.
Unlike cooking or baking, however, DGPs are usually specified in terms of a statistical model, or a set of equations involving constants, parameter values, and random variables.
More complex DGPs, such as those for hierarchical data or other latent variable models, will often involve a series of several equations that describe different dimensions or levels of the model, which need to be followed in sequence to produce an artificial dataset.</p>
<p>In this chapter, we will look at how to instantiate a DGP as an R function (or perhaps a set of functions).
Designing DGPs and implementing them in R code involves making choices about what aspects of the model we want to be able to control and how to set up the parameters of the model.
We start by providing a high-level overview of DGPs and discussing some of the choices and challenges involved in designing them.
We then demonstrate how to write R functions for DGPs.
In the remainder, we present detailed examples involving a hierarchical DGP for generating data on students nested within schools and an item response theory DGP for generating data on responses to individual test items.</p>
<div id="DGP-examples" class="section level2 hasAnchor" number="6.1">
<h2 class="hasAnchor"><span class="header-section-number">6.1</span> Examples<a href="#DGP-examples" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Before diving in, it is helpful to consider a few examples that we will return to throughout this and subsequent chapters.</p>
<div id="ANOVA-example" class="section level3 hasAnchor" number="6.1.1">
<h3 class="hasAnchor"><span class="header-section-number">6.1.1</span> Example 1: One-way analysis of variance<a href="#ANOVA-example" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>We have already seen one example of a DGP in the ANOVA example from Chapter @ref(case-ANOVA). Here, we consider observations on some variable <span class="math inline">\(X\)</span> drawn from a population consisting of <span class="math inline">\(G\)</span> groups, where group <span class="math inline">\(g\)</span> has population mean <span class="math inline">\(\mu_g\)</span> and population variance <span class="math inline">\(\sigma_g^2\)</span> for <span class="math inline">\(g = 1,...,G\)</span>.
A simulated dataset consists of <span class="math inline">\(n_g\)</span> observations from each group <span class="math inline">\(g = 1,...,G\)</span>, where <span class="math inline">\(X_{ig}\)</span> is the measurement for observation <span class="math inline">\(i\)</span> in group <span class="math inline">\(g\)</span>.
The statistical model for these data can be written as follows:
<span class="math display">\[
X_{ig} = \mu_g + \epsilon_{ig}, \quad \mbox{with} \quad \epsilon_{ig} \sim N( 0, \sigma^2_g )
\]</span>
for <span class="math inline">\(i = 1,...,n_g\)</span> and <span class="math inline">\(g = 1,...,G\)</span>.
Alternately, we could write the model as
<span class="math display">\[
X_{ig} \sim N( \mu_g, \sigma_g^2 ).
\]</span></p>
</div>
<div id="BVPois-example" class="section level3 hasAnchor" number="6.1.2">
<h3 class="hasAnchor"><span class="header-section-number">6.1.2</span> Example 2: Bivariate Poisson model<a href="#BVPois-example" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>As a second example, suppose that we want to understand how the usual Pearson sample correlation coefficient behaves with non-normal data and also to investigate how the Pearson correlation relates to Spearman’s rank correlation coefficient.
To look into such questions, one DGP we might entertain is a bivariate Poisson model, which is a distribution for a pair of counts, <span class="math inline">\(C_1,C_2\)</span>, where each count follows a Poisson distribution and where the pair of counts may be correlated.
We will denote the expected values of the counts as <span class="math inline">\(\mu_1\)</span> and <span class="math inline">\(\mu_2\)</span> and the Pearson correlation between the counts as <span class="math inline">\(\rho\)</span>.</p>
<p>To simulate a dataset based on this model, we would first need to choose how many observations to generate. Call this sample size <span class="math inline">\(N\)</span>.
One way to generate data following a bivariate Poisson model is to generate <em>three</em> independent Poisson random variables for each of the <span class="math inline">\(N\)</span> observations:
<span class="math display">\[
\begin{aligned}
Z_0 &amp;\sim Pois\left( \rho \sqrt{\mu_1 \mu_2}\right) \\
Z_1 &amp;\sim Pois\left(\mu_1 - \rho \sqrt{\mu_1 \mu_2}\right) \\
Z_2 &amp;\sim Pois\left(\mu_2 - \rho \sqrt{\mu_1 \mu_2}\right)
\end{aligned}
\]</span>
and then combine the pieces to create two dependent observations:
<span class="math display">\[
\begin{aligned}
C_1 &amp;= Z_0 + Z_1 \\
C_2 &amp;= Z_0 + Z_2.
\end{aligned}
\]</span>
An interesting feature of this model is that the range of possible correlations is constrained: only positive correlations are possible and, because each of the independent pieces must have a non-negative mean, the maximum possible correlation is <span class="math inline">\(\sqrt{\frac{\min\{\mu_1,\mu_2\}}{\max\{\mu_1,\mu_2\}}}\)</span>.</p>
</div>
<div id="CRT-example" class="section level3 hasAnchor" number="6.1.3">
<h3 class="hasAnchor"><span class="header-section-number">6.1.3</span> Example 3: Hierarchical linear model for a cluster-randomized trial<a href="#CRT-example" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Cluster-randomized trials are randomized experiments where the unit of randomization is a <em>group</em> of individuals, rather than the individuals themselves.
For example, suppose we have a collection of schools and the students within them.
A cluster-randomized trial involves randomizing the <em>schools</em> into treatment or control conditions and then measuring an outcome such as academic performance on the multiple students within the schools.
Typically, researchers will be interested in the extent to which average outcomes differ across schools assigned to different conditions, which captures the impact of the treatment relative to the control condition.
We will index the schools using <span class="math inline">\(j = 1,...,J\)</span> and let <span class="math inline">\(n_j\)</span> denote the number of students observed in school <span class="math inline">\(j\)</span>.
Say that <span class="math inline">\(Y_{ij}\)</span> is the outcome measure for student <span class="math inline">\(i\)</span> in school <span class="math inline">\(j\)</span>, for <span class="math inline">\(1 = 1,...,n_j\)</span> and <span class="math inline">\(j = 1,...,J\)</span>, and let <span class="math inline">\(Z_j\)</span> be an indicator equal to 1 if school <span class="math inline">\(j\)</span> is assigned to the treatment condition and otherwise equal to 0.</p>
<p>A widely used approach for estimating impacts from cluster-randomized trials is heirarchical linear modeling (HLM).
One way to write an HLM is in two parts.
First, we consider a regression model that describes the distribution of the outcomes across students within school <span class="math inline">\(j\)</span>:
<span class="math display">\[
Y_{ij} = \beta_{0j} + \epsilon_{ij}, \qquad \epsilon_{ij} \sim N(0, \sigma_{\epsilon}^2),
\]</span>
where <span class="math inline">\(\beta_{0j}\)</span> is the average outcome across students in school <span class="math inline">\(j\)</span>.
Second, we allow that the school-level average outcomes differ by a treatment effect <span class="math inline">\(\gamma_{1}\)</span> and that, for schools within each condition, the average outcomes follow a normal distribution with variance <span class="math inline">\(\sigma_u^2\)</span>.
We can write these relationships as a regression equation for the school-specific average outcome:
<span class="math display">\[
\beta_{0j} = \gamma_{0} + \gamma_{10} Z_j + u_{0j}, \quad u_{0j} \sim N(0, \tau^2),
\]</span>
where <span class="math inline">\(\gamma_{0}\)</span> is the average outcome among schools in the control condition.</p>
<p>If we only consider the first stage of this model, it looks a bit like the one-way ANOVA model from the previous example:
in both cases, we have multiple observations from each of several groups.<br />
The main distinction is that the ANOVA model treats the <span class="math inline">\(G\)</span> groups as a fixed set, whereas the HLM treats the set of <span class="math inline">\(J\)</span> schools as sampled from a larger population of schools and includes a regression model describing the variation in the school-level average outcomes.</p>
</div>
</div>
<div id="components-of-a-dgp" class="section level2 hasAnchor" number="6.2">
<h2 class="hasAnchor"><span class="header-section-number">6.2</span> Components of a DGP<a href="#components-of-a-dgp" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>A DGP involves a statistical model with parameters and random variables, but it also often includes further details as well, beyond those that we would consider to be part of the model as we would use it for analyzing real data.
In statistical analysis of real data, we often use models that describe only <em>part</em> of the distribution of the data, rather than its full, multivariate distribution.
For instance, when conducting a regression analysis, we are analyzing the distribution of an outcome or response variable, conditional on a set of predictor variables.
In other words, we take the predictor variables as <em>given</em> or <em>fixed</em>, rather than modeling their distribution.
When using an item response theory (IRT) model, we use responses to a set of items to estimate individual ability levels, given the set of items on the test.
We do not (usually) model the items themselves.
In contrast, if we are going to <em>generate</em> data for simulating a regression model or IRT model, we need to specify distributions for these additional features (the predictors in a regression model, the items in an IRT model); we can no longer just take them as given.</p>
<p>In designing and discussing DGPs, it is helpful to draw distinctions between the components of the focal statistical model and the remaining components of the DGP that are taken as given when analyzing real data. A first relevant distinction is between structural features, covariates, and outcomes (or more generally, endogenous quantities):</p>
<ul>
<li><strong>Structural features</strong> are quantities, such as the per-group sample sizes in the one-way ANOVA example, that describe the structure of a dataset but do not enter directly into the focal statistical model.
When analyzing real data, we usually take the structural features as they come, but when simulating data, we will need to make choices about the structural features.
For instance, in the HLM example involving students nested within schools, the number of students in each school is a structural feature.
To simulate data based on HLM, we will need to make choices about the number of schools and the distribution of the number of students in each school (e.g., we might specify that school sizes are uniformly distributed between specified minimum and maximum sizes), even though we do not have to consider these quantities when estimating a hierarchical model on real data.</li>
<li><strong>Covariates</strong> are variables in a dataset that we typically take as given when analyzing real data.
For instance, in the one-way ANOVA example, the group assignments of each observation is a covariate.
In the HLM example, covariates would include the treatment indicators <span class="math inline">\(Z_1,...,Z_J\)</span>. In a more elaborate version of the HLM, they might also include variables such as student demographic information, measures of past academic performance, or school-level characteristics such as the school’s geographic region or treatment assignment.
When analyzing real data, we condition on these quantities, but when specifying a DGP, we will need to make choices about how they are distributed (e.g., we might specify that students’ past academic performance is normally distributed).</li>
<li><strong>Outcomes and endogenous quantities</strong> are the variables whose distribution is described by the focal statistical model.
In the one-way ANOVA example, the outcome variable consists of the measurements <span class="math inline">\(X_{ig}\)</span> for <span class="math inline">\(i = 1,...,n_g\)</span> and <span class="math inline">\(g = 1,...,G\)</span>.
In the bivariate Poisson model, the outcomes consist of the component variables <span class="math inline">\(Z_1,Z_2,Z_3\)</span> and the observed counts <span class="math inline">\(C_1,C_2\)</span> because all of these quantities follow distributions that are specified as part of the focal model.
The focal statistical model specifies the distribution of these variables, and we will be interested in estimating the parameters controlling their distribution.</li>
</ul>
<p>Note that the focal statistical model only determines this third component of the DGP. The focal model consists of the equations describing what we would aim to estimate when analyzing real data.
In contrast, the full statistical model also includes additional elements specify how to generate the structural features and covariates—the pieces that are taken as given when analyzing real data.
Table @ref(tab:real-vs-sim) contrasts the role of structural features, covariates, and outcomes in real data analysis versus in simulations.</p>
<table style="width:100%;">
<caption>(#tab:real-vs-sim) Real Data Analysis versus Simulation</caption>
<colgroup>
<col width="15%" />
<col width="42%" />
<col width="42%" />
</colgroup>
<thead>
<tr class="header">
<th>Component</th>
<th>Real world</th>
<th>Simulation world</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Structural features</td>
<td>We obtain data of a given sample size, sizes of clusters, etc.</td>
<td>We specify sample sizes, we specify how to generate cluster sizes</td>
</tr>
<tr class="even">
<td>Covariates</td>
<td>Data come with covariates</td>
<td>We specify how to generate covariates</td>
</tr>
<tr class="odd">
<td>Outcomes</td>
<td>Data come with outcome variables</td>
<td>We generate outcome data based on a focal model</td>
</tr>
<tr class="even">
<td>Parameter estimation</td>
<td>We estimate a statistical model to learn about the unknown parameters</td>
<td>We estimate a statistical model and compare the results to the true parameters</td>
</tr>
</tbody>
</table>
<p>For a given DGP, the full statistical model might involve distributions for structural features, distributions for covariates, and distributions for outcomes given the covariates.
Each of these distributions will involve parameters that control the properties of the distribution (such as the average and degree of variation in a variable).
We think of these parameters as falling into one of three categories: focal, auxiliary, or design.</p>
<ul>
<li><p><strong>Focal</strong> parameters are the quantities that we care about and seek to estimate in real data analysis.
These are typically parts of the focal statistical model, such as the population means <span class="math inline">\(\mu_1,...,\mu_G\)</span> in the one-way ANOVA model, the correlation between counts <span class="math inline">\(\rho\)</span> in the bivariate Poisson model, or the treatment effect <span class="math inline">\(\gamma_{1}\)</span> in the HLM example.</p></li>
<li><p><strong>Auxiliary</strong> parameters are the other quantities that go into the focal statistical model or some other part of the DGP, which we might not be substantively interested in when analyzing real data but which nonetheless affect the analysis.
For instance, in the one-way ANOVA model, we would consider the population variances <span class="math inline">\(\sigma_1^2,...,\sigma_G^2\)</span> to be auxiliary if we are not interested in investigating how they vary from group to group.
In the bivariate Poisson model we might consider the average counts <span class="math inline">\(\mu_1\)</span> and <span class="math inline">\(\mu_2\)</span> to be auxiliary parameters.</p></li>
<li><p><strong>Design</strong> parameters are the quantities that control how we generate structural features of the data.
For instance, in a cluster-randomized trial, the fraction of schools assigned to treatment is a design parameter that can be directly controlled by the researchers.
Additional design parameters might include the minimum and maximum number of students per school.
Typically, in a real data analysis, we would not directly estimate such parameters because we take the distribution of structural features as given.</p></li>
</ul>
<p>It is evident from this discussion that DGPs can involve <em>many</em> moving parts.
One of the central challenges in specifying DGPs is that the performance of estimation methods will generally be affected by the <em>full</em> statistical model—including the design parameters and distribution of structural features and covariates—even though they are not part of the focal model.</p>
</div>
<div id="DGP-functions" class="section level2 hasAnchor" number="6.3">
<h2 class="hasAnchor"><span class="header-section-number">6.3</span> A statistical model is a recipe for data generation<a href="#DGP-functions" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Once we have decided on a full statistical model and written it down in mathematical terms, we need to translate it into code.
A function that implements a data-generating model should have the following form:</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb123-1"><a href="#cb123-1" tabindex="-1"></a>generate_data <span class="ot">&lt;-</span> <span class="cf">function</span>( </span>
<span id="cb123-2"><a href="#cb123-2" tabindex="-1"></a>  focal_parameters, auxiliary_parameters, design_parameters</span>
<span id="cb123-3"><a href="#cb123-3" tabindex="-1"></a>) {</span>
<span id="cb123-4"><a href="#cb123-4" tabindex="-1"></a>  </span>
<span id="cb123-5"><a href="#cb123-5" tabindex="-1"></a>  <span class="co"># generate pseudo-random numbers and use those to make some data</span></span>
<span id="cb123-6"><a href="#cb123-6" tabindex="-1"></a>  </span>
<span id="cb123-7"><a href="#cb123-7" tabindex="-1"></a>  <span class="fu">return</span>(sim_data)</span>
<span id="cb123-8"><a href="#cb123-8" tabindex="-1"></a>}</span></code></pre></div>
<p>The function takes a set of parameter values as input, simulates random numbers and does calculations, and produces as output a set of simulated data.
Typically, the inputs will consist of multiple parameters, and these will include not only the focal model parameters, but also the auxiliary parameters, sample sizes, and other design parameters.
The output will typically be a dataset, mimicking what one would see in an analysis of real data.
In some cases, the output data might be augmented with some other latent quantities (normally unobserved in the real world) that can be used later to assess whether an estimation procedure produces results that are close to the truth.</p>
<p>We have already seen an example of a complete DGP function in the case study on one-way ANOVA (see Section @ref(case-anova-DGP)).
In this case study, we developed the following function to generate data for a single outcome from a set of <span class="math inline">\(G\)</span> groups:</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb124-1"><a href="#cb124-1" tabindex="-1"></a>generate_ANOVA_data <span class="ot">&lt;-</span> <span class="cf">function</span>(mu, sigma_sq, sample_size) {</span>
<span id="cb124-2"><a href="#cb124-2" tabindex="-1"></a>  </span>
<span id="cb124-3"><a href="#cb124-3" tabindex="-1"></a>  N <span class="ot">&lt;-</span> <span class="fu">sum</span>(sample_size)</span>
<span id="cb124-4"><a href="#cb124-4" tabindex="-1"></a>  G <span class="ot">&lt;-</span> <span class="fu">length</span>(sample_size)</span>
<span id="cb124-5"><a href="#cb124-5" tabindex="-1"></a>  </span>
<span id="cb124-6"><a href="#cb124-6" tabindex="-1"></a>  group <span class="ot">&lt;-</span> <span class="fu">factor</span>(<span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span>G, <span class="at">times =</span> sample_size))</span>
<span id="cb124-7"><a href="#cb124-7" tabindex="-1"></a>  mu_long <span class="ot">&lt;-</span> <span class="fu">rep</span>(mu, <span class="at">times =</span> sample_size)</span>
<span id="cb124-8"><a href="#cb124-8" tabindex="-1"></a>  sigma_long <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="fu">sqrt</span>(sigma_sq), <span class="at">times =</span> sample_size)</span>
<span id="cb124-9"><a href="#cb124-9" tabindex="-1"></a>  </span>
<span id="cb124-10"><a href="#cb124-10" tabindex="-1"></a>  x <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(N, <span class="at">mean =</span> mu_long, <span class="at">sd =</span> sigma_long)</span>
<span id="cb124-11"><a href="#cb124-11" tabindex="-1"></a>  sim_data <span class="ot">&lt;-</span> <span class="fu">tibble</span>(<span class="at">group =</span> group, <span class="at">x =</span> x)</span>
<span id="cb124-12"><a href="#cb124-12" tabindex="-1"></a>  </span>
<span id="cb124-13"><a href="#cb124-13" tabindex="-1"></a>  <span class="fu">return</span>(sim_data)</span>
<span id="cb124-14"><a href="#cb124-14" tabindex="-1"></a>}</span></code></pre></div>
<p>This function takes both the focal model parameters (<code>mu</code>, <code>sigma_sq</code>) and other design parameters that one might not think of as parameters per-se (<code>sample_size</code>).
When simulating, we have to specify quantities that we take for granted when analyzing real data.</p>
<p>How would we write a DGP function for the bivariate Poisson model? The equations in Section @ref(DGP-examples) give us the recipe, so it just a matter of re-expressing them in code.
For this model, the only design parameter is the sample size, <span class="math inline">\(N\)</span>;
the sole focal parameter is the correlation between the variates, <span class="math inline">\(\rho\)</span>; and
the auxiliary parameters are the expected counts <span class="math inline">\(\mu_1\)</span> and <span class="math inline">\(\mu_2\)</span>.
Our function should have all four of these quantities as inputs and should produce as output a dataset with two variables, <span class="math inline">\(C_1\)</span> and <span class="math inline">\(C_2\)</span>.
Here is one way to implement the model:</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb125-1"><a href="#cb125-1" tabindex="-1"></a>r_bivariate_Poisson <span class="ot">&lt;-</span> <span class="cf">function</span>(N, rho, mu1, mu2) {</span>
<span id="cb125-2"><a href="#cb125-2" tabindex="-1"></a>  </span>
<span id="cb125-3"><a href="#cb125-3" tabindex="-1"></a>  <span class="co"># covariance term, equal to E(Z_3)</span></span>
<span id="cb125-4"><a href="#cb125-4" tabindex="-1"></a>  EZ3 <span class="ot">&lt;-</span> rho <span class="sc">*</span> <span class="fu">sqrt</span>(mu1 <span class="sc">*</span> mu2) </span>
<span id="cb125-5"><a href="#cb125-5" tabindex="-1"></a>  </span>
<span id="cb125-6"><a href="#cb125-6" tabindex="-1"></a>  <span class="co"># Generate independent components</span></span>
<span id="cb125-7"><a href="#cb125-7" tabindex="-1"></a>  Z1 <span class="ot">&lt;-</span> <span class="fu">rpois</span>(N, <span class="at">lambda =</span> mu1 <span class="sc">-</span> EZ3)</span>
<span id="cb125-8"><a href="#cb125-8" tabindex="-1"></a>  Z2 <span class="ot">&lt;-</span> <span class="fu">rpois</span>(N, <span class="at">lambda =</span> mu2 <span class="sc">-</span> EZ3)</span>
<span id="cb125-9"><a href="#cb125-9" tabindex="-1"></a>  Z3 <span class="ot">&lt;-</span> <span class="fu">rpois</span>(N, <span class="at">lambda =</span> EZ3)</span>
<span id="cb125-10"><a href="#cb125-10" tabindex="-1"></a>  </span>
<span id="cb125-11"><a href="#cb125-11" tabindex="-1"></a>  <span class="co"># Assemble components</span></span>
<span id="cb125-12"><a href="#cb125-12" tabindex="-1"></a>  dat <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb125-13"><a href="#cb125-13" tabindex="-1"></a>    <span class="at">C1 =</span> Z1 <span class="sc">+</span> Z3,</span>
<span id="cb125-14"><a href="#cb125-14" tabindex="-1"></a>    <span class="at">C2 =</span> Z2 <span class="sc">+</span> Z3</span>
<span id="cb125-15"><a href="#cb125-15" tabindex="-1"></a>  )</span>
<span id="cb125-16"><a href="#cb125-16" tabindex="-1"></a>  </span>
<span id="cb125-17"><a href="#cb125-17" tabindex="-1"></a>  <span class="fu">return</span>(dat)</span>
<span id="cb125-18"><a href="#cb125-18" tabindex="-1"></a>}</span></code></pre></div>
<p>Here we generate 5 observations from the bivariate Poisson with <span class="math inline">\(\rho = 0.5\)</span> and <span class="math inline">\(\mu_1 = \mu_2 = 4\)</span>:</p>
<div class="sourceCode" id="cb126"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb126-1"><a href="#cb126-1" tabindex="-1"></a><span class="fu">r_bivariate_Poisson</span>(<span class="dv">5</span>, <span class="at">rho =</span> <span class="fl">0.5</span>, <span class="at">mu1 =</span> <span class="dv">4</span>, <span class="at">mu2 =</span> <span class="dv">4</span>)</span></code></pre></div>
<pre><code>##   C1 C2
## 1  4  4
## 2  2  2
## 3  2  1
## 4  5  6
## 5  2  3</code></pre>
</div>
<div id="DGP-plotting" class="section level2 hasAnchor" number="6.4">
<h2 class="hasAnchor"><span class="header-section-number">6.4</span> Plot the artificial data<a href="#DGP-plotting" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>The whole purpose of writing a DGP is to produce something that can be treated just as if it were real data.
Considering that is our goal, we should act like it and engage in data analysis processes that we would apply whenever we analyze real data.
In particular, it is worthwhile to create one or more plots of the data generated by a DGP, just as we would if we were exploring a new real dataset for the first time.
This exercise can be very helpful for catching problems in the DGP function (about which more below).
Beyond just debugging, constructing graphic visualizations can be a very effective way to <em>study</em> a model and strengthen your understanding of how to interpret its parameters.</p>
In the one-way ANOVA example, it would be conventional to visualize the data with box plots or some other summary statistics for the data from each group.
For exploratory graphics, we prefer plots that include representations of the raw data points, not just summary statistics.
The figure below uses a density ridge-plot, filled in with points for each observation in each group.
The plot is based on a simulated dataset with 50 observations in each of five groups.
<div class="figure" style="text-align: center">
<img src="Designing-Simulations-in-R_files/figure-html/ANOVA-bee-swarm-1.png" alt="Densities of five heteroskedastic groups for the one-way ANOVA example." width="75%" />
<p class="caption">
(#fig:ANOVA-bee-swarm)Densities of five heteroskedastic groups for the one-way ANOVA example.
</p>
</div>
<p>Here is a plot of 30 observations from the bivariate Poisson distribution with means <span class="math inline">\(\mu_1 = 10, \mu_2 = 7\)</span> and correlation <span class="math inline">\(\rho = .65\)</span> (points are jittered slightly to avoid over-plotting):</p>
<div class="figure" style="text-align: center">
<img src="Designing-Simulations-in-R_files/figure-html/bivariate-Poisson-scatter-1.png" alt="$N = 30$ observations from the bivariate Poisson distribution with $\mu_1 = 10, \mu_2 = 7, ho = .65$." width="75%" />
<p class="caption">
(#fig:bivariate-Poisson-scatter)<span class="math inline">\(N = 30\)</span> observations from the bivariate Poisson distribution with <span class="math inline">\(\mu_1 = 10, \mu_2 = 7, ho = .65\)</span>.
</p>
</div>
<p>Plots like these are useful for building intuitions about a model. For instance, we can inspect @ref(fig:bivariate-Poisson-scatter) to get a sense of the order of magnitude and range of the observations, as well as the likelihood of obtaining multiple observations with identical counts.
Depending on the analysis procedures we will apply to the dataset, we might even create plots of transformations of the dataset, such as a histogram of the differences <span class="math inline">\(C_2 - C_1\)</span> or a scatterplot of the rank transformations of <span class="math inline">\(C_1\)</span> and <span class="math inline">\(C_2\)</span>.</p>
</div>
<div id="check-the-data-generating-function" class="section level2 hasAnchor" number="6.5">
<h2 class="hasAnchor"><span class="header-section-number">6.5</span> Check the data-generating function<a href="#check-the-data-generating-function" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>An important part of programming in R—especially when writing custom functions—is finding ways to test and check the correctness of your code. Just writing a data-generating function is not enough. It is also <em>critical</em> to test whether the output it produces is correct. How best to do this will depend on the particulars of the DGP being implemented.</p>
<p>For many DGPs, a broadly useful strategy is to generate a very large sample of data—one so large that the sample distribution should very closely resemble the population distribution.
One can then test whether features of the sample distribution closely align with corresponding parameters of the population model.</p>
<p>For the heteroskedastic ANOVA problem, one basic thing we can do is check that the simulated data from each group follows a normal distribution.
In the following code, we simulate very large samples from each of the four groups, and check that the means and variances agree with the input parameters:</p>
<div class="sourceCode" id="cb128"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb128-1"><a href="#cb128-1" tabindex="-1"></a>mu <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">6</span>)</span>
<span id="cb128-2"><a href="#cb128-2" tabindex="-1"></a>sigma_sq <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">1</span>)</span>
<span id="cb128-3"><a href="#cb128-3" tabindex="-1"></a></span>
<span id="cb128-4"><a href="#cb128-4" tabindex="-1"></a>check_data <span class="ot">&lt;-</span> <span class="fu">generate_ANOVA_data</span>( </span>
<span id="cb128-5"><a href="#cb128-5" tabindex="-1"></a>  <span class="at">mu =</span> mu, </span>
<span id="cb128-6"><a href="#cb128-6" tabindex="-1"></a>  <span class="at">sigma_sq =</span> sigma_sq,</span>
<span id="cb128-7"><a href="#cb128-7" tabindex="-1"></a>  <span class="at">sample_size =</span> <span class="fu">rep</span>(<span class="dv">10000</span>, <span class="dv">4</span>) </span>
<span id="cb128-8"><a href="#cb128-8" tabindex="-1"></a>)</span>
<span id="cb128-9"><a href="#cb128-9" tabindex="-1"></a></span>
<span id="cb128-10"><a href="#cb128-10" tabindex="-1"></a>chk <span class="ot">&lt;-</span> </span>
<span id="cb128-11"><a href="#cb128-11" tabindex="-1"></a>  check_data <span class="sc">%&gt;%</span> </span>
<span id="cb128-12"><a href="#cb128-12" tabindex="-1"></a>  <span class="fu">group_by</span>( group ) <span class="sc">%&gt;%</span></span>
<span id="cb128-13"><a href="#cb128-13" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">summarise</span>(</span>
<span id="cb128-14"><a href="#cb128-14" tabindex="-1"></a>    <span class="at">n =</span> <span class="fu">n</span>(),</span>
<span id="cb128-15"><a href="#cb128-15" tabindex="-1"></a>    <span class="at">mean =</span> <span class="fu">mean</span>(x),</span>
<span id="cb128-16"><a href="#cb128-16" tabindex="-1"></a>    <span class="at">var =</span> <span class="fu">var</span>(x)</span>
<span id="cb128-17"><a href="#cb128-17" tabindex="-1"></a>  ) <span class="sc">%&gt;%</span></span>
<span id="cb128-18"><a href="#cb128-18" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">mu =</span> mu, <span class="at">sigma2 =</span> sigma_sq) <span class="sc">%&gt;%</span> </span>
<span id="cb128-19"><a href="#cb128-19" tabindex="-1"></a>  <span class="fu">relocate</span>( group, n, mean, mu, var, sigma2 )</span>
<span id="cb128-20"><a href="#cb128-20" tabindex="-1"></a>chk</span></code></pre></div>
<pre><code>## # A tibble: 4 × 6
##   group     n  mean    mu   var sigma2
##   &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;
## 1 1     10000 0.988     1 2.97       3
## 2 2     10000 1.99      2 1.99       2
## 3 3     10000 5.02      5 5.00       5
## 4 4     10000 5.98      6 0.993      1</code></pre>
<p>It seems we are recovering our parameters.</p>
<p>We can also make some diagnostic plots to assess whether we have normal data (using QQ plots, where we expect a straight line if the data are normal):</p>
<div class="sourceCode" id="cb130"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb130-1"><a href="#cb130-1" tabindex="-1"></a><span class="fu">ggplot</span>( check_data ) <span class="sc">+</span></span>
<span id="cb130-2"><a href="#cb130-2" tabindex="-1"></a>  <span class="fu">aes</span>( <span class="at">sample =</span> x, <span class="at">color =</span> group ) <span class="sc">+</span> </span>
<span id="cb130-3"><a href="#cb130-3" tabindex="-1"></a>  <span class="fu">facet_wrap</span>( <span class="sc">~</span> group ) <span class="sc">+</span></span>
<span id="cb130-4"><a href="#cb130-4" tabindex="-1"></a>  <span class="fu">stat_qq</span>() <span class="sc">+</span> <span class="fu">stat_qq_line</span>()</span></code></pre></div>
<p><img src="Designing-Simulations-in-R_files/figure-html/unnamed-chunk-77-1.png" width="75%" style="display: block; margin: auto;" />
This diagnostic looks good too.
Here, these checks may seem a bit silly, but most bugs are silly—at least once you find them!
In models that are even a little bit more complex, it is quite easy for small things such as a sign error to slip into your code.
Even simple checks such as these can be quite helpful in catching such bugs.</p>
</div>
<div id="case-cluster" class="section level2 hasAnchor" number="6.6">
<h2 class="hasAnchor"><span class="header-section-number">6.6</span> Example: Simulating clustered data<a href="#case-cluster" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Writing code for a complicated DGP can feel like a daunting task, but if you first focus on a recipe for how the data is generated, it is often not too bad to then convert that recipe into code.
We now illustrate this process with a detailed case study involving a more complex data-generating process
Recent literature on multisite trials (where, for example, students are randomized to treatment or control within each of a series of sites) has explored how variation in the strength of effects across sites can affect how different data-analysis procedures behave <span class="citation">(e.g., <a href="#ref-miratrix2021applied">Miratrix, Weiss, and Henderson 2021</a>; <a href="#ref-Bloom:2016um">Bloom et al. 2016</a>)</span>.
In this example, we are going to extend this work to explore best practices for estimating treatment effects in cluster randomized trials.
In particular, we will investigate what happens when the treatment impact for each school is related to the size of the school.</p>
<div id="a-design-decision-what-do-we-want-to-manipulate" class="section level3 hasAnchor" number="6.6.1">
<h3 class="hasAnchor"><span class="header-section-number">6.6.1</span> A design decision: What do we want to manipulate?<a href="#a-design-decision-what-do-we-want-to-manipulate" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>In designing a simulation study, we need to find a DGP that will allow us to address the specific questions we are interested in investigating.
For instance, in the one-way ANOVA example, we wanted to see how different degrees of within-group variation impacted the performance of several hypothesis-testing procedures.
We therefore needed a data generation process that allowed us to control the extent of within-group variation.</p>
<p>To figure out what DGP to use for simulating data from a cluster-randomized trial, we need to consider how we are going to use those data in our simulation study.
Because we are interested in understanding what happens when school-specific effects are related to school size, we will need data with the following features:</p>
<ol style="list-style-type: lower-alpha">
<li>observations for students in each of several schools;</li>
<li>schools are different sizes and have different mean outcomes;</li>
<li>school-specific treatment effects correlate with school size; and</li>
<li>schools are assigned to different treatment conditions.</li>
</ol>
<p>A given dataset will consist of observations for individual students in schools, with each student having a school id, a treatment assignment (shared for all in the school), and an outcome.
A good starting point for building a DGP is to first sketch out what a simulated dataset should look like.
For this example, we need data like the following:</p>
<table>
<thead>
<tr class="header">
<th align="right">schoolID</th>
<th align="right">Z</th>
<th align="right">size</th>
<th align="right">studentID</th>
<th align="right">Y</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">1</td>
<td align="right">1</td>
<td align="right">24</td>
<td align="right">1</td>
<td align="right">3.6</td>
</tr>
<tr class="even">
<td align="right">1</td>
<td align="right">1</td>
<td align="right">24</td>
<td align="right">3</td>
<td align="right">1.0</td>
</tr>
<tr class="odd">
<td align="right">1</td>
<td align="right">etc</td>
<td align="right">etc</td>
<td align="right">etc</td>
<td align="right">etc</td>
</tr>
<tr class="even">
<td align="right">1</td>
<td align="right">1</td>
<td align="right">24</td>
<td align="right">24</td>
<td align="right">2.0</td>
</tr>
<tr class="odd">
<td align="right">2</td>
<td align="right">0</td>
<td align="right">32</td>
<td align="right">1</td>
<td align="right">0.5</td>
</tr>
<tr class="even">
<td align="right">2</td>
<td align="right">0</td>
<td align="right">32</td>
<td align="right">2</td>
<td align="right">1.5</td>
</tr>
<tr class="odd">
<td align="right">2</td>
<td align="right">0</td>
<td align="right">32</td>
<td align="right">3</td>
<td align="right">1.2</td>
</tr>
<tr class="even">
<td align="right">etc</td>
<td align="right">etc</td>
<td align="right">etc</td>
<td align="right">etc</td>
<td align="right">etc</td>
</tr>
</tbody>
</table>
<p>When running simulations, it is good practice to look at simple scenarios along with complex ones.
This lets us not only identify conditions where some aspect of the DGP is important, but also verify that the feature does <em>not</em> matter under scenarios where we know it should not.
Given this principle, we land on the following points:</p>
<ul>
<li>We need a DGP that lets us generate schools that are all the same size or that are all different sizes.</li>
<li>Our DGP should allow for variation in the school-specific treatment effects.</li>
<li>We should have the option to generate school-specific effects that are related or unrelated to school size.</li>
</ul>
</div>
<div id="a-model-for-a-cluster-rct" class="section level3 hasAnchor" number="6.6.2">
<h3 class="hasAnchor"><span class="header-section-number">6.6.2</span> A model for a cluster RCT<a href="#a-model-for-a-cluster-rct" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>DGPs are expressed and communicated using mathematical models.
In developing a DGP, we often start by considering the model for the outcomes (along with its focal parameters), which covers some but not all of the steps in the full recipe for generating data.
It is helpful to write down the equations for the outcome model and then note what further quantities need to be generated (such as structural features and covariates).
Then we can consider how to generate these quantities with auxiliary models.</p>
<p>Section @ref(CRT-example) introduced a basic HLM for a cluster-randomized trial.
This model had two parts, starting with a model for our student outcome:
<span class="math display">\[ Y_{ij} = \beta_{0j} + \epsilon_{ij} \mbox{ with } \epsilon_{ij} \sim N( 0, \sigma^2_\epsilon ) \]</span>
where <span class="math inline">\(Y_{ij}\)</span> is the outcome for student <span class="math inline">\(i\)</span> in site <span class="math inline">\(j\)</span>, <span class="math inline">\(\beta_{0j}\)</span> is the average outcome in site <span class="math inline">\(j\)</span>, and <span class="math inline">\(\epsilon_{ij}\)</span> is the residual error for student <span class="math inline">\(i\)</span> in site <span class="math inline">\(j\)</span>.
The model was completed by specifying how the site-specific outcomes vary as a function of treatment assignment:
<span class="math display">\[ \beta_{0j} = \gamma_{0} + \gamma_{1} Z_j + u_j, \quad u_j \sim N( 0, \sigma^2_u ).\]</span>
This model has a constant treatment effect: if a school is assigned to treatment, then all outcomes in the cluster are raised by the amount <span class="math inline">\(\gamma_{1}\)</span>.
But we also want to allow the size of impact to vary by school size.
This suggests we will need to elaborate the model to include a treatment-by-size interaction term.</p>
<p>One approach for allowing the school-specific impacts to depend on school size is to introduce school size as a predictor, as in
<span class="math display">\[
\beta_{0j} = \gamma_{0} + \gamma_{1} Z_j + \gamma_{2} \left(Z_j \times n_j\right) + u_j.
\]</span>
A drawback of this approach is that changing the average size of the schools will change the average treatment impact.
A more interpretable approach is to allow treatment effects to depend on the <em>relative</em> school sizes.
To do this, we can define a covariate that describes the deviation in the school size relative to the average size.
Thus, let
<span class="math display">\[ S_j = \frac{n_j - \bar{n}}{ \bar{n} }, \]</span>
where <span class="math inline">\(\bar{n}\)</span> is the overall average school size.
Using this covariate, we then revise our equation for our site <span class="math inline">\(j\)</span> to:
<span class="math display">\[ \beta_{0j} = \gamma_{0} + \gamma_{1} Z_j + \gamma_{2} \left( Z_j \times S_j\right) + u_j. \]</span>
If <span class="math inline">\(\gamma_{2}\)</span> is positive, then bigger schools will have larger treatment impacts.
Because <span class="math inline">\(S_j\)</span> is centered at 0, the overall average impact across schools will be simply <span class="math inline">\(\gamma_{1}\)</span>.
(If <span class="math inline">\(S_j\)</span> was not centered at zero, then the overall average impact would be some function of <span class="math inline">\(\gamma_{1}\)</span> and <span class="math inline">\(\gamma_{2}\)</span>.)</p>
<p>Putting all of the above together, we now have an HLM to describe the distribution of outcomes conditional on the covariates and structural features:
<span class="math display">\[
\begin{aligned}
Y_{ij} &amp;= \beta_{0j} + \epsilon_{ij} \quad &amp;\epsilon_{ij} &amp;\sim N( 0, \sigma^2_\epsilon ) \\
\beta_{0j} &amp;= \gamma_{0} + \gamma_{1} Z_j + \gamma_{2} Z_j S_j + u_j \quad &amp; u_j &amp;\sim N( 0, \sigma^2_u )
\end{aligned}
\]</span>
Substituting the second equation into the first leads to a single equation for generating the student-level outcomes (or what is called the reduced form of the HLM):
<span class="math display">\[ Y_{ij} = \gamma_{0} + \gamma_{1} Z_j + \gamma_{2} Z_j S_j  + u_j + \epsilon_{ij}\]</span>
The parameters of this focal model are the mean outcome among control schools (<span class="math inline">\(\gamma_{0}\)</span>), the average treatment impact (<span class="math inline">\(\gamma_{1}\)</span>), the site-size by treatment interaction term (<span class="math inline">\(\gamma_{2}\)</span>), the amount of school-level variation (<span class="math inline">\(\sigma^2_u\)</span>), and the amount of within-school variation (<span class="math inline">\(\sigma^2_\epsilon\)</span>).</p>
<p>There are several ways that we could elaborate this model further.
For one, we might want to include a main effect for <span class="math inline">\(S_j\)</span>, so that average outcomes in the absence of treatment are also dependent on school size.
For another, we might revise the model to allow for school-to-school variation in treatment impacts that is not explained by school size.
For simplicity, we do not build in these further features, but see the exercises at the end of the chapter.</p>
<p>So far we have a mathematical model analogous to what we would write if we were <em>analyzing</em> the data.
To <em>generate</em> data, we also need a way to generate the structural features and covariates involved in the model.
First, we need to know the number of clusters (<span class="math inline">\(J\)</span>) and the sizes of the clusters (<span class="math inline">\(n_j\)</span>, for <span class="math inline">\(j = 1, ..., J\)</span>).
For illustrative purposes, we will generate size sizes from a uniform distribution with average school size <span class="math inline">\(\bar{n}\)</span> and a fixed parameter <span class="math inline">\(\alpha\)</span> that controls the degree of variation in school size. Mathematically,
<span class="math display">\[ n_j \sim \text{Unif}\left[ (1-\alpha)\bar{n}, (1+\alpha)\bar{n} \right].\]</span>
Equivalently, we could generate site sizes by taking
<span class="math display">\[n_j = \bar{n}(1 + \alpha U_j), \quad U_j \sim unif(-1, 1).\]</span>
For instance, if <span class="math inline">\(\bar{n} = 100\)</span> and <span class="math inline">\(\alpha = 0.25\)</span> then schools would range in size from 75 to 125.
This specification is nice because it is simple, with just two parameters, both of which are easy to interpret: <span class="math inline">\(\bar{n}\)</span> is the average school size and <span class="math inline">\(\alpha\)</span> is the degree of variation in school size.</p>
<p>To round out the model, we also need to define how to generate the treatment indicator, <span class="math inline">\(Z_j\)</span>.
To allow for different treatment allocations, we will specify a proportion <span class="math inline">\(p\)</span> of clusters assigned to treatment.
Because we are simulating a cluster-randomized trial, we do this by drawing a simple random sample (without replacement) of <span class="math inline">\(p \times J\)</span> schools out of the total sample of <span class="math inline">\(J\)</span> schools, then setting <span class="math inline">\(Z_j = 1\)</span> for these schools and <span class="math inline">\(Z_j = 0\)</span> for the remaining schools.
We will denote this process as <span class="math inline">\(Z_1,...,Z_J \sim SRS(p, J)\)</span>, where SRS stands for simple random sample.</p>
<p>Now that we have an auxiliary model for school sizes, let us look again at our treatment impact heterogeneity term:
<span class="math display">\[ \gamma_{2} Z_j S_j = \gamma_{2} Z_j \left(\frac{n_j - \bar{n}}{\bar{n}}\right) = \gamma_{2}  \alpha Z_j U_j, \]</span>
where <span class="math inline">\(U_j \sim \text{Unif}(-1,1)\)</span> is the uniform variable used to generate <span class="math inline">\(n_j\)</span>.
Because we have standardized by average school size, the importance of the covariate does not change as a function of average school size, but rather as a function of the relative variation parameter <span class="math inline">\(\alpha\)</span>.
Setting up a DGP with standardized quantities will make it easier to interpret simulation results, especially if we are looking at results from multiple scenarios with different parameter values.
To the extent feasible, we want the parameters of the DGP to change only one feature of the data, so that it is easier to isolate the influence of each parameter.</p>
</div>
<div id="from-equations-to-code" class="section level3 hasAnchor" number="6.6.3">
<h3 class="hasAnchor"><span class="header-section-number">6.6.3</span> From equations to code<a href="#from-equations-to-code" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>When sketching out the equations for the DGP, we worked from the lowest level of the model (the students) to the higher level (schools) and then to the auxiliary models for covariates and structural features.
For writing code to based on the DGP, we will proceed in the opposite direction, from auxiliary to focal and from the highest level to the lowest.
First, we will generate the sites and their features:</p>
<ul>
<li>Generate school sizes</li>
<li>Generate school-level covariates</li>
<li>Generate school-level random effects</li>
</ul>
<p>Then we will generate the students inside the sites:</p>
<ul>
<li>Generate student residuals</li>
<li>Add everything up to generate student outcomes</li>
</ul>
<p>The mathematical model gives us the details we need to execute with each of these steps.</p>
<p>Here is the skeleton of a DGP function with arguments for each of the parameters we might want to control, including defaults for each (see @ref(default-arguments) for more on function defaults):</p>
<div class="sourceCode" id="cb131"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb131-1"><a href="#cb131-1" tabindex="-1"></a>gen_cluster_RCT <span class="ot">&lt;-</span> <span class="cf">function</span>(</span>
<span id="cb131-2"><a href="#cb131-2" tabindex="-1"></a>    <span class="at">J =</span> <span class="dv">30</span>,</span>
<span id="cb131-3"><a href="#cb131-3" tabindex="-1"></a>    <span class="at">n_bar =</span> <span class="dv">10</span>,</span>
<span id="cb131-4"><a href="#cb131-4" tabindex="-1"></a>    <span class="at">alpha =</span> <span class="dv">0</span>,</span>
<span id="cb131-5"><a href="#cb131-5" tabindex="-1"></a>    <span class="at">p =</span> <span class="fl">0.5</span>,</span>
<span id="cb131-6"><a href="#cb131-6" tabindex="-1"></a>    <span class="at">gamma_0 =</span> <span class="dv">0</span>, <span class="at">gamma_1 =</span> <span class="dv">0</span>, <span class="at">gamma_2 =</span> <span class="dv">0</span>,</span>
<span id="cb131-7"><a href="#cb131-7" tabindex="-1"></a>    <span class="at">sigma2_u =</span> <span class="dv">0</span>, <span class="at">sigma2_e =</span> <span class="dv">1</span></span>
<span id="cb131-8"><a href="#cb131-8" tabindex="-1"></a>) {</span>
<span id="cb131-9"><a href="#cb131-9" tabindex="-1"></a>  </span>
<span id="cb131-10"><a href="#cb131-10" tabindex="-1"></a>  <span class="co"># generate schools sizes </span></span>
<span id="cb131-11"><a href="#cb131-11" tabindex="-1"></a>  <span class="co"># Code (see below) goes here</span></span>
<span id="cb131-12"><a href="#cb131-12" tabindex="-1"></a>}</span></code></pre></div>
<p>Note that the inputs to this function are a mix of <em>model parameters</em> (<code>gamma_0</code>, <code>gamma_1</code>, <code>gamma_2</code>, representing coefficients in regressions), <em>auxilary parameters</em> (<code>sigma2_u</code>, <code>sigma2_e</code>, <code>alpha</code>, <code>n_bar</code>), and <em>design parameters</em> (<code>J</code>, <code>p</code>) that directly inform data generation.
We set default arguments (e.g., <code>gamma_0=0</code>) so that we can ignore aspects of the DGP that we do not care about for the moment.</p>
<p>Inside the model, we will have a block of code to generate the variables pertaining to schools, and then another to generate the variables pertaining to students.</p>
<p>We first make the schools:</p>
<div class="sourceCode" id="cb132"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb132-1"><a href="#cb132-1" tabindex="-1"></a>  n_min <span class="ot">&lt;-</span> <span class="fu">round</span>( n_bar <span class="sc">*</span> (<span class="dv">1</span> <span class="sc">-</span> alpha) )</span>
<span id="cb132-2"><a href="#cb132-2" tabindex="-1"></a>  n_max <span class="ot">&lt;-</span> <span class="fu">round</span>( n_bar <span class="sc">*</span> (<span class="dv">1</span> <span class="sc">+</span> alpha) )</span>
<span id="cb132-3"><a href="#cb132-3" tabindex="-1"></a>  nj <span class="ot">&lt;-</span> <span class="fu">sample</span>( n_min<span class="sc">:</span>n_max, J, <span class="at">replace =</span> <span class="cn">TRUE</span> )</span>
<span id="cb132-4"><a href="#cb132-4" tabindex="-1"></a>  </span>
<span id="cb132-5"><a href="#cb132-5" tabindex="-1"></a>  <span class="co"># Generate average control outcome for all schools</span></span>
<span id="cb132-6"><a href="#cb132-6" tabindex="-1"></a>  <span class="co"># (the random effects)</span></span>
<span id="cb132-7"><a href="#cb132-7" tabindex="-1"></a>  u0j <span class="ot">&lt;-</span> <span class="fu">rnorm</span>( J, <span class="at">mean =</span> <span class="dv">0</span>, <span class="at">sd =</span> <span class="fu">sqrt</span>(sigma2_u) )</span>
<span id="cb132-8"><a href="#cb132-8" tabindex="-1"></a>  </span>
<span id="cb132-9"><a href="#cb132-9" tabindex="-1"></a>  <span class="co"># randomize schools (proportion p to treatment)</span></span>
<span id="cb132-10"><a href="#cb132-10" tabindex="-1"></a>  Zj <span class="ot">&lt;-</span> <span class="fu">ifelse</span>( <span class="fu">sample</span>( <span class="dv">1</span><span class="sc">:</span>J ) <span class="sc">&lt;=</span> J <span class="sc">*</span> p, <span class="dv">1</span>, <span class="dv">0</span>)</span>
<span id="cb132-11"><a href="#cb132-11" tabindex="-1"></a>  </span>
<span id="cb132-12"><a href="#cb132-12" tabindex="-1"></a>  <span class="co"># Calculate schools intercepts</span></span>
<span id="cb132-13"><a href="#cb132-13" tabindex="-1"></a>  S_j <span class="ot">&lt;-</span> (nj <span class="sc">-</span> n_bar) <span class="sc">/</span> n_bar</span>
<span id="cb132-14"><a href="#cb132-14" tabindex="-1"></a>  beta_0j <span class="ot">&lt;-</span> gamma_0 <span class="sc">+</span> gamma_1 <span class="sc">*</span> Zj <span class="sc">+</span> gamma_2 <span class="sc">*</span> Zj <span class="sc">*</span> S_j <span class="sc">+</span> u0j</span></code></pre></div>
<p>The code is a literal translation of the math we did before.
Note the line with <code>sample(1:J) &lt;= J*p</code>; this is a simple trick to generate a 0/1 indicator for control and treatment conditions.</p>
<p>There is also a serious error in the above code (serious in that the code will run and look fine in many cases, but not always do what we want); we leave it as an exercise (see below) to find and fix it.
<!-- JEP: Does this exercise support our pedagogical goals? If this is supposed to be intro chapter, then debugging a subtle problem seems like it could be counterproductive. -->
<!-- LWM: I think we hand-hold the debugging clearly in the exercises, so I am not worried, and the larger point is important? --></p>
<p>Next, we use the site characteristics to generate the individual-level variables:</p>
<div class="sourceCode" id="cb133"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb133-1"><a href="#cb133-1" tabindex="-1"></a>  <span class="co"># Make individual site membership</span></span>
<span id="cb133-2"><a href="#cb133-2" tabindex="-1"></a>  sid <span class="ot">&lt;-</span> <span class="fu">as.factor</span>( <span class="fu">rep</span>( <span class="dv">1</span><span class="sc">:</span>J, nj ) )</span>
<span id="cb133-3"><a href="#cb133-3" tabindex="-1"></a>  </span>
<span id="cb133-4"><a href="#cb133-4" tabindex="-1"></a>  <span class="co"># Generate the individual-level errors and outcome</span></span>
<span id="cb133-5"><a href="#cb133-5" tabindex="-1"></a>  N <span class="ot">&lt;-</span> <span class="fu">sum</span>( nj )</span>
<span id="cb133-6"><a href="#cb133-6" tabindex="-1"></a>  e <span class="ot">&lt;-</span> <span class="fu">rnorm</span>( N, <span class="at">mean =</span> <span class="dv">0</span>, <span class="at">sd =</span> <span class="fu">sqrt</span>(sigma2_e) )</span>
<span id="cb133-7"><a href="#cb133-7" tabindex="-1"></a>  Y <span class="ot">&lt;-</span> beta_0j[sid] <span class="sc">+</span> e</span>
<span id="cb133-8"><a href="#cb133-8" tabindex="-1"></a>  </span>
<span id="cb133-9"><a href="#cb133-9" tabindex="-1"></a>  <span class="co"># Bundle into a dataset</span></span>
<span id="cb133-10"><a href="#cb133-10" tabindex="-1"></a>  dd <span class="ot">&lt;-</span> <span class="fu">data.frame</span>( </span>
<span id="cb133-11"><a href="#cb133-11" tabindex="-1"></a>    <span class="at">sid =</span> sid,</span>
<span id="cb133-12"><a href="#cb133-12" tabindex="-1"></a>    <span class="at">Z =</span> Zj[ sid ],</span>
<span id="cb133-13"><a href="#cb133-13" tabindex="-1"></a>    <span class="at">Yobs =</span> Y</span>
<span id="cb133-14"><a href="#cb133-14" tabindex="-1"></a>  )</span></code></pre></div>
<p>A key piece here is the <code>rep()</code> function that takes a list and repeats each element of the list a specified number of times.
In particular, <code>rep()</code> repeats each number (<span class="math inline">\(1, 2, \ldots, J\)</span>), the corresponding number of times as listed in <code>nj</code>.
Putting the code above into the function skeleton will produce a complete DGP function (view the <a href="/case_study_code/gen_cluster_RCT.R">complete function here</a>).
We can then call the function as so:</p>
<div class="sourceCode" id="cb134"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb134-1"><a href="#cb134-1" tabindex="-1"></a>dat <span class="ot">&lt;-</span> <span class="fu">gen_cluster_RCT</span>( </span>
<span id="cb134-2"><a href="#cb134-2" tabindex="-1"></a>  <span class="at">J=</span><span class="dv">3</span>, <span class="at">n_bar =</span> <span class="dv">5</span>, <span class="at">alpha =</span> <span class="fl">0.5</span>, <span class="at">p =</span> <span class="fl">0.5</span>, </span>
<span id="cb134-3"><a href="#cb134-3" tabindex="-1"></a>  <span class="at">gamma_0 =</span> <span class="dv">0</span>, <span class="at">gamma_1 =</span> <span class="fl">0.2</span>, <span class="at">gamma_2 =</span> <span class="fl">0.2</span>,</span>
<span id="cb134-4"><a href="#cb134-4" tabindex="-1"></a>  <span class="at">sigma2_u =</span> <span class="fl">0.4</span>, <span class="at">sigma2_e =</span> <span class="dv">1</span></span>
<span id="cb134-5"><a href="#cb134-5" tabindex="-1"></a>)</span>
<span id="cb134-6"><a href="#cb134-6" tabindex="-1"></a></span>
<span id="cb134-7"><a href="#cb134-7" tabindex="-1"></a>dat</span></code></pre></div>
<pre><code>##    sid Z       Yobs
## 1    1 1  2.3263686
## 2    1 1  2.0202277
## 3    1 1  3.5850632
## 4    1 1  0.9581332
## 5    1 1  2.6183761
## 6    1 1  0.3198559
## 7    2 0 -2.2305376
## 8    2 0  1.0479261
## 9    2 0 -0.6256389
## 10   2 0  1.0891353
## 11   2 0 -0.6051252
## 12   2 0 -0.3099363
## 13   2 0 -0.9828624
## 14   2 0 -0.5571326
## 15   3 0  0.1203995
## 16   3 0  1.7086978
## 17   3 0  0.1213685</code></pre>
<p>With this function, we can control the average size of the clusters (<code>n</code>), the number of clusters (<code>J</code>), the proportion treated (<code>p</code>), the average outcome in the control group (<code>gamma_0</code>), the average treatment effect (<code>gamma_1</code>), the site size by treatment interaction (<code>gamma_2</code>), the amount of cross site variation (<code>sigma2_u</code>), the residual variation (<code>sigma2_e</code>), and the amount of site size variation (<code>alpha</code>).
The next step is to test the code, making sure it is doing what we think it is.
In fact, it is not–there is a subtle bug that only appears under some specifications of the parameters; see the exercises for more on diagnosing and repairing this error.</p>
</div>
<div id="DGP-standardization" class="section level3 hasAnchor" number="6.6.4">
<h3 class="hasAnchor"><span class="header-section-number">6.6.4</span> Standardization in the DGP<a href="#DGP-standardization" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>One difficulty with the current implementation of the model is that the magnitude of the different parameters are inter-connected.
For instance, raising or lowering the within-school variance (<span class="math inline">\(\sigma^2_u\)</span>) will increase the overall variation in <span class="math inline">\(Y\)</span>, and therefore affect our the interpretation of the treatment effect parameters, because a given value of <span class="math inline">\(\gamma_{1}\)</span> will be less consequential if there is more overall variation.
We can fix this issue by standardizing the model parameters.
Standardization will allow us to reduce the set of parameters we might want to manipulate and will ensure that varying the remaining parameters only affects one aspect of the DGP.</p>
<p>For a continuous, normally distributed outcome variable, a common approach to scaling is to constrain the overall variance of the outcome to a fixed value, such as 1 or 100.
The magnitude of the other parameters of the model can then be interpreted relative to this scale.
Often, we can also constrain the mean of the outcome to a fixed value, such as setting <span class="math inline">\(\gamma_0 = 0\)</span> without affecting the interpretation of the other parameters.</p>
<p>With the current model, the variance of the outcome across students in the control condition is
<span class="math display">\[
\begin{aligned}
\text{Var}( Y_{ij} | Z_j = 0) &amp;= \text{Var}( \beta_{0j} + \epsilon_{ij} | Z_j = 0) \\
&amp;= \text{Var}( \gamma_{0} + \gamma_{1} Z_j + \gamma_{2} Z_j S_j + u_j + \epsilon_{ij} | Z_j = 0) \\
&amp;= \text{Var}( \gamma_{0} + u_j + \epsilon_{ij} ) \\
&amp;= \sigma^2_u + \sigma^2_\epsilon.
\end{aligned}
\]</span>
To ensure that the total variance is held constant, we can redefine the variance parameters in terms of the intra-class correlation (ICC).
The ICC is defined as
<span class="math display">\[ ICC = \frac{ \sigma^2_u }{ \sigma^2_u + \sigma^2_\epsilon }.\]</span>
The ICC measures the degree of between-group variation as a proportion of the total variation of the outcome.
It plays an important role in power calculations for cluster-randomized trials.
If we want the total variance of the outcome to be 1, we need to set <span class="math inline">\(\sigma^2_u + \sigma^2_{\epsilon} = 1\)</span>, which the implies that <span class="math inline">\(ICC = \sigma^2_u\)</span>, and <span class="math inline">\(\sigma^2_\epsilon = 1 - ICC\)</span>.
Thus, we can call our DGP function as follows:</p>
<div class="sourceCode" id="cb136"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb136-1"><a href="#cb136-1" tabindex="-1"></a>ICC <span class="ot">&lt;-</span> <span class="fl">0.3</span></span>
<span id="cb136-2"><a href="#cb136-2" tabindex="-1"></a>dat <span class="ot">&lt;-</span> <span class="fu">gen_cluster_RCT</span>( </span>
<span id="cb136-3"><a href="#cb136-3" tabindex="-1"></a>  <span class="at">J =</span> <span class="dv">30</span>, <span class="at">n_bar =</span> <span class="dv">20</span>, <span class="at">alpha =</span> <span class="fl">0.5</span>, <span class="at">p =</span> <span class="fl">0.5</span>,</span>
<span id="cb136-4"><a href="#cb136-4" tabindex="-1"></a>  <span class="at">gamma_0 =</span> <span class="dv">0</span>, <span class="at">gamma_1 =</span> <span class="fl">0.3</span>, <span class="at">gamma_2 =</span> <span class="fl">0.2</span>,</span>
<span id="cb136-5"><a href="#cb136-5" tabindex="-1"></a>  <span class="at">sigma2_u =</span> ICC, <span class="at">sigma2_e =</span> <span class="dv">1</span> <span class="sc">-</span> ICC</span>
<span id="cb136-6"><a href="#cb136-6" tabindex="-1"></a>)</span></code></pre></div>
<p>Manipulating the ICC rather than separately manipulating <span class="math inline">\(\sigma^2_u\)</span> and <span class="math inline">\(\sigma^2_\epsilon\)</span> will let us change the degree of between-group variation without affecting the overall scale of the outcome.</p>
<p>A further consequence of setting the overall scale of the outcome to 1 is that the parameters controlling the treatment impact can now be interpreted as standardized mean difference effect sizes.
The standardized mean difference for a treatment impact is defined as the average impact over the standard deviation of the outcome among control observations.<a href="#fn11" class="footnote-ref" id="fnref11"><sup>11</sup></a>
Letting <span class="math inline">\(\delta\)</span> denote the standardized mean difference parameter,
<span class="math display">\[ \delta = \frac{E(Y | Z_j = 1) - E(Y | Z_j = 0)}{SD( Y | Z_j = 0 )} = \frac{\gamma_1}{\sqrt{ \sigma^2_u + \sigma^2_\epsilon } } \]</span>
Because we have constrained the total variance, <span class="math inline">\(\gamma_1\)</span> is equivalent to <span class="math inline">\(\delta\)</span>. This equivalence holds for any value of <span class="math inline">\(\gamma_0\)</span>, so we do not have to worry about manipulating <span class="math inline">\(\gamma_0\)</span> in the simulations—we can simply leave it at its default value.</p>
<!-- JEP: Do we want to discuss anything about interpretation of gamma_2? Or add an exercise about it? -->
<!-- LWM: I don't think there is a need -->
</div>
</div>
<div id="three-parameter-IRT" class="section level2 hasAnchor" number="6.7">
<h2 class="hasAnchor"><span class="header-section-number">6.7</span> Sometimes a DGP is all you need<a href="#three-parameter-IRT" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>We have introduced the data-generating process as only the first step in developing a simulation study. Indeed, there are many more considerations to come, which we will describe in subsequent chapters.
However, this first step is still very useful in its own right, even apart from the other components of a simulation.
Sometimes, a data-generating function is all you need to learn about a statistical model.</p>
<p>Writing data-generating functions is a very effective way to <em>study</em> a statistical model, such as a model that you might be learning about in a course or through self-study.
Writing code based on a model is a much more <em>active</em> process than listening to a lecture or reading a book or paper.
Coding requires you to make the mathematical notation tangible and can help you to notice details of the model that might be easily missed through listening or reading alone.</p>
<p>Suppose we are taking a first course psychometrics and have just been introduced to item response theory (IRT) models for binary response items.
Our instructor has just laid out a bunch of notation:</p>
<ul>
<li>We have data from a sample of <span class="math inline">\(N\)</span> individuals, each of whom responds to a set of <span class="math inline">\(M\)</span> test items.</li>
<li>We let <span class="math inline">\(X_{im} = 1\)</span> if respondent <span class="math inline">\(i\)</span> answers item <span class="math inline">\(m\)</span> correctly, with <span class="math inline">\(X_{im} = 0\)</span> otherwise, for <span class="math inline">\(i = 1,...,N\)</span> and <span class="math inline">\(m = 1,...,M\)</span>.</li>
<li>We imagine that each respondent has a latent ability <span class="math inline">\(\theta_i\)</span> on whatever domain the test measures.</li>
</ul>
<p>Now our instructor starts dropping models on us, and puts up a slide showing the equation for a three-parameter IRT model:
<span class="math display">\[
Pr(X_{im} = 1) = \gamma_m + (1 - \gamma_m) g\left( \alpha_m [\theta_i - \beta_m]\right),
\]</span>
where <span class="math inline">\(g(x)\)</span> is the cumulative logistic curve: <span class="math inline">\(g(x) = e^x / (1 + e^x)\)</span>.
The instructor explains that <span class="math inline">\(\alpha_m\)</span> is discrimination parameter that can take any real value, <span class="math inline">\(\beta_m\)</span> is a difficulty parameter that has to be greater than zero, and <span class="math inline">\(\gamma_m\)</span> is a guessing parameter between 0 and 1.
They also explain that the guessing parameter is often hard to estimate and so might get treated as fixed and known, based on the number of response options on the item.
For instance, if all the items have four options, then we might take <span class="math inline">\(\gamma_m = \frac{1}{4}\)</span> for <span class="math inline">\(m = 1,...,M\)</span>.
Finally, they explain that the ability parameters are assumed to follow a standard normal distribution, so <span class="math inline">\(\theta_i \sim N(0, 1)\)</span> in the population.</p>
<p>What is this madness? It certainly is a lot of notation to follow.
To make sense of all the moving pieces, let’s try simulating from the model using more-or-less arbitrary parameters.
To begin, we will need to pick a test length <span class="math inline">\(M\)</span> and a sample size <span class="math inline">\(N\)</span>.
Let’s use <span class="math inline">\(N = 7\)</span> participants and <span class="math inline">\(M = 4\)</span> items for starters:</p>
<div class="sourceCode" id="cb137"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb137-1"><a href="#cb137-1" tabindex="-1"></a>N <span class="ot">&lt;-</span> <span class="dv">7</span></span>
<span id="cb137-2"><a href="#cb137-2" tabindex="-1"></a>M <span class="ot">&lt;-</span> <span class="dv">4</span></span></code></pre></div>
<p>The <span class="math inline">\(\theta_i\)</span> distribution seems like the next-simplest part of the model, so let’s generate some ability parameters:</p>
<div class="sourceCode" id="cb138"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb138-1"><a href="#cb138-1" tabindex="-1"></a>thetas <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(N)</span></code></pre></div>
<p>Now we need sets of parameters <span class="math inline">\(\alpha_m, \beta_m, \gamma_m\)</span> for every item <span class="math inline">\(m = 1,...,M\)</span>.
Where do we get these?</p>
<p>For a particular fixed-length test, the set of item parameters would depend on the features of the actual test questions.
But we are not (yet) dealing with actual testing data, so we will need to make up an auxiliary model for these parameters.
Perhaps we could just simulate some values?
Arbitrarily, let’s draw the difficulty parameters from a normal distribution with mean <span class="math inline">\(\mu_\alpha = 0\)</span> and standard deviation <span class="math inline">\(\tau_\alpha = 1\)</span>.
The discrimination parameters have to be greater than zero, and values near <span class="math inline">\(\beta_m = 1\)</span> make the model simplify (in other words, if <span class="math inline">\(\beta_1 = 1\)</span> then we can drop the parameter from the model), so let’s draw them from a gamma distribution with mean <span class="math inline">\(\mu_\beta = 1\)</span> and standard deviation <span class="math inline">\(\tau_\beta = 0.2\)</span>.
This decision requires a bit of work: gamma distributions are usually parameterized in terms of shape and rate, not mean and standard deviation.
A bit of poking on Wikipedia gives us the answer, however:
shape is equal to <span class="math inline">\(\mu_\beta^2 \tau_\beta^2 = 0.2^2\)</span> and rate is equal to <span class="math inline">\(\mu_\beta \tau_\beta^2 = 0.2^2\)</span>.
Finally, we imagine that all the test questions have four possible responses, and therefore set <span class="math inline">\(\gamma_m = \frac{1}{4}\)</span> for all the items, just like the instructor suggested.
Each item requires three numbers; the easiest way to generate them is to let them all be independent of each other, so we do that.
With that, let’s make up some item parameters:</p>
<div class="sourceCode" id="cb139"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb139-1"><a href="#cb139-1" tabindex="-1"></a>alphas <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(M, <span class="at">mean =</span> <span class="dv">0</span>, <span class="at">sd =</span> <span class="fl">1.5</span>)           <span class="co"># difficulty parameters</span></span>
<span id="cb139-2"><a href="#cb139-2" tabindex="-1"></a>betas <span class="ot">&lt;-</span> <span class="fu">rgamma</span>(M, <span class="at">shape =</span> <span class="fl">0.2</span><span class="sc">^</span><span class="dv">2</span>, <span class="at">rate =</span> <span class="fl">0.2</span><span class="sc">^</span><span class="dv">2</span>)  <span class="co"># discrimination parameters</span></span>
<span id="cb139-3"><a href="#cb139-3" tabindex="-1"></a>gammas <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="dv">1</span> <span class="sc">/</span> <span class="dv">4</span>, M)                          <span class="co"># guessing parameters</span></span></code></pre></div>
<p>A three-parameter IRT model describes the probability that a given respondent with ability <span class="math inline">\(\theta_i\)</span> answers each of the items on the test correctly.
To generate data based on the model, we need to produce scores on every item for every respondent, leading to a matrix of <span class="math inline">\(N\)</span> respondents by <span class="math inline">\(M\)</span> items.
To simplify this calculation, we write a function to compute the item probabilities for a single respondent:</p>
<div class="sourceCode" id="cb140"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb140-1"><a href="#cb140-1" tabindex="-1"></a>r_scores <span class="ot">&lt;-</span> <span class="cf">function</span>(theta_i, alphas, betas, gammas, M) {</span>
<span id="cb140-2"><a href="#cb140-2" tabindex="-1"></a>  pi_i <span class="ot">&lt;-</span> gammas <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">-</span> gammas) <span class="sc">*</span> <span class="fu">plogis</span>(alphas <span class="sc">*</span> (theta_i <span class="sc">-</span> betas))</span>
<span id="cb140-3"><a href="#cb140-3" tabindex="-1"></a>  scores <span class="ot">&lt;-</span> <span class="fu">rbinom</span>(M, <span class="at">size =</span> <span class="dv">1</span>, <span class="at">prob =</span> pi_i)</span>
<span id="cb140-4"><a href="#cb140-4" tabindex="-1"></a>  <span class="fu">names</span>(scores) <span class="ot">&lt;-</span> <span class="fu">paste0</span>(<span class="st">&quot;q&quot;</span>,<span class="dv">1</span><span class="sc">:</span>M)</span>
<span id="cb140-5"><a href="#cb140-5" tabindex="-1"></a>  <span class="fu">return</span>(scores)</span>
<span id="cb140-6"><a href="#cb140-6" tabindex="-1"></a>}</span>
<span id="cb140-7"><a href="#cb140-7" tabindex="-1"></a></span>
<span id="cb140-8"><a href="#cb140-8" tabindex="-1"></a><span class="fu">r_scores</span>(thetas[<span class="dv">1</span>], <span class="at">alphas =</span> alphas, <span class="at">betas =</span> betas, </span>
<span id="cb140-9"><a href="#cb140-9" tabindex="-1"></a>         <span class="at">gammas =</span> gammas, <span class="at">M =</span> M)</span></code></pre></div>
<pre><code>## q1 q2 q3 q4 
##  0  1  0  1</code></pre>
<p>The first line of the function calculates the probability of correctly answering all <span class="math inline">\(M\)</span> items, and stores the result in a vector <code>pi_i</code>.
In the next line, we simulate binary outcomes by flipping coins with the specified vector of probabilities.
Finally, we assign names to each item so that we can keep track of which score is for which item.
Now, using the <code>map()</code> function, we can run the function for every one of our respondents:</p>
<div class="sourceCode" id="cb142"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb142-1"><a href="#cb142-1" tabindex="-1"></a><span class="fu">map_dfr</span>(</span>
<span id="cb142-2"><a href="#cb142-2" tabindex="-1"></a>  thetas, <span class="at">.f =</span> r_scores, </span>
<span id="cb142-3"><a href="#cb142-3" tabindex="-1"></a>  <span class="at">alphas =</span> alphas, <span class="at">betas =</span> betas, <span class="at">gammas =</span> gammas, <span class="at">M =</span> M</span>
<span id="cb142-4"><a href="#cb142-4" tabindex="-1"></a>)</span></code></pre></div>
<pre><code>## # A tibble: 7 × 4
##      q1    q2    q3    q4
##   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;
## 1     0     0     1     0
## 2     1     1     0     0
## 3     1     0     0     0
## 4     1     1     1     1
## 5     0     0     0     1
## 6     1     0     1     1
## 7     0     1     0     0</code></pre>
<p>To make it easier to generate datasets with different characteristics, we bundle the above code chunks into a single data-generating function.
To do so, we have to decide what the input parameters should be.
We know we need to at least specify <span class="math inline">\(N\)</span> and <span class="math inline">\(M\)</span>.
We made assumptions about the item parameters, but we had to specify means and standard deviations for the difficulty and discrimination parameter distributions, so it is natural to allow those to be inputs also.
Our data-generating function will then be</p>
<div class="sourceCode" id="cb144"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb144-1"><a href="#cb144-1" tabindex="-1"></a>r_3PL_IRT <span class="ot">&lt;-</span> <span class="cf">function</span>(</span>
<span id="cb144-2"><a href="#cb144-2" tabindex="-1"></a>    N, <span class="at">M =</span> <span class="dv">4</span>,</span>
<span id="cb144-3"><a href="#cb144-3" tabindex="-1"></a>    <span class="at">diff_M =</span> <span class="dv">0</span>, <span class="at">diff_SD =</span> <span class="dv">1</span>,</span>
<span id="cb144-4"><a href="#cb144-4" tabindex="-1"></a>    <span class="at">disc_M =</span> <span class="dv">1</span>, <span class="at">disc_SD =</span> <span class="fl">0.2</span>,</span>
<span id="cb144-5"><a href="#cb144-5" tabindex="-1"></a>    <span class="at">item_options =</span> <span class="dv">4</span></span>
<span id="cb144-6"><a href="#cb144-6" tabindex="-1"></a>) {</span>
<span id="cb144-7"><a href="#cb144-7" tabindex="-1"></a>  <span class="co"># generate ability parameters</span></span>
<span id="cb144-8"><a href="#cb144-8" tabindex="-1"></a>  thetas <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(N)</span>
<span id="cb144-9"><a href="#cb144-9" tabindex="-1"></a>  </span>
<span id="cb144-10"><a href="#cb144-10" tabindex="-1"></a>  <span class="co"># generate item parameters</span></span>
<span id="cb144-11"><a href="#cb144-11" tabindex="-1"></a>  alphas <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(M, <span class="at">mean =</span> diff_M, <span class="at">sd =</span> diff_SD)</span>
<span id="cb144-12"><a href="#cb144-12" tabindex="-1"></a>  betas <span class="ot">&lt;-</span> <span class="fu">rgamma</span>(M, </span>
<span id="cb144-13"><a href="#cb144-13" tabindex="-1"></a>                  <span class="at">shape =</span> disc_M<span class="sc">^</span><span class="dv">2</span> <span class="sc">*</span> disc_SD<span class="sc">^</span><span class="dv">2</span>, </span>
<span id="cb144-14"><a href="#cb144-14" tabindex="-1"></a>                  <span class="at">rate =</span> disc_M <span class="sc">*</span> disc_SD<span class="sc">^</span><span class="dv">2</span>)</span>
<span id="cb144-15"><a href="#cb144-15" tabindex="-1"></a>  gammas <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="dv">1</span> <span class="sc">/</span> item_options, M)</span>
<span id="cb144-16"><a href="#cb144-16" tabindex="-1"></a></span>
<span id="cb144-17"><a href="#cb144-17" tabindex="-1"></a>  <span class="co"># simulate item responses</span></span>
<span id="cb144-18"><a href="#cb144-18" tabindex="-1"></a>  test_scores <span class="ot">&lt;-</span> <span class="fu">map_dfr</span>(</span>
<span id="cb144-19"><a href="#cb144-19" tabindex="-1"></a>   thetas, <span class="at">.f =</span> r_scores, </span>
<span id="cb144-20"><a href="#cb144-20" tabindex="-1"></a>    <span class="at">alphas =</span> alphas, <span class="at">betas =</span> betas, <span class="at">gammas =</span> gammas, <span class="at">M =</span> M</span>
<span id="cb144-21"><a href="#cb144-21" tabindex="-1"></a>  )</span>
<span id="cb144-22"><a href="#cb144-22" tabindex="-1"></a>  </span>
<span id="cb144-23"><a href="#cb144-23" tabindex="-1"></a>  <span class="co"># calculate total score</span></span>
<span id="cb144-24"><a href="#cb144-24" tabindex="-1"></a>  test_scores<span class="sc">$</span>total <span class="ot">&lt;-</span> <span class="fu">rowSums</span>(test_scores)</span>
<span id="cb144-25"><a href="#cb144-25" tabindex="-1"></a>  </span>
<span id="cb144-26"><a href="#cb144-26" tabindex="-1"></a>  <span class="fu">return</span>(test_scores)</span>
<span id="cb144-27"><a href="#cb144-27" tabindex="-1"></a>}</span>
<span id="cb144-28"><a href="#cb144-28" tabindex="-1"></a></span>
<span id="cb144-29"><a href="#cb144-29" tabindex="-1"></a><span class="fu">r_3PL_IRT</span>(<span class="at">N =</span> <span class="dv">7</span>, <span class="at">M =</span> <span class="dv">4</span>)</span></code></pre></div>
<pre><code>## # A tibble: 7 × 5
##      q1    q2    q3    q4 total
##   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;
## 1     1     1     0     0     2
## 2     1     1     1     1     4
## 3     1     1     1     0     3
## 4     1     1     1     1     4
## 5     1     1     1     0     3
## 6     1     1     1     1     4
## 7     1     1     1     1     4</code></pre>
<p>Now let’s look at a much larger sample of participants, with a longer test that includes <span class="math inline">\(M = 12\)</span> items:</p>
<div class="sourceCode" id="cb146"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb146-1"><a href="#cb146-1" tabindex="-1"></a>test_scores <span class="ot">&lt;-</span> <span class="fu">r_3PL_IRT</span>(<span class="at">N =</span> <span class="dv">10000</span>, <span class="at">M =</span> <span class="dv">12</span>)</span></code></pre></div>
<p>Having written a function for the 3-parameter logistic IRT model makes it easy to explore properties of the model.
For instance, we can easily visualize the distribution of the total scores on the test:</p>
<div class="sourceCode" id="cb147"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb147-1"><a href="#cb147-1" tabindex="-1"></a><span class="fu">ggplot</span>(test_scores, <span class="fu">aes</span>(total)) <span class="sc">+</span> </span>
<span id="cb147-2"><a href="#cb147-2" tabindex="-1"></a>  <span class="fu">geom_bar</span>() <span class="sc">+</span> </span>
<span id="cb147-3"><a href="#cb147-3" tabindex="-1"></a>  <span class="fu">scale_x_continuous</span>(<span class="at">limits =</span> <span class="fu">c</span>(<span class="dv">0</span>,<span class="fl">12.5</span>), <span class="at">breaks =</span> <span class="fu">seq</span>(<span class="dv">0</span>,<span class="dv">12</span>,<span class="dv">2</span>))</span></code></pre></div>
<p><img src="Designing-Simulations-in-R_files/figure-html/unnamed-chunk-91-1.png" width="75%" style="display: block; margin: auto;" /></p>
<p>Looking at item variation, we can examine the probability of correctly responding to each of the items by computing sample means for each item:</p>
<div class="sourceCode" id="cb148"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb148-1"><a href="#cb148-1" tabindex="-1"></a>test_scores <span class="sc">%&gt;%</span></span>
<span id="cb148-2"><a href="#cb148-2" tabindex="-1"></a>  <span class="fu">summarise</span>(<span class="fu">across</span>(<span class="fu">starts_with</span>(<span class="st">&quot;q&quot;</span>), mean))</span></code></pre></div>
<pre><code>## # A tibble: 1 × 12
##      q1    q2    q3    q4    q5    q6    q7    q8
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 0.628  0.62 0.629 0.256 0.539 0.620 0.624 0.620
## # ℹ 4 more variables: q9 &lt;dbl&gt;, q10 &lt;dbl&gt;,
## #   q11 &lt;dbl&gt;, q12 &lt;dbl&gt;</code></pre>
<p>The percentage of correct responses varies from 25.6% to 63.3.
What are the correlations between individual items and the total score?
Let’s check:</p>
<div class="sourceCode" id="cb150"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb150-1"><a href="#cb150-1" tabindex="-1"></a>test_scores <span class="sc">%&gt;%</span></span>
<span id="cb150-2"><a href="#cb150-2" tabindex="-1"></a>  <span class="fu">summarise</span>(<span class="fu">across</span>(<span class="fu">starts_with</span>(<span class="st">&quot;q&quot;</span>), <span class="sc">~</span> <span class="fu">cor</span>(.x, total)))</span></code></pre></div>
<pre><code>## # A tibble: 1 × 12
##      q1    q2     q3    q4    q5    q6    q7    q8
##   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 0.154 0.386 0.0195 0.227 0.445 0.411 0.386 0.421
## # ℹ 4 more variables: q9 &lt;dbl&gt;, q10 &lt;dbl&gt;,
## #   q11 &lt;dbl&gt;, q12 &lt;dbl&gt;</code></pre>
<p>Note that simulating a new dataset will produce different results for these summaries because generating each dataset entails sampling a new set of items (with different difficulty and discrimination).</p>
<p>Writing a DGP function makes it possible to study a model through exploration, simply by examining datasets generated by wiggling the model parameters up or down.
For instance, we could look at what happens to the distribution of total scores if the items covered a much broader range of difficulties (higher <span class="math inline">\(\tau_\alpha\)</span>) or are mis-calibrated to be too difficult (<span class="math inline">\(\mu_\tau &gt; 0\)</span>).
What if the items had varying numbers of response options, so the guessing parameters differ?
Are there item parameter values that will produce highly unrealistic distributions of total scores?
Exercises @ref(IRT-DGP-parameters), @ref(IRT-DGP-checking), and @ref(IRT-DGP-breaking) ask you to further explore these questions.</p>
<p>Overall, implementing the model as a data-generating function has allowed us to explore the model in a more active way than simply reading about it or listening to a lecture.
We have a more visceral feel about how the different parameters would create variation in our data—and it would be easy to tweak those parameters to see how things changed to learn even more.</p>
<!-- LWM: I like this example, but it would be great if we added some specific takeaways of what we are learning by these sorts of explorations. I had originally thought to look at how distribution of total score has changed as a function of student ability, but that would involve updating the DGP. To discuss. -->
</div>
<div id="more-to-explore" class="section level2 hasAnchor" number="6.8">
<h2 class="hasAnchor"><span class="header-section-number">6.8</span> More to explore<a href="#more-to-explore" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>This chapter has introduced the core components of a data-generating process and demonstrated how to move from formulating a full data-generating model to implementing the model in R code.
Our main aim has been to provide enough scaffolding for you to get started with simulating from and exploring a variety of models.
The exercises below will give you further practice in developing, testing, and extending DGP functions.
Of course, we have not covered every consideration and challenge that arises when writing DGPs for simulations—there is <em>much</em> more to explore!</p>
<p>We will cover some further challenges in subsequent chapters.
<!-- JEP: Links to specific further chapters? -->
<!-- LWM: TODO later when book is settled. -->
Yet more challenges will surely arise as you apply simulations in your own work.
Even though such challenges might not align with the examples or contexts that we have covered here, the concepts and principles that we have introduced should allow you to reason about potential solutions.
In doing so, we encourage you adopt the attitude of a chef in a test kitchen by trying out your ideas with code.
In the kitchen, there is often no way to know how a dish will turn out until you actually bake it and taste it.
Likewise, in developing a DGP, the best way to understand and evaluate a DGP is to write it out in code and explore the datasets that you can produce with it.</p>
</div>
<div id="exercises-3" class="section level2 hasAnchor" number="6.9">
<h2 class="hasAnchor"><span class="header-section-number">6.9</span> Exercises<a href="#exercises-3" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<div id="Welch-t-dgp" class="section level3 hasAnchor" number="6.9.1">
<h3 class="hasAnchor"><span class="header-section-number">6.9.1</span> The Welch test on a shifted-and-scaled <span class="math inline">\(t\)</span> distribution<a href="#Welch-t-dgp" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>The shifted-and-scaled <span class="math inline">\(t\)</span>-distribution has parameters <span class="math inline">\(\mu\)</span> (mean), <span class="math inline">\(\sigma\)</span> (scale), and <span class="math inline">\(\nu\)</span> (degrees of freedom).
If <span class="math inline">\(T\)</span> follows a student’s <span class="math inline">\(t\)</span>-distribution with <span class="math inline">\(\nu\)</span> degrees of freedom, then <span class="math inline">\(S = \mu + \sigma T\)</span> follows a shifted-and-scaled <span class="math inline">\(t\)</span>-distribution.</p>
<p>The following function will generate random draws from this distribution.
We additionally scale by <span class="math inline">\((\nu-2)/\nu\)</span> to achieve the target standard deviation (a <span class="math inline">\(t\)</span>-distribution has a variance of <span class="math inline">\(\nu/(\nu-2)\)</span>).</p>
<div class="sourceCode" id="cb152"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb152-1"><a href="#cb152-1" tabindex="-1"></a>r_tss <span class="ot">&lt;-</span> <span class="cf">function</span>(n, mean, sd, df) {</span>
<span id="cb152-2"><a href="#cb152-2" tabindex="-1"></a>  mean <span class="sc">+</span> sd <span class="sc">*</span> <span class="fu">sqrt</span>( (df<span class="dv">-2</span>)<span class="sc">/</span>df ) <span class="sc">*</span> <span class="fu">rt</span>(<span class="at">n =</span> n, <span class="at">df =</span> df)</span>
<span id="cb152-3"><a href="#cb152-3" tabindex="-1"></a>}</span>
<span id="cb152-4"><a href="#cb152-4" tabindex="-1"></a></span>
<span id="cb152-5"><a href="#cb152-5" tabindex="-1"></a><span class="fu">r_tss</span>(<span class="at">n =</span> <span class="dv">8</span>, <span class="at">mean =</span> <span class="dv">3</span>, <span class="at">sd =</span> <span class="dv">2</span>, <span class="at">df =</span> <span class="dv">5</span>)</span></code></pre></div>
<pre><code>## [1]  0.02822602  3.87035901  4.51376755
## [4]  3.02447410 -0.26265918  2.29642811
## [7]  1.16346358  7.59634125</code></pre>
<ol style="list-style-type: decimal">
<li><p>Modify the Welch simulation’s <code>simulate_data()</code> function to generate data from shifted-and-scaled <span class="math inline">\(t\)</span>-distributions rather than from normal distributions. Include the degrees of freedom as an input argument.
Simulate a dataset with low degrees of freedom and plot it to see if you see a few outliers.</p></li>
<li><p>Now generate more data and calculate the means and standard deviations to see if they are correctly calibrated (i.e., generate a big dataset to ensure you get reliable mean and standard deviation estimates). Check <code>df</code> equal to 500, 5, 3, and 2.</p></li>
<li><p>Once you are satisfied you have a correct DGP function, re-run the Type-I error rate calculations from the prior exercises in Section @ref(exAnovaExercises) using a <span class="math inline">\(t\)</span>-distribution with 5 degrees of freedom.
Do the results change substantially?</p></li>
</ol>
</div>
<div id="plot-the-bivariate-poisson" class="section level3 hasAnchor" number="6.9.2">
<h3 class="hasAnchor"><span class="header-section-number">6.9.2</span> Plot the bivariate Poisson<a href="#plot-the-bivariate-poisson" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>In Section @ref(DGP-functions), we provided an example of a DGP function for the bivariate Poisson model.
We demonstrated a plot of data simulated from this function in @ref(DGP-plotting).
Create a similar plot but for a much larger sample size of <span class="math inline">\(N = 1000\)</span>.</p>
<p>With such a large dataset, it will likely be hard to distinguish individual observations because of over-plotting.
Create a better visual representation of the same simulated dataset, such as a heatmap or a contour plot.</p>
</div>
<div id="BVP-check" class="section level3 hasAnchor" number="6.9.3">
<h3 class="hasAnchor"><span class="header-section-number">6.9.3</span> Check the bivariate Poisson function<a href="#BVP-check" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Although we presented a DGP function for the bivariate Poisson model, we have not demonstrated how to check that the function is correct—we’re leaving that to you!
Write some code to verify that the function <code>r_bivariate_Poisson()</code> is working properly.
Do this by generating a very large sample (say <span class="math inline">\(N = 10^4\)</span> or <span class="math inline">\(10^5\)</span>) and verifying the following:</p>
<ul>
<li>The sample means of <span class="math inline">\(C_1\)</span> and <span class="math inline">\(C_2\)</span> align with the specified population means.</li>
<li>The sample variances of <span class="math inline">\(C_1\)</span> and <span class="math inline">\(C_2\)</span> are close to the specified population means (because for a Poisson distribution <span class="math inline">\(\mathbb{E}(C_p) = \mathbb{V}(C_p)\)</span> for <span class="math inline">\(p = 1,2\)</span>).</li>
<li>The sample correlation aligns with the specified population correlation.</li>
<li>The observed counts <span class="math inline">\(C_1\)</span> and <span class="math inline">\(C_2\)</span> follow Poisson distributions.
<!-- LWM: How do you check to see if it follows?  Give some more hints here, and then refer to this problem later when asking again for gamma --></li>
</ul>
</div>
<div id="BVP-error" class="section level3 hasAnchor" number="6.9.4">
<h3 class="hasAnchor"><span class="header-section-number">6.9.4</span> Add error-catching to the bivariate Poisson function<a href="#BVP-error" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>In Section @ref(DGP-examples), we noted that the bivariate Poisson function as we described it can only produce a constrained range of correlations, which a maximum value that depends on the ratio of <span class="math inline">\(\mu_1\)</span> to <span class="math inline">\(\mu_2\)</span>.
Our current implementation of the model does not handle this aspect of the model very well:</p>
<div class="sourceCode" id="cb154"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb154-1"><a href="#cb154-1" tabindex="-1"></a><span class="fu">r_bivariate_Poisson</span>(<span class="dv">5</span>, <span class="at">rho =</span> <span class="fl">0.6</span>, <span class="at">mu1 =</span> <span class="dv">4</span>, <span class="at">mu2 =</span> <span class="dv">12</span>)</span></code></pre></div>
<pre><code>## Warning in rpois(N, lambda = mu1 - EZ3): NAs
## produced</code></pre>
<pre><code>##   C1 C2
## 1 NA 11
## 2 NA 11
## 3 NA 13
## 4 NA 15
## 5 NA  9</code></pre>
<p>For this combination of parameter values, <span class="math inline">\(\rho \times \sqrt{\mu_1 \mu_2}\)</span> is larger than <span class="math inline">\(\mu_1\)</span>, which leads to simulated values for <span class="math inline">\(C_1\)</span> that are all missing.
That makes it pretty hard to compute the correlation between <span class="math inline">\(C_1\)</span> and <span class="math inline">\(C_2\)</span>.</p>
<p>Please help us fix this issue! Revise <code>r_bivariate_Poisson()</code> so that it checks for allowable values of <span class="math inline">\(\rho\)</span>. If the user specifies a combination of parameters that does not make sense, make the function throw an error (using R’s <code>stop()</code> function).</p>
</div>
<div id="BVNB1" class="section level3 hasAnchor" number="6.9.5">
<h3 class="hasAnchor"><span class="header-section-number">6.9.5</span> A bivariate negative binomial distribution<a href="#BVNB1" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>One potential limitation of the bivariate Poisson distribution described above is that the variances of the counts are necessarily equal to the means (i.e., unit dispersion).
This limitation is inherited from the univariate Poisson distributions that each variate follows.
Just as with the corresponding univariate distributions, one way to relax this limitation is to consider distributions with marginals that are negative binomial rather than Poisson, thereby allowing for overdispersion.
<span class="citation">Cho et al. (<a href="#ref-Cho2023bivariate">2023</a>)</span> describes one type of bivariate negative binomial distribution and provides a method for constructing a bivariate negative binomial distribution by using latent, gamma-distributed components.
Their algorithm involves first generating components from gamma distributions with specified shape and scale parameters:
<span class="math display">\[
\begin{aligned}
Z_0 &amp;\sim \Gamma\left( \alpha_0, \beta\right) \\
Z_1 &amp;\sim \Gamma\left( \alpha_1, \beta\right) \\
Z_2 &amp;\sim \Gamma\left( \alpha_2, \beta\right)
\end{aligned}
\]</span>
for <span class="math inline">\(\alpha_0,\alpha_1,\alpha_2 &gt; 0\)</span> and <span class="math inline">\(\beta &gt; 0\)</span>.
They then simulate independent Poisson random variables as
<span class="math display">\[
\begin{aligned}
C_1 &amp;\sim Pois\left( Z_0 + Z_1 \right) \\
C_2 &amp;\sim Pois\left( \delta(Z_0 + Z_2) \right).
\end{aligned}
\]</span>
The resulting count variables follow marginal negative binomial distributions with moments
<span class="math display">\[
\begin{aligned}
\mathbb{E}(C_1) &amp;= (\alpha_0 + \alpha_1) \beta &amp; \mathbb{V}(C_1) &amp;= (\alpha_0 + \alpha_1) \beta (\beta + 1) \\
\mathbb{E}(C_2) &amp;= (\alpha_0 + \alpha_2) \beta \delta &amp; \mathbb{V}(C_2) &amp;= (\alpha_0 + \alpha_2) \beta \delta (\beta \delta + 1) \\
&amp; &amp; \text{Cov}(C_1, C_2) &amp;= \alpha_0 \beta^2 \delta.
\end{aligned}
\]</span>
The correlation between <span class="math inline">\(C_1\)</span> and <span class="math inline">\(C_2\)</span> is thus
<span class="math display">\[
\text{cor}(C_1, C_2) = \frac{\alpha_0}{\sqrt{(\alpha_0 + \alpha_1)(\alpha_0 + \alpha_2)}} \frac{\beta \sqrt{\delta}}{\sqrt{(\beta + 1)(\beta \delta + 1)}}.
\]</span></p>
<ol style="list-style-type: decimal">
<li><p>Write a DGP function that implements this distribution.</p></li>
<li><p>Write some code to check that the function produces data where each variate follows a negative binomial distribution and where the correlation agrees with the formula given above.</p></li>
<li><p>Consider parameter values that produce <span class="math inline">\(\mathbb{E}(C_1) = \mathbb{E}(C_2) = 10\)</span> and <span class="math inline">\(\mathbb{V}(C_1) = \mathbb{V}(C_2) = 15\)</span>. What are the minimum and maximum possible correlations between <span class="math inline">\(C_1\)</span> and <span class="math inline">\(C_2\)</span>?</p></li>
</ol>
</div>
<div id="BVNB2" class="section level3 hasAnchor" number="6.9.6">
<h3 class="hasAnchor"><span class="header-section-number">6.9.6</span> Another bivariate negative binomial distribution<a href="#BVNB2" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Another model for generating bivariate counts with negative binomial marginal distributions is by using Gaussian copulas. Here is a mathematical recipe for this distribution, which will produce counts with marginal means <span class="math inline">\(\mu_1\)</span> and <span class="math inline">\(\mu_2\)</span> and marginal variances <span class="math inline">\(\mu_1 + \mu_1^2 / p_1\)</span> and <span class="math inline">\(\mu_2 + \mu_2^2 / p_2\)</span>. Start by generating variates from a bivariate standard normal distribution with correlation <span class="math inline">\(\rho\)</span>:
<span class="math display">\[
\left(\begin{array}{c}Z_1 \\ Z_2 \end{array}\right) \sim N\left(\left[\begin{array}{c}0 \\ 0\end{array}\right], \ \left[\begin{array}{cc}1  &amp; \rho \\ \rho &amp; 1\end{array}\right]\right)
\]</span>
Now find <span class="math inline">\(U_1 = \Phi(Z_1)\)</span> and <span class="math inline">\(U_1 = \Phi(Z_1)\)</span>, where <span class="math inline">\(\Phi()\)</span> is the standard normal cumulative distribution function (called <code>pnorm()</code> in R).
Then generate the counts by evaluating <span class="math inline">\(U_1\)</span> and <span class="math inline">\(U_2\)</span> with the negative binomial quantile function, <span class="math inline">\(F_{NB}^{-1}(x | \mu, p)\)</span> with mean parameters <span class="math inline">\(\mu\)</span> and size parameter <span class="math inline">\(p\)</span> (this function is called <code>qnbinom()</code> in R):
<span class="math display">\[
C_1 = F_{NB}^{-1}(U_1 | \mu_1, p_1) \qquad C_2 = F_{NB}^{-1}(U_2 |  \mu_2, p_2).
\]</span>
The resulting counts will be correlated, but the correlation will not be equal to <span class="math inline">\(\rho\)</span>.</p>
<ol style="list-style-type: decimal">
<li><p>Write a DGP function that implements this distribution.</p></li>
<li><p>Write some code to check that the function produces data where each variate follows a negative binomial distribution</p></li>
<li><p>Use the function to create a graph showing the population correlation between the observed counts as a function of <span class="math inline">\(\rho\)</span>. Use <span class="math inline">\(\mu_1 = \mu_2 = 10\)</span> and <span class="math inline">\(p_1 = p_2 = 20\)</span>. How does the range of correlations compare to the range from Exercise @ref(BVNB1)?</p></li>
</ol>
</div>
<div id="cluster-RCT-plot" class="section level3 hasAnchor" number="6.9.7">
<h3 class="hasAnchor"><span class="header-section-number">6.9.7</span> Plot the data from a cluster-randomized trial<a href="#cluster-RCT-plot" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Run <code>gen_cluster_RCT()</code> with parameter values of your choice to produce data from a simulated cluster-randomized trial. Create a plot of the data that illustrates how student-level observations are nested within schools and how schools are assigned to different treatment conditions.</p>
</div>
<div id="cluster-RCT-checks" class="section level3 hasAnchor" number="6.9.8">
<h3 class="hasAnchor"><span class="header-section-number">6.9.8</span> Checking the Cluster RCT DGP<a href="#cluster-RCT-checks" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<ol style="list-style-type: decimal">
<li><p>What is the variance of the outcomes generated by the model for the cluster-randomized trial if there are no treatment effects? (Try simulating data to check!) What other quick checks can you run on this DGP to make sure it is working correctly?</p></li>
<li><p>In <code>gen_cluster_RCT()</code> we have the following line of code to generate the number of individuals per site.</p>
<div class="sourceCode" id="cb157"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb157-1"><a href="#cb157-1" tabindex="-1"></a>nj <span class="ot">&lt;-</span> <span class="fu">sample</span>( n_min<span class="sc">:</span>n_max, J, <span class="at">replace=</span><span class="cn">TRUE</span> )</span></code></pre></div>
<p>This code has an error. Generate a variety of datasets where you vary <code>n_min</code>, <code>n_max</code> and <code>J</code> to discover the error. Then repair the code.
Checking your data generating process across a range of scenarios is extremely important.</p></li>
</ol>
</div>
<div id="cluster-RCT-heterogeneity" class="section level3 hasAnchor" number="6.9.9">
<h3 class="hasAnchor"><span class="header-section-number">6.9.9</span> More school-level variation<a href="#cluster-RCT-heterogeneity" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>The DGP for the cluster-randomized trial allows for school-level treatment impact variation, but only to the extent that the variation is explained by school size. How could you modify your simulation to allow for school-level treatment impact variation that is not related to school size? Implement this change and generate some data to show how it works.</p>
</div>
<div id="cluster-RCT-baseline" class="section level3 hasAnchor" number="6.9.10">
<h3 class="hasAnchor"><span class="header-section-number">6.9.10</span> Cluster-randomized trial with baseline predictors<a href="#cluster-RCT-baseline" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Extend the DGP for the cluster-randomized trial to include an individual-level covariate <span class="math inline">\(X\)</span> that is correlated with the outcome.
Do this by modifying the model for student-level outcomes as
<span class="math display">\[
Y_{ij} = \beta_{0j} + \beta_{1} X_{ij} + \epsilon_{ij}.
\]</span>
Keep the same <span class="math inline">\(\beta_1\)</span> for all sites.
To implement this model as a DGP, you will have to decide how to generate <span class="math inline">\(X_{ij}\)</span>.</p>
<ol style="list-style-type: decimal">
<li>Use words and equations to explain your auxiliary model for <span class="math inline">\(X_{ij}\)</span>.</li>
<li>Implement the model by modifying <code>gen_cluster_RCT()</code> accordingly.</li>
<li>Use your implementation to find the unconditional variance of the outcome, <span class="math inline">\(\text{Var}(Y | Z_j = 0)\)</span>, when <span class="math inline">\(\beta_1 = 0.6\)</span>.</li>
</ol>
</div>
<div id="IRT-DGP-parameters" class="section level3 hasAnchor" number="6.9.11">
<h3 class="hasAnchor"><span class="header-section-number">6.9.11</span> 3-parameter IRT datasets<a href="#IRT-DGP-parameters" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>A challenge that arises with the IRT model described in Section @ref(three-parameter-IRT) is that the data are generated using <em>random parameters</em> (the person ability parameters <span class="math inline">\(\theta_1,...,\theta_N\)</span> and item characteristics <span class="math inline">\(\alpha_m, \beta_m, \gamma_m\)</span> for <span class="math inline">\(m = 1,...,M\)</span>) that we simulated from auxiliary models.
When applying IRT models to actual test data, the analyst’s goal will usually involve estimating at least some of these parameters: either using the model for <em>scoring</em> by estimating latent ability parameters or for <em>calibration</em> by estimating the item characteristics.
But each time we generate a new dataset with <code>r_3PL_IRT()</code>, those latent parameters will change.</p>
<p>In order to understand how well an estimation procedure will perform on data generated by our function, we will need to keep track of the parameter values, even though those values will not be known in real data analysis contexts.
Suppose that our main interest is in understanding how well we can recover the item characteristics.</p>
<ol style="list-style-type: decimal">
<li><p>Modify <code>r_3PL_IRT()</code> to return a list containing two datasets. The first entry in the list should be a dataset with the person-by-item responses, just as in the original function. The second entry in the list should be an <span class="math inline">\(M \times 3\)</span> dataset containing the item parameters.</p></li>
<li><p>An alternative strategy for implementing the three-parameter IRT DGP is to write two functions instead of one: a function to simulate a set of <span class="math inline">\(M\)</span> item parameters and a function to simulate the person-by-item responses. Complete the following function skeletons to implement this strategy. Demonstrate how to use the functions to simulate a dataset.</p>
<div class="sourceCode" id="cb158"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb158-1"><a href="#cb158-1" tabindex="-1"></a>r_3PL_items <span class="ot">&lt;-</span> <span class="cf">function</span>(</span>
<span id="cb158-2"><a href="#cb158-2" tabindex="-1"></a>  M, </span>
<span id="cb158-3"><a href="#cb158-3" tabindex="-1"></a>  <span class="at">diff_M =</span> <span class="dv">0</span>, <span class="at">diff_SD =</span> <span class="dv">1</span>,</span>
<span id="cb158-4"><a href="#cb158-4" tabindex="-1"></a>  <span class="at">disc_M =</span> <span class="dv">1</span>, <span class="at">disc_SD =</span> <span class="fl">0.2</span>,</span>
<span id="cb158-5"><a href="#cb158-5" tabindex="-1"></a>  <span class="at">item_options =</span> <span class="dv">4</span></span>
<span id="cb158-6"><a href="#cb158-6" tabindex="-1"></a>) {</span>
<span id="cb158-7"><a href="#cb158-7" tabindex="-1"></a>  <span class="co"># Code here</span></span>
<span id="cb158-8"><a href="#cb158-8" tabindex="-1"></a>  <span class="fu">return</span>(item_parameter_data)</span>
<span id="cb158-9"><a href="#cb158-9" tabindex="-1"></a>}</span>
<span id="cb158-10"><a href="#cb158-10" tabindex="-1"></a></span>
<span id="cb158-11"><a href="#cb158-11" tabindex="-1"></a>r_3PL_data <span class="ot">&lt;-</span> <span class="cf">function</span>( N, item_data ) {</span>
<span id="cb158-12"><a href="#cb158-12" tabindex="-1"></a>  <span class="co"># Generate item responses</span></span>
<span id="cb158-13"><a href="#cb158-13" tabindex="-1"></a>  <span class="fu">return</span>(response_data)</span>
<span id="cb158-14"><a href="#cb158-14" tabindex="-1"></a>}</span></code></pre></div></li>
<li><p>Describe the benefits and limitations of the two approaches you have implemented.</p></li>
<li><p>For your preferred strategy, modify your function(s) to also return the latent person ability parameters.</p></li>
</ol>
</div>
<div id="IRT-DGP-checking" class="section level3 hasAnchor" number="6.9.12">
<h3 class="hasAnchor"><span class="header-section-number">6.9.12</span> Check the 3-parameter IRT DGP<a href="#IRT-DGP-checking" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>For one of the DGPs you wrote in Exercise @ref(IRT-DGP-parameters), write code to check that the function is working properly. What features of the model will you check?</p>
</div>
<div id="IRT-DGP-breaking" class="section level3 hasAnchor" number="6.9.13">
<h3 class="hasAnchor"><span class="header-section-number">6.9.13</span> Explore the 3-parameter IRT model<a href="#IRT-DGP-breaking" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Use the modified DGP function(s) you wrote for Exercise @ref(IRT-DGP-parameters) to explore the model. Simulate data and create visualizations to answer the following questions.</p>
<ol style="list-style-type: decimal">
<li>What happens to the distribution of total scores if the items covered a very broader range of difficulties (higher <span class="math inline">\(\tau_\alpha\)</span>)?</li>
<li>What happens if the items are mis-calibrated to be too difficult (<span class="math inline">\(\mu_\tau &gt; 0\)</span>)?</li>
<li>What if the items had varying numbers of response options, so the guessing parameters differ?</li>
<li>Find at least one combination of parameter values that will produce very extreme or unrealistic distributions of total scores.</li>
</ol>
</div>
<div id="meta-regression-DGP" class="section level3 hasAnchor" number="6.9.14">
<h3 class="hasAnchor"><span class="header-section-number">6.9.14</span> Random effects meta-regression<a href="#meta-regression-DGP" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Meta-analysis involves working with quantitative findings reported by previous studies on a particular topic, in the form of effect size estimates and their standard errors, to generate integrative summaries and identify patterns in the findings that might not be evident from any previous study considered in isolation.
One model that is widely used in meta-analysis is the random effects meta-regression, which relates the effect sizes to known characteristics of the studies that are encoded in the form of predictors.
Consider a collection of <span class="math inline">\(K\)</span> studies. Let <span class="math inline">\(T_i\)</span> denote an effect size estimate and <span class="math inline">\(s_i\)</span> denote its standard error for study <span class="math inline">\(i\)</span>.
Let <span class="math inline">\(x_{i}\)</span> be a quantitative predictor variable that represents some characteristic of study <span class="math inline">\(i\)</span> (such as its year of publication).
The random effects meta-regression model assumes
<span class="math display">\[
T_i = \beta_0 + \beta_1 x_i + u_i + e_i,
\]</span>
where <span class="math inline">\(u_i \sim N(0, \tau^2)\)</span> and <span class="math inline">\(e_i \sim N(0, s_i^2)\)</span>.
In this model, <span class="math inline">\(\beta_0\)</span> corresponds to the expected effect size when <span class="math inline">\(x_i = 0\)</span> and <span class="math inline">\(\beta_1\)</span> describes the expected difference in effect size per one unit difference in <span class="math inline">\(x_i\)</span>.
The first error <span class="math inline">\(u_i\)</span> corresponds to the heterogeneity in the effect sizes above and beyond the variation explained by <span class="math inline">\(x_i\)</span>, and the second error <span class="math inline">\(e_i\)</span> corresponds to the sampling error, which we assume has known variance <span class="math inline">\(s_i^2\)</span>.</p>
<ol style="list-style-type: decimal">
<li><p>Of the variables in the random effects meta-regression model, which are structural features, which are covariates, and which are outcomes? Of the parameters described above, which would you classify as focal, which as auxiliary, and which as design parameters?</p></li>
<li><p>In addition to the focal model described above, what further assumptions or auxiliary models will be needed in order to simulate data for a random effects meta-regression? Propose an auxiliary model for any needed quantities.</p></li>
<li><p>Using your proposed auxiliary model, write a function to generate data for a random effects meta-regression. Demonstrate your function by creating a plot based on a simulated dataset with <span class="math inline">\(K = 30\)</span> effect sizes.</p></li>
<li><p>Write code to check the properties of your data-generating function.</p></li>
</ol>
</div>
<div id="Vevea-Hedges-DGP" class="section level3 hasAnchor" number="6.9.15">
<h3 class="hasAnchor"><span class="header-section-number">6.9.15</span> Meta-regression with selective reporting<a href="#Vevea-Hedges-DGP" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p><span class="citation">Vevea and Hedges (<a href="#ref-vevea1995general">1995</a>)</span> proposed a meta-regression model that allows for the possibility that not all primary study results are published.
They assume that primary study results are generated according to the random effects meta-regression model described in Exercise @ref(meta-regression-DGP), but then only a subset of results are observed, where the probability of being included is a function of the result’s one-sided <span class="math inline">\(p\)</span>-value for the null hypothesis <span class="math inline">\(H_0: \delta \leq 0\)</span> against alternative <span class="math inline">\(H_A: \delta &gt; 0\)</span>.
Let <span class="math inline">\(p_i = 1 - \Phi(T_i / s_i)\)</span> be the one-sided <span class="math inline">\(p\)</span>-value for study result <span class="math inline">\(i\)</span>, where <span class="math inline">\(Phi()\)</span> is the standard normal cumulative distribution (<code>pnorm()</code> in R).
In one version of the selection model, the selection probability follows a piece-wise constant distribution with
<span class="math display">\[
\text{Pr}(T_i \text{ is observed}) = \begin{cases}
1 &amp; \text{if} \quad 0 \leq p_i &lt; .025 \\
\lambda_1 &amp; \text{if} \quad .025 \leq p_i &lt; .500 \\  
\lambda_2 &amp; \text{if} \quad .500 \leq  p_i &lt; 1
\end{cases}
\]</span>
for selection probabilities <span class="math inline">\(0 \leq \lambda_1 \leq 1\)</span> and <span class="math inline">\(0 \leq \lambda_2 \leq 1\)</span>.</p>
<ol style="list-style-type: decimal">
<li><p>Modify your data-generating function from Exercise @ref(meta-regression-DGP) to follow the Vevea-Hedges selection model. Ensure that the new data-generating function returns a total of <span class="math inline">\(K\)</span> primary study results.</p></li>
<li><p>Use the new function to generate a large number of effect size estimates, all with <span class="math inline">\(s_i = 0.35\)</span>, using parameters <span class="math inline">\(\beta_0 = 0.1\)</span>, <span class="math inline">\(\beta_1 = 0.0\)</span>, <span class="math inline">\(\tau = 0.1\)</span>, <span class="math inline">\(\lambda_1 = 0.5\)</span>, and <span class="math inline">\(\lambda_2 = 0.2\)</span>. Plot the distribution of observed effect size estimates.</p></li>
<li><p>Create several further plots using different values for <span class="math inline">\(\lambda_1\)</span> and <span class="math inline">\(\lambda_2\)</span>. How do these parameters affect the shape of the distribution?</p></li>
<li><p>Use the <code>selmodel()</code> function from the <code>metafor</code> package to estimate the Vevea-Hedges selection model based on one of your simulated datasets. (See Exercise @ref(Vevea-Hedges-estimation) for example syntax.) How do the estimates compare to the model parameters you’ve specified?</p></li>
</ol>
<!--chapter:end:020-Data-generating-models.Rmd-->
</div>
</div>
</div>
<div id="data-analysis-procedures" class="section level1 hasAnchor" number="7">
<h1 class="hasAnchor"><span class="header-section-number">7</span> Data analysis procedures<a href="#data-analysis-procedures" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p>The overall aims of many simulation studies have to do with understand how a particular data-analysis procedure works or comparing the performance of multiple, competing procedures.
Thus, the data-analysis procedure or procedures are the central object of study.
Depending on the research question, the data-analysis procedure might be very simple—as simple as just computing a sample correlation–or it might involve a combination of several components.
For example, the procedure might entail first computing a diagnostic test for heteroskedasticity and then, depending on the outcome of the test, applying either a conventional formula or a heteroskedasticity-robust formula for standard errors.
As another example, a data-analysis procedure might involve using multiple imputation for missingness on key variables, then fitting a statistical model, and then generating predicted values based on the model.
Also depending on the research question, we might need to create <em>several</em> functions that implement different estimation procedures to be compared.</p>
<p>In this chapter, we demonstrate how to implement data-analysis procedures in the form of R functions, which we call <em>estimation functions</em>, so that their performance can eventually be evaluated by repeatedly applying them to artificial data.
We start by describing the high-level design of an estimation function, and illustrate with some simple examples.
We then discuss approaches for writing simulations that compare multiple data analysis procedures.
Next, we describe strategies for validating the coded-up estimation functions before running a full simulation.
Finally, we examine methods for handling common computational problems with estimation functions, such as handling non-convergence when using maximum likelihood estimation.</p>
<div id="estimation-functions" class="section level2 hasAnchor" number="7.1">
<h2 class="hasAnchor"><span class="header-section-number">7.1</span> Writing estimation functions<a href="#estimation-functions" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>In the abstract, a function that implements an estimation procedure should have the following form:</p>
<div class="sourceCode" id="cb159"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb159-1"><a href="#cb159-1" tabindex="-1"></a>estimate <span class="ot">&lt;-</span> <span class="cf">function</span>(data) {</span>
<span id="cb159-2"><a href="#cb159-2" tabindex="-1"></a></span>
<span id="cb159-3"><a href="#cb159-3" tabindex="-1"></a>  <span class="co"># calculations/model-fitting/estimation procedures</span></span>
<span id="cb159-4"><a href="#cb159-4" tabindex="-1"></a>  </span>
<span id="cb159-5"><a href="#cb159-5" tabindex="-1"></a>  <span class="fu">return</span>(estimates)</span>
<span id="cb159-6"><a href="#cb159-6" tabindex="-1"></a>}</span></code></pre></div>
<p>The function takes a dataset as input, fits a model or otherwise calculates an estimate, possibly with associated standard errors and so forth, and returns these quantities as output.
The estimates could be point estimates of parameters, standard errors, confidence intervals, p-values, predictions, or other quantities.
The calculations in the body of the function should be set up to use datasets that have the same structure (i.e., same dimensions, same variable names) as the output of the corresponding function for generating simulated data.
However, in principle, we should also be able to run the estimation function on real data as well.</p>
<p>In Chapter @ref(case-ANOVA) we wrote a function called <code>ANOVA_Welch_F()</code> for computing <span class="math inline">\(p\)</span>-values from two different procedures for testing equality of means in a heteroskedastic ANOVA:</p>
<div class="sourceCode" id="cb160"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb160-1"><a href="#cb160-1" tabindex="-1"></a>ANOVA_Welch_F <span class="ot">&lt;-</span> <span class="cf">function</span>(data) {</span>
<span id="cb160-2"><a href="#cb160-2" tabindex="-1"></a>  anova_F <span class="ot">&lt;-</span> <span class="fu">oneway.test</span>(x <span class="sc">~</span> group, <span class="at">data =</span> data, <span class="at">var.equal =</span> <span class="cn">TRUE</span>)</span>
<span id="cb160-3"><a href="#cb160-3" tabindex="-1"></a>  Welch_F <span class="ot">&lt;-</span> <span class="fu">oneway.test</span>(x <span class="sc">~</span> group, <span class="at">data =</span> data, <span class="at">var.equal =</span> <span class="cn">FALSE</span>)</span>
<span id="cb160-4"><a href="#cb160-4" tabindex="-1"></a>  </span>
<span id="cb160-5"><a href="#cb160-5" tabindex="-1"></a>  result <span class="ot">&lt;-</span> <span class="fu">tibble</span>(</span>
<span id="cb160-6"><a href="#cb160-6" tabindex="-1"></a>    <span class="at">ANOVA =</span> anova_F<span class="sc">$</span>p.value,</span>
<span id="cb160-7"><a href="#cb160-7" tabindex="-1"></a>    <span class="at">Welch =</span> Welch_F<span class="sc">$</span>p.value</span>
<span id="cb160-8"><a href="#cb160-8" tabindex="-1"></a>  )</span>
<span id="cb160-9"><a href="#cb160-9" tabindex="-1"></a>  </span>
<span id="cb160-10"><a href="#cb160-10" tabindex="-1"></a>  <span class="fu">return</span>(result)</span>
<span id="cb160-11"><a href="#cb160-11" tabindex="-1"></a>}</span></code></pre></div>
<p>Apply this function to a simulated dataset returns two p-values, one for the usual ANOVA <span class="math inline">\(F\)</span> test (which assumes homoskedasticity) and one for Welch’s heteroskedastic <span class="math inline">\(F\)</span> test:</p>
<div class="sourceCode" id="cb161"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb161-1"><a href="#cb161-1" tabindex="-1"></a>sim_data <span class="ot">&lt;-</span> <span class="fu">generate_ANOVA_data</span>(</span>
<span id="cb161-2"><a href="#cb161-2" tabindex="-1"></a>  <span class="at">mu =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">6</span>), </span>
<span id="cb161-3"><a href="#cb161-3" tabindex="-1"></a>  <span class="at">sigma_sq =</span> <span class="fu">c</span>(<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">1</span>),</span>
<span id="cb161-4"><a href="#cb161-4" tabindex="-1"></a>  <span class="at">sample_size =</span> <span class="fu">c</span>(<span class="dv">3</span>, <span class="dv">6</span>, <span class="dv">2</span>, <span class="dv">4</span>)</span>
<span id="cb161-5"><a href="#cb161-5" tabindex="-1"></a>)</span>
<span id="cb161-6"><a href="#cb161-6" tabindex="-1"></a><span class="fu">ANOVA_Welch_F</span>(sim_data)</span></code></pre></div>
<pre><code>## # A tibble: 1 × 2
##      ANOVA  Welch
##      &lt;dbl&gt;  &lt;dbl&gt;
## 1 0.000293 0.0179</code></pre>
<p>Our <code>ANOVA_Welch_F()</code> function is designed to work with the output of <code>generate_ANOVA_data()</code> in that it assumes that the grouping variable is called <code>group</code> and the outcome is called <code>x</code>.
Relying on this assumption would be a poor choice if we were designing a function as part of an R package or for general-purpose use.
However, because the primary use of the function is for simulation, it is reasonable to assume that the input data will always have appropriate variable names.</p>
<p>In Chapter @ref(data-generating-processes), we looked at a data-generating function for a bivariate Poisson distribution, an example of a non-normal bivariate distribution.
We might use such a distribution to understand the behavior of Pearson’s sample correlation coefficient and its normalizing transformation, known as Fisher’s <span class="math inline">\(z\)</span>-transformation, which is equivalent to the hyperbolic arc-tangent function (<code>atanh()</code> in R).
When the sample measurements follow a bivariate normal distribution, Fisher’s <span class="math inline">\(z\)</span>-transformed correlation is very close to normally distributed and its standard error is simply <span class="math inline">\(1 / \sqrt{N - 3}\)</span>, and thus independent of the correlation.
This makes <span class="math inline">\(z\)</span>-transformation very useful for computing confidence intervals, which can then be back-transformed to the Pearson-<span class="math inline">\(r\)</span> scale.</p>
<p>In this problem, a simple estimation function would take a dataset with two variables as input and compute the sample correlation and its <span class="math inline">\(z\)</span>-transformation, compute confidence intervals for <span class="math inline">\(z\)</span>, and then back-transform the confidence interval end-points.
Here is an implementation of these calculations:</p>
<div class="sourceCode" id="cb163"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb163-1"><a href="#cb163-1" tabindex="-1"></a>r_and_z <span class="ot">&lt;-</span> <span class="cf">function</span>(data) {</span>
<span id="cb163-2"><a href="#cb163-2" tabindex="-1"></a>  </span>
<span id="cb163-3"><a href="#cb163-3" tabindex="-1"></a>  r <span class="ot">&lt;-</span> <span class="fu">cor</span>(data<span class="sc">$</span>C1, data<span class="sc">$</span>C2)</span>
<span id="cb163-4"><a href="#cb163-4" tabindex="-1"></a>  z <span class="ot">&lt;-</span> <span class="fu">atanh</span>(r)</span>
<span id="cb163-5"><a href="#cb163-5" tabindex="-1"></a>  se_z <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">/</span> <span class="fu">sqrt</span>(<span class="fu">nrow</span>(data) <span class="sc">-</span> <span class="dv">3</span>)</span>
<span id="cb163-6"><a href="#cb163-6" tabindex="-1"></a>  ci_z <span class="ot">&lt;-</span> z <span class="sc">+</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">1</span>, <span class="dv">1</span>) <span class="sc">*</span> <span class="fu">qnorm</span>(.<span class="dv">975</span>) <span class="sc">*</span> se_z</span>
<span id="cb163-7"><a href="#cb163-7" tabindex="-1"></a>  ci_r <span class="ot">&lt;-</span> <span class="fu">tanh</span>(ci_z)</span>
<span id="cb163-8"><a href="#cb163-8" tabindex="-1"></a>  </span>
<span id="cb163-9"><a href="#cb163-9" tabindex="-1"></a>  <span class="fu">tibble</span>( <span class="at">r =</span> r, <span class="at">z =</span> z, <span class="at">CI_lo =</span> ci_r[<span class="dv">1</span>], <span class="at">CI_hi =</span> ci_r[<span class="dv">2</span>] )</span>
<span id="cb163-10"><a href="#cb163-10" tabindex="-1"></a>}</span></code></pre></div>
<p>To check that the function returns a result of the expected form, we generate a small dataset using the <code>r_bivariate_Poisson()</code> function developed in the last chapter, then apply our estimation function to the result:</p>
<div class="sourceCode" id="cb164"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb164-1"><a href="#cb164-1" tabindex="-1"></a>Pois_dat <span class="ot">&lt;-</span> <span class="fu">r_bivariate_Poisson</span>(<span class="dv">40</span>, <span class="at">rho =</span> <span class="fl">0.5</span>, <span class="at">mu1 =</span> <span class="dv">4</span>, <span class="at">mu2 =</span> <span class="dv">4</span>)</span>
<span id="cb164-2"><a href="#cb164-2" tabindex="-1"></a><span class="fu">r_and_z</span>(Pois_dat)</span></code></pre></div>
<pre><code>## # A tibble: 1 × 4
##       r     z CI_lo CI_hi
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 0.557 0.628 0.296 0.740</code></pre>
<p>Although it is a little cumbersome to do so, we could also apply the estimation function to a real dataset.
Here is an example, which calculates the correlation between ratings of judicial integrity and familiarity with the law from the <code>USJudgeRatings</code> dataset (which is included in base R).
For the function to work on this dataset, we first need to rename the relevant variables.</p>
<div class="sourceCode" id="cb166"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb166-1"><a href="#cb166-1" tabindex="-1"></a><span class="fu">data</span>(USJudgeRatings)</span>
<span id="cb166-2"><a href="#cb166-2" tabindex="-1"></a></span>
<span id="cb166-3"><a href="#cb166-3" tabindex="-1"></a>USJudgeRatings <span class="sc">%&gt;%</span></span>
<span id="cb166-4"><a href="#cb166-4" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">select</span>(<span class="at">C1 =</span> INTG, <span class="at">C2 =</span> FAMI) <span class="sc">%&gt;%</span></span>
<span id="cb166-5"><a href="#cb166-5" tabindex="-1"></a>  <span class="fu">r_and_z</span>()</span></code></pre></div>
<pre><code>## # A tibble: 1 × 4
##       r     z CI_lo CI_hi
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 0.869  1.33 0.769 0.927</code></pre>
<p>The function returns a valid result—a quite strong correlation!</p>
<p>It is a good practice to test out a newly-developed estimation function on real data as a check that it is working as intended.
This type of test ensures that the estimation function is not using information outside of the dataset, such as by using known parameter values to construct an estimate.
Applying the function to a real dataset demonstrates that the function implements a procedure that could actually be applied in real data analysis contexts.</p>
</div>
<div id="multiple-estimation-procedures" class="section level2 hasAnchor" number="7.2">
<h2 class="hasAnchor"><span class="header-section-number">7.2</span> Including Multiple Data Analysis Procedures<a href="#multiple-estimation-procedures" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Many simulations involve head-to-head comparisons between more than one data-analysis procedure.
As a design principle, we generally recommend writing different functions for each estimation method one is planning on evaluating.
Doing so makes it easier to add in additional methods as desired or to focus on just a subset of methods.
Writing separate function also leads to a code base that is flexible and useful for other purposes (such as analyzing real data).
Finally (repeating one of our favorite mantras), separating functions makes debugging easier because it lets you focus attention on one thing at a time, without worrying about how errors in one area might propagate to others.</p>
<p>To see how this works in practice, we will return to the case study from Section @ref(case-cluster), where we developed a data-generating function for simulating a cluster-randomized trial with student-level outcomes but school-level treatment assignment.
Our data-generating process allowed for varying school sizes and heterogeneous treatment effects, which might be correlated with school size.
Several different procedures might be used to estimate an overall average effect from a clustered experiment, including:</p>
<ul>
<li>Estimating a multi-level regression model (also known as a hierarchical linear model),</li>
<li>Estimating an ordinary least squares (OLS) regression model and applying cluster-robust standard errors, or</li>
<li>Averaging the outcomes by school, then estimating a linear regression model on the mean outcomes.</li>
</ul>
<p>All three of these methods are widely used and have some theoretical guarantees supporting their use.
Education researchers tend to be more comfortable using multi-level regression models, whereas economists tend to use OLS with clustered standard errors.
<!-- JEP: Do we want to add any citations for further reading about these strategies? Any further comments about these methods? -->
<!-- LWM: I think we don't need anything? --></p>
<p>We next develop estimation functions for each of these procedures.
We analyze as we expect would be done in practice; even though we generated data with a school size covariate, we do not include it in our estimation functions.
Each function needs to produce a point estimate, standard error, and <span class="math inline">\(p\)</span>-value for the average treatment effect.
To have data to practice on, we generate a sample dataset using <a href="/case_study_code/gen_cluster_RCT_rev.R">a revised version of <code>gen_cluster_RCT()</code></a>, which corrects the bug discussed in Exercise @ref(cluster-RCT-checks):</p>
<div class="sourceCode" id="cb168"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb168-1"><a href="#cb168-1" tabindex="-1"></a>dat <span class="ot">&lt;-</span> <span class="fu">gen_cluster_RCT</span>( </span>
<span id="cb168-2"><a href="#cb168-2" tabindex="-1"></a>  <span class="at">J=</span><span class="dv">16</span>, <span class="at">n_bar =</span> <span class="dv">30</span>, <span class="at">alpha =</span> <span class="fl">0.8</span>, <span class="at">p =</span> <span class="fl">0.5</span>, </span>
<span id="cb168-3"><a href="#cb168-3" tabindex="-1"></a>  <span class="at">gamma_0 =</span> <span class="dv">0</span>, <span class="at">gamma_1 =</span> <span class="fl">0.2</span>, <span class="at">gamma_2 =</span> <span class="fl">0.2</span>,</span>
<span id="cb168-4"><a href="#cb168-4" tabindex="-1"></a>  <span class="at">sigma2_u =</span> <span class="fl">0.4</span>, <span class="at">sigma2_e =</span> <span class="fl">0.6</span></span>
<span id="cb168-5"><a href="#cb168-5" tabindex="-1"></a>)</span></code></pre></div>
<p>For the multi-level modeling strategy, there are several different existing packages that we could use.
We will implement an estimator using the popular <code>lme4</code> package, along with the <code>lmerTest</code> function for computing a <span class="math inline">\(p\)</span>-value for the average effect.
Here is a basic implementation:</p>
<div class="sourceCode" id="cb169"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb169-1"><a href="#cb169-1" tabindex="-1"></a>analysis_MLM <span class="ot">&lt;-</span> <span class="cf">function</span>( dat ) {</span>
<span id="cb169-2"><a href="#cb169-2" tabindex="-1"></a>  </span>
<span id="cb169-3"><a href="#cb169-3" tabindex="-1"></a>  M1 <span class="ot">&lt;-</span> lme4<span class="sc">::</span><span class="fu">lmer</span>( Yobs <span class="sc">~</span> <span class="dv">1</span> <span class="sc">+</span> Z <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> sid), <span class="at">data =</span> dat )</span>
<span id="cb169-4"><a href="#cb169-4" tabindex="-1"></a>  M1_test <span class="ot">&lt;-</span> lmerTest<span class="sc">::</span><span class="fu">as_lmerModLmerTest</span>(M1)</span>
<span id="cb169-5"><a href="#cb169-5" tabindex="-1"></a>  M1_summary <span class="ot">&lt;-</span> <span class="fu">summary</span>(M1_test)<span class="sc">$</span>coefficients</span>
<span id="cb169-6"><a href="#cb169-6" tabindex="-1"></a>  </span>
<span id="cb169-7"><a href="#cb169-7" tabindex="-1"></a>  <span class="fu">tibble</span>( </span>
<span id="cb169-8"><a href="#cb169-8" tabindex="-1"></a>    <span class="at">ATE_hat =</span> M1_summary[<span class="st">&quot;Z&quot;</span>,<span class="st">&quot;Estimate&quot;</span>], </span>
<span id="cb169-9"><a href="#cb169-9" tabindex="-1"></a>    <span class="at">SE_hat =</span> M1_summary[<span class="st">&quot;Z&quot;</span>,<span class="st">&quot;Std. Error&quot;</span>], </span>
<span id="cb169-10"><a href="#cb169-10" tabindex="-1"></a>    <span class="at">p_value =</span> M1_summary[<span class="st">&quot;Z&quot;</span>, <span class="st">&quot;Pr(&gt;|t|)&quot;</span>] </span>
<span id="cb169-11"><a href="#cb169-11" tabindex="-1"></a>  )</span>
<span id="cb169-12"><a href="#cb169-12" tabindex="-1"></a>}</span></code></pre></div>
<p>The function fits a multi-level model with a fixed coefficient for the treatment indicator and random intercepts for each school.
To get a p-value for the treatment coefficient, we have to convert the model into an <code>lmerModLmerTest</code> object and then pass it through <code>summary()</code>.
The function outputs only the statistics in which we are interested.</p>
<p>Our function makes use of the <code>lme4</code> and <code>lmerTest</code> packages.
Rather than assuming that these packages will be loaded, we call relevant functions using the package name as a prefix, as in <code>lme4::lmer()</code>.
This way, we can run the function even if we have not loaded the packages in the global environment.
This approach is also preferable to loading packages inside the function itself (e.g., with <code>require(lme4)</code>) because calling the function does not change which packages are loaded in the global environment.</p>
<p>Here is a function implementing OLS regression with cluster-robust standard errors:</p>
<div class="sourceCode" id="cb170"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb170-1"><a href="#cb170-1" tabindex="-1"></a>analysis_OLS <span class="ot">&lt;-</span> <span class="cf">function</span>( dat, <span class="at">se_type =</span> <span class="st">&quot;CR2&quot;</span> ) {</span>
<span id="cb170-2"><a href="#cb170-2" tabindex="-1"></a>  </span>
<span id="cb170-3"><a href="#cb170-3" tabindex="-1"></a>  M2 <span class="ot">&lt;-</span> estimatr<span class="sc">::</span><span class="fu">lm_robust</span>( </span>
<span id="cb170-4"><a href="#cb170-4" tabindex="-1"></a>    Yobs <span class="sc">~</span> <span class="dv">1</span> <span class="sc">+</span> Z, <span class="at">data =</span> dat, </span>
<span id="cb170-5"><a href="#cb170-5" tabindex="-1"></a>    <span class="at">clusters =</span> sid,  <span class="at">se_type =</span> se_type</span>
<span id="cb170-6"><a href="#cb170-6" tabindex="-1"></a>  )</span>
<span id="cb170-7"><a href="#cb170-7" tabindex="-1"></a>  </span>
<span id="cb170-8"><a href="#cb170-8" tabindex="-1"></a>  <span class="fu">tibble</span>( </span>
<span id="cb170-9"><a href="#cb170-9" tabindex="-1"></a>    <span class="at">ATE_hat =</span> M2<span class="sc">$</span>coefficients[[<span class="st">&quot;Z&quot;</span>]], </span>
<span id="cb170-10"><a href="#cb170-10" tabindex="-1"></a>    <span class="at">SE_hat =</span> M2<span class="sc">$</span>std.error[[<span class="st">&quot;Z&quot;</span>]], </span>
<span id="cb170-11"><a href="#cb170-11" tabindex="-1"></a>    <span class="at">p_value =</span> M2<span class="sc">$</span>p.value[[<span class="st">&quot;Z&quot;</span>]] </span>
<span id="cb170-12"><a href="#cb170-12" tabindex="-1"></a>  )</span>
<span id="cb170-13"><a href="#cb170-13" tabindex="-1"></a>}</span></code></pre></div>
<p>To get cluster-robust standard errors, we use the <code>lm_robust()</code> function from the <code>estimatr()</code> package, again calling only the relevant function using the package prefix rather than loading the whole package.
A novel aspect of this estimation function is that it includes an additional intput argument, <code>se_type</code>, which allows us to control the type of standard error calculated by <code>lm_robust()</code>.
Adding this option would let us use the same function to compute (and compare) different types of clustered standard errors for the average treatment effect estimate.
We set a default option of <code>"CR2"</code>, just like the default of <code>lm_robust()</code>.</p>
<p>Sometimes an analytic procedure involves multiple steps.
For example, aggregation estimator first involves collapsing the data to a school-level dataset, and then analyzing at the school level.
This is fine: we just wrap all the steps in a single estimation function: from the point of view of <em>using</em> the function, it is a single call, no matter how complicated the process inside.
Here is the code for the aggregate-then-analyze approach:</p>
<div class="sourceCode" id="cb171"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb171-1"><a href="#cb171-1" tabindex="-1"></a>analysis_agg <span class="ot">&lt;-</span> <span class="cf">function</span>( dat, <span class="at">se_type =</span> <span class="st">&quot;HC2&quot;</span> ) {</span>
<span id="cb171-2"><a href="#cb171-2" tabindex="-1"></a>  </span>
<span id="cb171-3"><a href="#cb171-3" tabindex="-1"></a>  datagg <span class="ot">&lt;-</span> dplyr<span class="sc">::</span><span class="fu">summarise</span>( </span>
<span id="cb171-4"><a href="#cb171-4" tabindex="-1"></a>    dat,</span>
<span id="cb171-5"><a href="#cb171-5" tabindex="-1"></a>    <span class="at">Ybar =</span> <span class="fu">mean</span>( Yobs ),</span>
<span id="cb171-6"><a href="#cb171-6" tabindex="-1"></a>    <span class="at">n =</span> <span class="fu">n</span>(),</span>
<span id="cb171-7"><a href="#cb171-7" tabindex="-1"></a>    <span class="at">.by =</span> <span class="fu">c</span>(sid, Z)</span>
<span id="cb171-8"><a href="#cb171-8" tabindex="-1"></a>  )</span>
<span id="cb171-9"><a href="#cb171-9" tabindex="-1"></a>  </span>
<span id="cb171-10"><a href="#cb171-10" tabindex="-1"></a>  <span class="fu">stopifnot</span>( <span class="fu">nrow</span>( datagg ) <span class="sc">==</span> <span class="fu">length</span>(<span class="fu">unique</span>(dat<span class="sc">$</span>sid) ) )</span>
<span id="cb171-11"><a href="#cb171-11" tabindex="-1"></a>  </span>
<span id="cb171-12"><a href="#cb171-12" tabindex="-1"></a>  M3 <span class="ot">&lt;-</span> estimatr<span class="sc">::</span><span class="fu">lm_robust</span>( </span>
<span id="cb171-13"><a href="#cb171-13" tabindex="-1"></a>    Ybar <span class="sc">~</span> <span class="dv">1</span> <span class="sc">+</span> Z, <span class="at">data =</span> datagg, </span>
<span id="cb171-14"><a href="#cb171-14" tabindex="-1"></a>    <span class="at">se_type =</span> se_type </span>
<span id="cb171-15"><a href="#cb171-15" tabindex="-1"></a>  )</span>
<span id="cb171-16"><a href="#cb171-16" tabindex="-1"></a>  </span>
<span id="cb171-17"><a href="#cb171-17" tabindex="-1"></a>  <span class="fu">tibble</span>( </span>
<span id="cb171-18"><a href="#cb171-18" tabindex="-1"></a>    <span class="at">ATE_hat =</span> M3<span class="sc">$</span>coefficients[[<span class="st">&quot;Z&quot;</span>]], </span>
<span id="cb171-19"><a href="#cb171-19" tabindex="-1"></a>    <span class="at">SE_hat =</span> M3<span class="sc">$</span>std.error[[<span class="st">&quot;Z&quot;</span>]], </span>
<span id="cb171-20"><a href="#cb171-20" tabindex="-1"></a>    <span class="at">p_value =</span> M3<span class="sc">$</span>p.value[[<span class="st">&quot;Z&quot;</span>]] </span>
<span id="cb171-21"><a href="#cb171-21" tabindex="-1"></a>  )</span>
<span id="cb171-22"><a href="#cb171-22" tabindex="-1"></a>}</span></code></pre></div>
<p>Note the <code>stopifnot</code> command: it will throw an error if the condition is not true.
This <code>stopifnot</code> ensures we do not have both treatment and control students within a single school–if we did, we would have more aggregated values than school ids due to the grouping!
Putting <em>assert statements</em> in your code like this is a good way to guarantee you are not introducing weird and hard-to-track errors.
A <code>stopifnot</code> statement halts your code as soon as something goes wrong, rather than letting that initial wrongness flow on to further work, creating odd results that are hard to understand.
Here we are protecting ourselves from strange results if, for example, we messed up our DGP code to have treatment not nested within school, or we were using data that did not actually come from a cluster randomized experiment.
See Section @ref(about-stopifnot) for more.</p>
<p>All of our functions produce output in the same format:</p>
<div class="sourceCode" id="cb172"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb172-1"><a href="#cb172-1" tabindex="-1"></a><span class="fu">analysis_MLM</span>( dat )</span></code></pre></div>
<pre><code>## # A tibble: 1 × 3
##   ATE_hat SE_hat p_value
##     &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;
## 1  -0.111  0.323   0.737</code></pre>
<div class="sourceCode" id="cb174"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb174-1"><a href="#cb174-1" tabindex="-1"></a><span class="fu">analysis_OLS</span>( dat )</span></code></pre></div>
<pre><code>## # A tibble: 1 × 3
##   ATE_hat SE_hat p_value
##     &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;
## 1  -0.177  0.307   0.576</code></pre>
<div class="sourceCode" id="cb176"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb176-1"><a href="#cb176-1" tabindex="-1"></a><span class="fu">analysis_agg</span>( dat )</span></code></pre></div>
<pre><code>## # A tibble: 1 × 3
##   ATE_hat SE_hat p_value
##     &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;
## 1 -0.0818  0.339   0.813</code></pre>
<p>Ensuring that the output of all the functions is structured in the same way will make it easy to keep the results organized once we start running multiple iterations of the simulation.
If each estimation method returns a dataset with the same variables, we can simply stack the results on top of each other.
Here is a function that bundles all the estimation procedures together:</p>
<div class="sourceCode" id="cb178"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb178-1"><a href="#cb178-1" tabindex="-1"></a>estimate_Tx_Fx <span class="ot">&lt;-</span> <span class="cf">function</span>(</span>
<span id="cb178-2"><a href="#cb178-2" tabindex="-1"></a>    data, </span>
<span id="cb178-3"><a href="#cb178-3" tabindex="-1"></a>    <span class="at">CR_se_type =</span> <span class="st">&quot;CR2&quot;</span>, <span class="at">agg_se_type =</span> <span class="st">&quot;HC2&quot;</span></span>
<span id="cb178-4"><a href="#cb178-4" tabindex="-1"></a>) {</span>
<span id="cb178-5"><a href="#cb178-5" tabindex="-1"></a>  </span>
<span id="cb178-6"><a href="#cb178-6" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">bind_rows</span>(</span>
<span id="cb178-7"><a href="#cb178-7" tabindex="-1"></a>    <span class="at">MLM =</span> <span class="fu">analysis_MLM</span>( dat ),</span>
<span id="cb178-8"><a href="#cb178-8" tabindex="-1"></a>    <span class="at">OLS =</span> <span class="fu">analysis_OLS</span>( dat, <span class="at">se_type =</span> CR_se_type),</span>
<span id="cb178-9"><a href="#cb178-9" tabindex="-1"></a>    <span class="at">agg =</span> <span class="fu">analysis_agg</span>( dat, <span class="at">se_type =</span> agg_se_type),</span>
<span id="cb178-10"><a href="#cb178-10" tabindex="-1"></a>    <span class="at">.id =</span> <span class="st">&quot;estimator&quot;</span></span>
<span id="cb178-11"><a href="#cb178-11" tabindex="-1"></a>  )</span>
<span id="cb178-12"><a href="#cb178-12" tabindex="-1"></a>  </span>
<span id="cb178-13"><a href="#cb178-13" tabindex="-1"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb179"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb179-1"><a href="#cb179-1" tabindex="-1"></a><span class="fu">estimate_Tx_Fx</span>(dat)</span></code></pre></div>
<pre><code>## # A tibble: 3 × 4
##   estimator ATE_hat SE_hat p_value
##   &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;
## 1 MLM       -0.111   0.323   0.737
## 2 OLS       -0.177   0.307   0.576
## 3 agg       -0.0818  0.339   0.813</code></pre>
<p>This is a common coding pattern for simulations that involve multiple estimation procedures.
Each procedure is expressed in its own function, then these are assembled together in a single function so that they can all easily be applied to the same dataset.
Stacking the results row-wise will make it easy to compute performance measures for all methods at once.
The benefit of stacking will become even more evident once we are working across multiple replications of the simulation process, as we will in Chapter @ref(running-the-simulation-process).</p>
</div>
<div id="validating-an-estimation-function" class="section level2 hasAnchor" number="7.3">
<h2 class="hasAnchor"><span class="header-section-number">7.3</span> Validating an Estimation Function<a href="#validating-an-estimation-function" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Just as with data-generating functions, it is critical to verify the accuracy of an implemented estimation function.
If an estimation function involves a known procedure that has been implemented in R or one of its contributed packages, then a straightforward way to do this is to compare your implementation to another existing implementation.
For estimation functions that involve multi-step procedures or novel methods, other approaches to verification may be needed, which rely more on statistical theory.</p>
<div id="checking-against-existing-implementations" class="section level3 hasAnchor" number="7.3.1">
<h3 class="hasAnchor"><span class="header-section-number">7.3.1</span> Checking against existing implementations<a href="#checking-against-existing-implementations" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>For our Welch test function, we can check the output of <code>ANOVA_Welch_F()</code> against the built-in <code>oneway.test</code> function. Let’s do that with a fresh set of data:</p>
<div class="sourceCode" id="cb181"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb181-1"><a href="#cb181-1" tabindex="-1"></a>sim_data <span class="ot">&lt;-</span> <span class="fu">generate_ANOVA_data</span>(</span>
<span id="cb181-2"><a href="#cb181-2" tabindex="-1"></a>  <span class="at">mu =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">6</span>), </span>
<span id="cb181-3"><a href="#cb181-3" tabindex="-1"></a>  <span class="at">sigma_sq =</span> <span class="fu">c</span>(<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">1</span>),</span>
<span id="cb181-4"><a href="#cb181-4" tabindex="-1"></a>  <span class="at">sample_size =</span> <span class="fu">c</span>(<span class="dv">3</span>, <span class="dv">6</span>, <span class="dv">2</span>, <span class="dv">4</span>)</span>
<span id="cb181-5"><a href="#cb181-5" tabindex="-1"></a>)</span>
<span id="cb181-6"><a href="#cb181-6" tabindex="-1"></a></span>
<span id="cb181-7"><a href="#cb181-7" tabindex="-1"></a>aov_results <span class="ot">&lt;-</span> <span class="fu">oneway.test</span>(x <span class="sc">~</span> <span class="fu">factor</span>(group), <span class="at">data =</span> sim_data, </span>
<span id="cb181-8"><a href="#cb181-8" tabindex="-1"></a>                           <span class="at">var.equal =</span> <span class="cn">FALSE</span>)</span>
<span id="cb181-9"><a href="#cb181-9" tabindex="-1"></a>aov_results</span></code></pre></div>
<pre><code>## 
##  One-way analysis of means (not assuming
##  equal variances)
## 
## data:  x and factor(group)
## F = 28.367, num df = 3.0000, denom df =
## 3.3253, p-value = 0.007427</code></pre>
<div class="sourceCode" id="cb183"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb183-1"><a href="#cb183-1" tabindex="-1"></a>Welch_results <span class="ot">&lt;-</span> <span class="fu">ANOVA_Welch_F</span>(sim_data)</span>
<span id="cb183-2"><a href="#cb183-2" tabindex="-1"></a><span class="fu">all.equal</span>(aov_results<span class="sc">$</span>p.value, Welch_results<span class="sc">$</span>Welch)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>We use <code>all.equal()</code> because it will check equality up to a tolerance in R, which can avoid some perplexing errors due to rounding.</p>
<p>For the bivariate correlation example, we can check the output of <code>r_and_z()</code> against R’s built-in <code>cor.test()</code> function:</p>
<div class="sourceCode" id="cb185"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb185-1"><a href="#cb185-1" tabindex="-1"></a>Pois_dat <span class="ot">&lt;-</span> <span class="fu">r_bivariate_Poisson</span>(<span class="dv">15</span>, <span class="at">rho =</span> <span class="fl">0.6</span>, <span class="at">mu1 =</span> <span class="dv">14</span>, <span class="at">mu2 =</span> <span class="dv">8</span>)</span>
<span id="cb185-2"><a href="#cb185-2" tabindex="-1"></a></span>
<span id="cb185-3"><a href="#cb185-3" tabindex="-1"></a>my_result <span class="ot">&lt;-</span> <span class="fu">r_and_z</span>(Pois_dat) <span class="sc">|&gt;</span> <span class="fu">subset</span>(<span class="at">select =</span> <span class="sc">-</span>z)</span>
<span id="cb185-4"><a href="#cb185-4" tabindex="-1"></a>my_result</span></code></pre></div>
<pre><code>## # A tibble: 1 × 3
##       r   CI_lo CI_hi
##   &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;
## 1 0.503 -0.0125 0.807</code></pre>
<div class="sourceCode" id="cb187"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb187-1"><a href="#cb187-1" tabindex="-1"></a>R_result <span class="ot">&lt;-</span> <span class="fu">cor.test</span>(<span class="sc">~</span> C1 <span class="sc">+</span> C2, <span class="at">data =</span> Pois_dat)</span>
<span id="cb187-2"><a href="#cb187-2" tabindex="-1"></a>R_result <span class="ot">&lt;-</span> <span class="fu">tibble</span>(<span class="at">r =</span> R_result<span class="sc">$</span>estimate[[<span class="st">&quot;cor&quot;</span>]], </span>
<span id="cb187-3"><a href="#cb187-3" tabindex="-1"></a>                   <span class="at">CI_lo =</span> R_result<span class="sc">$</span>conf.int[<span class="dv">1</span>], </span>
<span id="cb187-4"><a href="#cb187-4" tabindex="-1"></a>                   <span class="at">CI_hi =</span> R_result<span class="sc">$</span>conf.int[<span class="dv">2</span>])</span>
<span id="cb187-5"><a href="#cb187-5" tabindex="-1"></a>R_result</span></code></pre></div>
<pre><code>## # A tibble: 1 × 3
##       r   CI_lo CI_hi
##   &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;
## 1 0.503 -0.0125 0.807</code></pre>
<div class="sourceCode" id="cb189"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb189-1"><a href="#cb189-1" tabindex="-1"></a><span class="fu">all.equal</span>(R_result, my_result)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>This type of test is even more useful here because <code>r_and_z()</code> uses our own implementation of the confidence interval calculations, rather than relying on R’s built-in functions as we did with <code>ANOVA_Welch_F()</code>.</p>
</div>
<div id="checking-novel-procedures" class="section level3 hasAnchor" number="7.3.2">
<h3 class="hasAnchor"><span class="header-section-number">7.3.2</span> Checking novel procedures<a href="#checking-novel-procedures" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Simulations are usually an integral part of projects to develop novel statistical methods.
Checking estimation functions in such projects presents a challenge: if an estimation procedure truly is new, how do you check that your code is correct?
Effective methods for doing so will vary from problem to problem, but an over-arching strategy is to use theoretical results about the performance of the estimator to check that your implementation works as expected.
For instance, we might work out the algebraic properties of an estimator for a special case and then check that the result of the estimation function agrees with our algebra.
For some estimation problems, we might be able to identify theoretical properties of an estimator when applied to a very large sample of data and when the model is correctly specified.
If we can find results about large-sample behavior, then we can test an estimation function by applying it to a very large sample and checking whether the resulting estimates are very close to specified parameter values.
We illustrate each of these approaches using our functions for estimating treatment effects from cluster-randomized trials.</p>
<p>We start by testing an algebraic property.
With each of the three methods we have implemented, the treatment effect estimator is a difference between the weighted average of the outcomes from students in each treatment condition;
the only difference between the estimators is in what weights are used.
In the special case where all schools have the same number of students, the weights used by all three methods end up being the same: all three methods allocate equal weight to each school.
Therefore, we know that there should be no difference between the three point estimates.
Furthermore, a bit of algebra will show that the cluster-robust standard error from the OLS approach will end up being identical to the robust standard error from the aggregation approach.
If there are also equal numbers of schools assigned to both conditions, then the standard error from the multilevel model will also be identical to the other standard errors.</p>
<p>Let’s verify that our estimation functions produce results that are consistent with these theoretical properties.
To do so, we will need to generate a dataset with equal cluster sizes, setting <span class="math inline">\(\alpha = 0\)</span>:</p>
<div class="sourceCode" id="cb191"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb191-1"><a href="#cb191-1" tabindex="-1"></a>dat <span class="ot">&lt;-</span> <span class="fu">gen_cluster_RCT</span>( </span>
<span id="cb191-2"><a href="#cb191-2" tabindex="-1"></a>  <span class="at">J=</span><span class="dv">12</span>, <span class="at">n_bar =</span> <span class="dv">30</span>, <span class="at">alpha =</span> <span class="dv">0</span>, <span class="at">p =</span> <span class="fl">0.5</span>, </span>
<span id="cb191-3"><a href="#cb191-3" tabindex="-1"></a>  <span class="at">gamma_0 =</span> <span class="dv">0</span>, <span class="at">gamma_1 =</span> <span class="fl">0.2</span>, <span class="at">gamma_2 =</span> <span class="fl">0.2</span>,</span>
<span id="cb191-4"><a href="#cb191-4" tabindex="-1"></a>  <span class="at">sigma2_u =</span> <span class="fl">0.4</span>, <span class="at">sigma2_e =</span> <span class="fl">0.6</span></span>
<span id="cb191-5"><a href="#cb191-5" tabindex="-1"></a>)</span>
<span id="cb191-6"><a href="#cb191-6" tabindex="-1"></a><span class="fu">table</span>(dat<span class="sc">$</span>sid) <span class="co"># verify equal-sized clusters</span></span></code></pre></div>
<pre><code>## 
##  1  2  3  4  5  6  7  8  9 10 11 12 
## 30 30 30 30 30 30 30 30 30 30 30 30</code></pre>
<div class="sourceCode" id="cb193"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb193-1"><a href="#cb193-1" tabindex="-1"></a><span class="fu">estimate_Tx_Fx</span>(dat)</span></code></pre></div>
<pre><code>## # A tibble: 3 × 4
##   estimator ATE_hat SE_hat p_value
##   &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;
## 1 MLM        -0.525  0.366   0.183
## 2 OLS        -0.525  0.366   0.183
## 3 agg        -0.525  0.366   0.183</code></pre>
<p>All three methods yield identical results.
Now let’s try equal school sizes but unequal allocation to treatment:</p>
<div class="sourceCode" id="cb195"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb195-1"><a href="#cb195-1" tabindex="-1"></a>dat <span class="ot">&lt;-</span> <span class="fu">gen_cluster_RCT</span>( </span>
<span id="cb195-2"><a href="#cb195-2" tabindex="-1"></a>  <span class="at">J=</span><span class="dv">12</span>, <span class="at">n_bar =</span> <span class="dv">30</span>, <span class="at">alpha =</span> <span class="dv">0</span>, <span class="at">p =</span> <span class="dv">2</span> <span class="sc">/</span> <span class="dv">3</span>, </span>
<span id="cb195-3"><a href="#cb195-3" tabindex="-1"></a>  <span class="at">gamma_0 =</span> <span class="dv">0</span>, <span class="at">gamma_1 =</span> <span class="fl">0.2</span>, <span class="at">gamma_2 =</span> <span class="fl">0.2</span>,</span>
<span id="cb195-4"><a href="#cb195-4" tabindex="-1"></a>  <span class="at">sigma2_u =</span> <span class="fl">0.4</span>, <span class="at">sigma2_e =</span> <span class="fl">0.6</span></span>
<span id="cb195-5"><a href="#cb195-5" tabindex="-1"></a>)</span>
<span id="cb195-6"><a href="#cb195-6" tabindex="-1"></a><span class="fu">estimate_Tx_Fx</span>(dat)</span></code></pre></div>
<pre><code>## # A tibble: 3 × 4
##   estimator ATE_hat SE_hat p_value
##   &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;
## 1 MLM         0.189  0.547   0.737
## 2 OLS         0.189  0.413   0.663
## 3 agg         0.189  0.413   0.657</code></pre>
<p>As expected, all three point estimators match, but the SE from the multilevel model is a little bit discrepant from the others.</p>
<p>We can also use large-sample theory to check the multilevel modeling estimator.
If the model is correctly specified, then <em>all</em> the parameters of the model should be accurately estimated if the model is fit to a very large sample of data.
To check this property, we will need access to the full model output, not just the selected results returned by <code>analysis_MLM()</code>.
One way to handle this is to make a small tweak to the estimation function, adding an option to control whether to return the entire model or just selected results.
Here is the tweaked function:</p>
<div class="sourceCode" id="cb197"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb197-1"><a href="#cb197-1" tabindex="-1"></a>analysis_MLM <span class="ot">&lt;-</span> <span class="cf">function</span>( dat, <span class="at">all_results =</span> <span class="cn">FALSE</span>) {</span>
<span id="cb197-2"><a href="#cb197-2" tabindex="-1"></a>  </span>
<span id="cb197-3"><a href="#cb197-3" tabindex="-1"></a>  M1 <span class="ot">&lt;-</span> lme4<span class="sc">::</span><span class="fu">lmer</span>( Yobs <span class="sc">~</span> <span class="dv">1</span> <span class="sc">+</span> Z <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> sid), <span class="at">data =</span> dat )</span>
<span id="cb197-4"><a href="#cb197-4" tabindex="-1"></a>  M1_test <span class="ot">&lt;-</span> lmerTest<span class="sc">::</span><span class="fu">as_lmerModLmerTest</span>(M1)</span>
<span id="cb197-5"><a href="#cb197-5" tabindex="-1"></a>  </span>
<span id="cb197-6"><a href="#cb197-6" tabindex="-1"></a>  <span class="cf">if</span> (all_results) {</span>
<span id="cb197-7"><a href="#cb197-7" tabindex="-1"></a>    <span class="fu">return</span>(<span class="fu">summary</span>(M1_test))</span>
<span id="cb197-8"><a href="#cb197-8" tabindex="-1"></a>  } </span>
<span id="cb197-9"><a href="#cb197-9" tabindex="-1"></a>  </span>
<span id="cb197-10"><a href="#cb197-10" tabindex="-1"></a>  M1_summary <span class="ot">&lt;-</span> <span class="fu">summary</span>(M1_test)<span class="sc">$</span>coefficients</span>
<span id="cb197-11"><a href="#cb197-11" tabindex="-1"></a>  </span>
<span id="cb197-12"><a href="#cb197-12" tabindex="-1"></a>  <span class="fu">tibble</span>( </span>
<span id="cb197-13"><a href="#cb197-13" tabindex="-1"></a>    <span class="at">ATE_hat =</span> M1_summary[<span class="st">&quot;Z&quot;</span>,<span class="st">&quot;Estimate&quot;</span>], </span>
<span id="cb197-14"><a href="#cb197-14" tabindex="-1"></a>    <span class="at">SE_hat =</span> M1_summary[<span class="st">&quot;Z&quot;</span>,<span class="st">&quot;Std. Error&quot;</span>], </span>
<span id="cb197-15"><a href="#cb197-15" tabindex="-1"></a>    <span class="at">p_value =</span> M1_summary[<span class="st">&quot;Z&quot;</span>, <span class="st">&quot;Pr(&gt;|t|)&quot;</span>] </span>
<span id="cb197-16"><a href="#cb197-16" tabindex="-1"></a>  )</span>
<span id="cb197-17"><a href="#cb197-17" tabindex="-1"></a>}</span></code></pre></div>
<p>Setting <code>all_results</code> to <code>TRUE</code> will return the entire function; keeping it at the default value of <code>FALSE</code> will return the same output as the other functions.
Now let’s apply the estimation function to a very large dataset, with variation in cluster sizes.
We set <code>gamma_2 = 0</code> so that the estimation model is correctly specified:</p>
<div class="sourceCode" id="cb198"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb198-1"><a href="#cb198-1" tabindex="-1"></a>dat <span class="ot">&lt;-</span> <span class="fu">gen_cluster_RCT</span>( </span>
<span id="cb198-2"><a href="#cb198-2" tabindex="-1"></a>  <span class="at">J=</span><span class="dv">5000</span>, <span class="at">n_bar =</span> <span class="dv">20</span>, <span class="at">alpha =</span> <span class="fl">0.9</span>, <span class="at">p =</span> <span class="dv">2</span> <span class="sc">/</span> <span class="dv">3</span>, </span>
<span id="cb198-3"><a href="#cb198-3" tabindex="-1"></a>  <span class="at">gamma_0 =</span> <span class="dv">2</span>, <span class="at">gamma_1 =</span> <span class="fl">0.30</span>, <span class="at">gamma_2 =</span> <span class="dv">0</span>,</span>
<span id="cb198-4"><a href="#cb198-4" tabindex="-1"></a>  <span class="at">sigma2_u =</span> <span class="fl">0.4</span>, <span class="at">sigma2_e =</span> <span class="fl">0.6</span></span>
<span id="cb198-5"><a href="#cb198-5" tabindex="-1"></a>)</span>
<span id="cb198-6"><a href="#cb198-6" tabindex="-1"></a></span>
<span id="cb198-7"><a href="#cb198-7" tabindex="-1"></a><span class="fu">analysis_MLM</span>(dat, <span class="at">all_results =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<pre><code>## Linear mixed model fit by REML. t-tests use
##   Satterthwaite&#39;s method [lmerModLmerTest]
## Formula: Yobs ~ 1 + Z + (1 | sid)
##    Data: dat
## 
## REML criterion at convergence: 242678
## 
## Scaled residuals: 
##     Min      1Q  Median      3Q     Max 
## -4.3080 -0.6581  0.0007  0.6594  4.2134 
## 
## Random effects:
##  Groups   Name        Variance Std.Dev.
##  sid      (Intercept) 0.3972   0.6302  
##  Residual             0.6030   0.7765  
## Number of obs: 98772, groups:  sid, 5000
## 
## Fixed effects:
##              Estimate Std. Error        df
## (Intercept) 2.017e+00  1.636e-02 4.969e+03
## Z           2.838e-01  2.003e-02 4.964e+03
##             t value Pr(&gt;|t|)    
## (Intercept)  123.29   &lt;2e-16 ***
## Z             14.17   &lt;2e-16 ***
## ---
## Signif. codes:  
## 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Correlation of Fixed Effects:
##   (Intr)
## Z -0.817</code></pre>
<p>The intercept and treatment effect coefficient estimates are very close to their true parameter values, as are the estimated school-level variance and student-level residual variance.
This all gives some assurance that the <code>analysis_MLM()</code> function is working properly.</p>
<p>Of course, it is important to bear in mind that these tests are only partial verifications.
With the algebraic test, we’ve checked that the functions seem to be working properly for scenarios with equal school sizes, but they still might have errors that only appear when school sizes vary.
Likewise, <code>analysis_MLM()</code> seems to be working properly for very large datasets, but our test does not rule out the possibility of bugs that only crawl out when <span class="math inline">\(J\)</span> is small.
Our large-sample test also relies on the correctness of the <code>gen_cluster_RCT()</code> function;
if we had seen a discrepancy between parameters and estimates from the multilevel model, it could have been because of a problem with the data-generation function rather than with the estimation function.</p>
<p>These limitations are typical of what can be accomplished through tests based on theoretical results, because theoretical results typically only hold under specific conditions.
After all, if we had comprehensive theoretical results, we would not need to simulate anything in the first place!
Nonetheless, it is good to work through such tests to the extent that relevant theory is available for the problem you are studying.</p>
</div>
<div id="checking-with-simulations" class="section level3 hasAnchor" number="7.3.3">
<h3 class="hasAnchor"><span class="header-section-number">7.3.3</span> Checking with simulations<a href="#checking-with-simulations" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Checking, debugging, and revising should not be limited to when you are initially developing estimation functions.
It often happens that later steps in the process of conducting a simulation will reveal problems with the code for earlier steps.
For instance, once you have run the data-generating and estimation steps repeatedly, calculated performance summaries, and created some graphs of the results, you might find an unusual or anomolous pattern in the performance of an estimator.
This might be a legitimate result—it might be that the estimator really does behave weirdly or not work well—or it might be due to a problem in how you implemented the estimator or data-generating process.
When faced with an unusual pattern, we recommend revisiting the estimation code to double check for bugs and also thinking further about what might lead to the anomoly.
Further exploration might lead you to a deeper understanding of how a method works and perhaps even an idea for how to improve the estimator or refine the data-generating process.</p>
<p>A good illustration of this process comes from one of Luke’s past research projects (see <span class="citation">Pashley, Keele, and Miratrix (<a href="#ref-pashley2024improving">2024</a>)</span>), in which he and other co-authors were working on a way to improve Instrumental Variable (IV) estimation using post-stratification.
The method they studied involved grouping units based on a covariate that predicts compliance status, then calculating estimates within each group, then summarizing the estimates across groups.
They used simulations to see whether this method would improve the accuracy of the overall summary effect estimate.
In the first simulation, the estimates were full of NAs and odd results because the estimation function failed to account for what happens in groups of observations where the number of compliers was estimated to be zero.
After repairing that problem and re-running everything, the simulation results still indicated serious and unexpected bias, which turned out to be due to an error in how the estimation function implemented the step of summarizing estimates across groups.
After again correcting and re-running, the simulation results showed that the gains in accuracy from this new method were minimal, even when the groups were formed based on a variable that was almost perfectly predictive of compliance status.
Eventually, we understood that the groups with very few compliers produced such unstable estimates that they spoiled the overall average estimate.
This inspired us to revise our estimation strategy and introduce a method that dropped or down-weighted strata with few compliers, which ultimately helped us to strengthen the contribution of our work.</p>
<p>As this experience highlights, simulations seldom follow a single, well-defined trajectory.
The point of conducting simulations is to help us, as researchers, learn about estimation methods so that we can analyze real data better.
What we learn from simulation gives us a better understanding of the methods (potentially including a better understanding of theoretical results), leading to ideas about better methods to create new scenarios to explore in further simulations.
Of course, at some point one needs to step off this merry-go-round, write up the findings, cook dinner, and clean the bathroom.
But, just like many other research endeavors, simulations follow a highly iterative process.</p>
</div>
</div>
<div id="handling-errors-warnings-and-other-hiccups" class="section level2 hasAnchor" number="7.4">
<h2 class="hasAnchor"><span class="header-section-number">7.4</span> Handling errors, warnings, and other hiccups<a href="#handling-errors-warnings-and-other-hiccups" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Especially when working with more advanced estimation methods, it is possible that your estimation function will fail, throw an error, or return something uninterpretable for certain input datasets.
For instance, maximum likelihood estimation often requires iterative, numerical optimization algorithms that sometimes fail to converge.
This might happen rarely enough that it takes a while to even notice that it is a problem, but even quite rare things can occur when you run simulations with many thousands of repetitions.
Less dire but still annoying, your estimation function might generate warnings, which can pile up if you are running many repetitions.
In some cases, such warnings might also signal that the estimator produced a bad result, and
it may not be clear whether we should retain this result (or include it in overall performance assessments).
After all, the function tried to warn us that something is off!</p>
<p>Errors and warnings in estimation functions pose two problems, one purely technical and one conceptual.
On a technical level, R functions stop running if they hit errors (though not warnings), so we need ways to handle the errors in order to get our simulations up and running.
On a conceptual level, we need to decide how to use the information contained in errors and warnings, whether that be by further elaborating the estimation procedures to address different contingencies or by evaluating the performance of the estimators in a way that appropriately accounts for errors.
We consider each of the problems here, then revisit the conceptual considerations in Chapter @ref(performance-criteria).</p>
<div id="capturing-errors-and-warnings" class="section level3 hasAnchor" number="7.4.1">
<h3 class="hasAnchor"><span class="header-section-number">7.4.1</span> Capturing errors and warnings<a href="#capturing-errors-and-warnings" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Some estimation functions will require complicated or stochastic calculations that can sometimes produce errors.
Intermittent errors can really be annoying and time-consuming if not addressed.
To protect yourself, it is good practice to anticipate potential errors, preventing them from stopping code execution and allowing your simulations to keep running.
We will demonstrate some techniques for error-handling using tools from the <code>purrr</code> package.</p>
<p>For illustrative purposes, consider the following error-prone function that sometimes returns what we want, sometimes returns <code>NaN</code> due to taking the square root of a negative number, and sometimes crashes completely because <code>broken_code()</code> does not exist:</p>
<div class="sourceCode" id="cb200"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb200-1"><a href="#cb200-1" tabindex="-1"></a>my_complex_function <span class="ot">=</span> <span class="cf">function</span>( param ) {</span>
<span id="cb200-2"><a href="#cb200-2" tabindex="-1"></a>    </span>
<span id="cb200-3"><a href="#cb200-3" tabindex="-1"></a>    vals <span class="ot">=</span> <span class="fu">rnorm</span>( param, <span class="at">mean =</span> <span class="fl">0.5</span> )</span>
<span id="cb200-4"><a href="#cb200-4" tabindex="-1"></a>    <span class="cf">if</span> ( <span class="fu">sum</span>( vals ) <span class="sc">&gt;</span> <span class="dv">5</span> ) {</span>
<span id="cb200-5"><a href="#cb200-5" tabindex="-1"></a>        <span class="fu">broken_code</span>( <span class="dv">4</span> )</span>
<span id="cb200-6"><a href="#cb200-6" tabindex="-1"></a>    } <span class="cf">else</span> {</span>
<span id="cb200-7"><a href="#cb200-7" tabindex="-1"></a>        <span class="fu">sqrt</span>( <span class="fu">sum</span>( vals ) <span class="sc">*</span> <span class="fu">sign</span>( vals )[[<span class="dv">1</span>]] )</span>
<span id="cb200-8"><a href="#cb200-8" tabindex="-1"></a>    }</span>
<span id="cb200-9"><a href="#cb200-9" tabindex="-1"></a>}</span></code></pre></div>
<p>Running it produces some results and an occasional warning, and some errors:</p>
<div class="sourceCode" id="cb201"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb201-1"><a href="#cb201-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">3</span>)</span>
<span id="cb201-2"><a href="#cb201-2" tabindex="-1"></a><span class="fu">my_complex_function</span>( <span class="dv">1</span> )</span></code></pre></div>
<pre><code>## [1] 0.6796568</code></pre>
<div class="sourceCode" id="cb203"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb203-1"><a href="#cb203-1" tabindex="-1"></a><span class="fu">my_complex_function</span>( <span class="dv">10</span> )</span></code></pre></div>
<pre><code>## [1] 2.132087</code></pre>
<div class="sourceCode" id="cb205"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb205-1"><a href="#cb205-1" tabindex="-1"></a><span class="fu">my_complex_function</span>( <span class="dv">5</span> )</span></code></pre></div>
<pre><code>## Warning in sqrt(sum(vals) * sign(vals)[[1]]):
## NaNs produced</code></pre>
<pre><code>## [1] NaN</code></pre>
<p>Running it many times produces warnings, then an error:</p>
<div class="sourceCode" id="cb208"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb208-1"><a href="#cb208-1" tabindex="-1"></a>resu <span class="ot">&lt;-</span> <span class="fu">replicate</span>(<span class="dv">20</span>, <span class="fu">my_complex_function</span>( <span class="dv">7</span> ))</span></code></pre></div>
<pre><code>## Warning in sqrt(sum(vals) * sign(vals)[[1]]):
## NaNs produced
## Warning in sqrt(sum(vals) * sign(vals)[[1]]):
## NaNs produced</code></pre>
<pre><code>## Error in broken_code(4): could not find function &quot;broken_code&quot;</code></pre>
<p>The <code>purrr</code> package includes a function called <code>safely</code> that makes it easy to trap errors.
To use it, we feed the estimation function into <code>safely()</code> to create a new version:</p>
<div class="sourceCode" id="cb211"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb211-1"><a href="#cb211-1" tabindex="-1"></a>my_safe_function <span class="ot">&lt;-</span> <span class="fu">safely</span>( my_complex_function, <span class="at">otherwise =</span> <span class="cn">NA</span> )</span>
<span id="cb211-2"><a href="#cb211-2" tabindex="-1"></a><span class="fu">my_safe_function</span>( <span class="dv">7</span> )</span></code></pre></div>
<pre><code>## $result
## [1] 2.175561
## 
## $error
## NULL</code></pre>
<p>The safe version of the function returns a list with two entries: the result (or NULL if there was an error), and the error message (or NULL if there was no error).
<code>safely()</code> is an example of a <em>functional</em> (or an <em>abverb</em>), which takes a function and returns a new function that does something slightly different.
We include <code>otherwise = NA</code> so we always get a result, rather than a <code>NULL</code> when there is an error.</p>
<p>We can use the safe function repeatedly and it will always return a result:</p>
<div class="sourceCode" id="cb213"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb213-1"><a href="#cb213-1" tabindex="-1"></a>resu <span class="ot">&lt;-</span> <span class="fu">replicate</span>(<span class="dv">20</span>, <span class="fu">my_safe_function</span>( <span class="dv">7</span> ), <span class="at">simplify =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<pre><code>## Warning in sqrt(sum(vals) * sign(vals)[[1]]):
## NaNs produced
## Warning in sqrt(sum(vals) * sign(vals)[[1]]):
## NaNs produced
## Warning in sqrt(sum(vals) * sign(vals)[[1]]):
## NaNs produced
## Warning in sqrt(sum(vals) * sign(vals)[[1]]):
## NaNs produced
## Warning in sqrt(sum(vals) * sign(vals)[[1]]):
## NaNs produced</code></pre>
<div class="sourceCode" id="cb215"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb215-1"><a href="#cb215-1" tabindex="-1"></a>resu <span class="ot">&lt;-</span> <span class="fu">transpose</span>( resu )</span>
<span id="cb215-2"><a href="#cb215-2" tabindex="-1"></a><span class="fu">unlist</span>(resu<span class="sc">$</span>result)</span></code></pre></div>
<pre><code>##  [1] 1.3870195 0.5638654        NA 1.6995292
##  [5]        NA        NA       NaN 2.2121710
##  [9]        NA       NaN       NaN 1.8801925
## [13]       NaN 1.9154618       NaN        NA
## [17] 2.2245636        NA        NA 0.8854747</code></pre>
<p>The <code>transpose()</code> function takes a list of lists, and reorganizes them to give you a list of all the first elements, a list of all the second elements, etc.
This is very powerful for wrangling data, because then we can make a tibble with list columns as so:</p>
<div class="sourceCode" id="cb217"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb217-1"><a href="#cb217-1" tabindex="-1"></a>tb <span class="ot">&lt;-</span> <span class="fu">tibble</span>( <span class="at">result =</span> <span class="fu">unlist</span>( resu<span class="sc">$</span>result ), <span class="at">error =</span> resu<span class="sc">$</span>error )</span>
<span id="cb217-2"><a href="#cb217-2" tabindex="-1"></a><span class="fu">head</span>( tb, <span class="at">n =</span> <span class="dv">4</span> )</span></code></pre></div>
<pre><code>## # A tibble: 4 × 2
##   result error     
##    &lt;dbl&gt; &lt;list&gt;    
## 1  1.39  &lt;NULL&gt;    
## 2  0.564 &lt;NULL&gt;    
## 3 NA     &lt;smplErrr&gt;
## 4  1.70  &lt;NULL&gt;</code></pre>
<p>The <code>purrr</code> package includes several other functionals that are useful for handling errors and warnings.
The <code>possibly()</code> wrapper will try to run a function and will return a specified value in the event of an error:</p>
<div class="sourceCode" id="cb219"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb219-1"><a href="#cb219-1" tabindex="-1"></a>my_possible_function <span class="ot">&lt;-</span> <span class="fu">possibly</span>( my_complex_function, <span class="at">otherwise =</span> <span class="cn">NA</span> )</span>
<span id="cb219-2"><a href="#cb219-2" tabindex="-1"></a><span class="fu">my_possible_function</span>( <span class="dv">7</span> )</span></code></pre></div>
<pre><code>## [1] 1.506734</code></pre>
<div class="sourceCode" id="cb221"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb221-1"><a href="#cb221-1" tabindex="-1"></a>rs <span class="ot">&lt;-</span> <span class="fu">replicate</span>(<span class="dv">20</span>, <span class="fu">my_possible_function</span>( <span class="dv">7</span> ))</span></code></pre></div>
<pre><code>## Warning in sqrt(sum(vals) * sign(vals)[[1]]):
## NaNs produced
## Warning in sqrt(sum(vals) * sign(vals)[[1]]):
## NaNs produced
## Warning in sqrt(sum(vals) * sign(vals)[[1]]):
## NaNs produced</code></pre>
<div class="sourceCode" id="cb223"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb223-1"><a href="#cb223-1" tabindex="-1"></a>rs</span></code></pre></div>
<pre><code>##  [1]        NA 0.7023915 0.9495728        NA
##  [5]        NA 1.8784947 0.9838187        NA
##  [9]        NA 1.7676572 1.4809897        NA
## [13] 2.1019082        NA       NaN       NaN
## [17] 1.8629289 1.3467997       NaN 1.3017348</code></pre>
<p>It works as a simpler version of <code>safely()</code>, which does not record error messages.</p>
<p>The <code>quietly</code> functional leads to results that are bundled together with any console output, warnings, and messages, rather than printing anything to the console:</p>
<div class="sourceCode" id="cb225"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb225-1"><a href="#cb225-1" tabindex="-1"></a>my_quiet_function <span class="ot">&lt;-</span> <span class="fu">quietly</span>( my_complex_function )</span>
<span id="cb225-2"><a href="#cb225-2" tabindex="-1"></a></span>
<span id="cb225-3"><a href="#cb225-3" tabindex="-1"></a><span class="fu">my_quiet_function</span>( <span class="dv">1</span> )</span></code></pre></div>
<pre><code>## $result
## [1] 0.1724504
## 
## $output
## [1] &quot;&quot;
## 
## $warnings
## character(0)
## 
## $messages
## character(0)</code></pre>
<p>This can be especially useful to reduce extraneous printing in a simulation, which can slow down code execution more than you might expect.
However, <code>quietly()</code> does not trap errors:</p>
<div class="sourceCode" id="cb227"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb227-1"><a href="#cb227-1" tabindex="-1"></a>rs <span class="ot">&lt;-</span> <span class="fu">replicate</span>(<span class="dv">20</span>, <span class="fu">my_quiet_function</span>( <span class="dv">7</span> ))</span></code></pre></div>
<pre><code>## Error in broken_code(4): could not find function &quot;broken_code&quot;</code></pre>
<p>Double-wrapping your function will handle both errors and warnings, but the structure it produces gets a bit complicated:</p>
<div class="sourceCode" id="cb229"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb229-1"><a href="#cb229-1" tabindex="-1"></a>my_safe_quiet_function <span class="ot">&lt;-</span> <span class="fu">quietly</span>( <span class="fu">safely</span>( my_complex_function, <span class="at">otherwise =</span> <span class="cn">NA</span> ) )</span>
<span id="cb229-2"><a href="#cb229-2" tabindex="-1"></a><span class="fu">my_safe_quiet_function</span>(<span class="dv">7</span>)</span></code></pre></div>
<pre><code>## $result
## $result$result
## [1] NA
## 
## $result$error
## &lt;simpleError in broken_code(4): could not find function &quot;broken_code&quot;&gt;
## 
## 
## $output
## [1] &quot;&quot;
## 
## $warnings
## character(0)
## 
## $messages
## character(0)</code></pre>
<p>Even though the result is a bit of a mess, this structure provides all the pieces that we need to do further calculations on the result (when available), along with errors, warnings, and other output.</p>
<p>To see how this works in practice, we will adapt our <code>analysis_MLM()</code> function, which makes use of <code>lmer()</code> for fitting a multilevel model.
Currently, the estimation function sometimes prints messages to the console:</p>
<div class="sourceCode" id="cb231"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb231-1"><a href="#cb231-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">101012</span>)  <span class="co"># (I picked this to show a warning.)</span></span>
<span id="cb231-2"><a href="#cb231-2" tabindex="-1"></a>dat <span class="ot">&lt;-</span> <span class="fu">gen_cluster_RCT</span>( <span class="at">J =</span> <span class="dv">50</span>, <span class="at">n_bar =</span> <span class="dv">100</span>, <span class="at">sigma2_u =</span> <span class="dv">0</span> )</span>
<span id="cb231-3"><a href="#cb231-3" tabindex="-1"></a>mod <span class="ot">&lt;-</span> <span class="fu">analysis_MLM</span>(dat)</span></code></pre></div>
<pre><code>## boundary (singular) fit: see help(&#39;isSingular&#39;)</code></pre>
<p>Wrapping <code>lmer()</code> with <code>quietly()</code> makes it possible to catch such output and store it along with other results, as in the following:</p>
<div class="sourceCode" id="cb233"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb233-1"><a href="#cb233-1" tabindex="-1"></a>quiet_lmer <span class="ot">&lt;-</span> <span class="fu">quietly</span>(lme4<span class="sc">::</span>lmer)</span>
<span id="cb233-2"><a href="#cb233-2" tabindex="-1"></a>qmod <span class="ot">&lt;-</span> <span class="fu">quiet_lmer</span>( Yobs <span class="sc">~</span> <span class="dv">1</span> <span class="sc">+</span> Z <span class="sc">+</span> (<span class="dv">1</span><span class="sc">|</span>sid), <span class="at">data=</span>dat )</span>
<span id="cb233-3"><a href="#cb233-3" tabindex="-1"></a>qmod</span></code></pre></div>
<pre><code>## $result
## Linear mixed model fit by REML [&#39;lmerMod&#39;]
## Formula: Yobs ~ 1 + Z + (1 | sid)
##    Data: ..2
## REML criterion at convergence: 14026.44
## Random effects:
##  Groups   Name        Std.Dev.
##  sid      (Intercept) 0.0000  
##  Residual             0.9828  
## Number of obs: 5000, groups:  sid, 50
## Fixed Effects:
## (Intercept)            Z  
##   -0.013930    -0.008804  
## optimizer (nloptwrap) convergence code: 0 (OK) ; 0 optimizer warnings; 1 lme4 warnings 
## 
## $output
## [1] &quot;&quot;
## 
## $warnings
## character(0)
## 
## $messages
## [1] &quot;boundary (singular) fit: see help(&#39;isSingular&#39;)\n&quot;</code></pre>
<p>However, the <code>lmerTest</code> package does not like the structure of the results, and produces an error:</p>
<div class="sourceCode" id="cb235"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb235-1"><a href="#cb235-1" tabindex="-1"></a>lmerTest<span class="sc">::</span><span class="fu">as_lmerModLmerTest</span>(qmod<span class="sc">$</span>result)</span></code></pre></div>
<pre><code>## Error in lmerTest::as_lmerModLmerTest(qmod$result): Unable to extract deviance function from model fit</code></pre>
<!--All of this seems to have gotten tremendously complicated for this part of the book.  Wasn't it simpler before?  E.g., why need the double-wrapping here?  And why not just wrap the originally implemented method to avoid the weirdness with lmertest? -->
<p>We can side-step this by combining <code>as_lmerModLmerTest()</code> and <code>lmer()</code> into a single function.
While we are at it, we also layer on <code>summary()</code>.
To do so, we use the <code>compose()</code> functional from <code>purrr</code>, which takes a list of functions and wraps them into one:</p>
<div class="sourceCode" id="cb237"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb237-1"><a href="#cb237-1" tabindex="-1"></a>lmer_with_test <span class="ot">&lt;-</span> purrr<span class="sc">::</span><span class="fu">compose</span>(</span>
<span id="cb237-2"><a href="#cb237-2" tabindex="-1"></a>  summary,</span>
<span id="cb237-3"><a href="#cb237-3" tabindex="-1"></a>  lmerTest<span class="sc">::</span>as_lmerModLmerTest, </span>
<span id="cb237-4"><a href="#cb237-4" tabindex="-1"></a>  lme4<span class="sc">::</span>lmer</span>
<span id="cb237-5"><a href="#cb237-5" tabindex="-1"></a>)</span></code></pre></div>
<p>The resulting <code>lmer_with_test()</code> function acts as if we were calling <code>lmer()</code>, then feeding the result into <code>as_lmerModLmerTest()</code>, then feeding the result into <code>summary()</code>.
We then wrap the combination function with <code>safely()</code> and <code>quietly()</code>:</p>
<div class="sourceCode" id="cb238"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb238-1"><a href="#cb238-1" tabindex="-1"></a>quiet_safe_lmer <span class="ot">&lt;-</span> purrr<span class="sc">::</span><span class="fu">quietly</span>(purrr<span class="sc">::</span><span class="fu">safely</span>(lmer_with_test))</span></code></pre></div>
<p>Now we can use our suitably quieted and safe function in a new version of the estimation function:</p>
<div class="sourceCode" id="cb239"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb239-1"><a href="#cb239-1" tabindex="-1"></a>analysis_MLM_safe <span class="ot">&lt;-</span> <span class="cf">function</span>( dat, <span class="at">all_results =</span> <span class="cn">FALSE</span> ) {</span>
<span id="cb239-2"><a href="#cb239-2" tabindex="-1"></a>  </span>
<span id="cb239-3"><a href="#cb239-3" tabindex="-1"></a>  M1 <span class="ot">&lt;-</span> <span class="fu">quiet_safe_lmer</span>( Yobs <span class="sc">~</span> <span class="dv">1</span> <span class="sc">+</span> Z <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> sid), <span class="at">data=</span>dat )</span>
<span id="cb239-4"><a href="#cb239-4" tabindex="-1"></a>  </span>
<span id="cb239-5"><a href="#cb239-5" tabindex="-1"></a>  <span class="cf">if</span> (all_results) {</span>
<span id="cb239-6"><a href="#cb239-6" tabindex="-1"></a>    <span class="fu">return</span>(M1)</span>
<span id="cb239-7"><a href="#cb239-7" tabindex="-1"></a>  } </span>
<span id="cb239-8"><a href="#cb239-8" tabindex="-1"></a>  </span>
<span id="cb239-9"><a href="#cb239-9" tabindex="-1"></a>  message <span class="ot">&lt;-</span> <span class="fu">ifelse</span>( <span class="fu">length</span>( M1<span class="sc">$</span>message ) <span class="sc">&gt;</span> <span class="dv">0</span>, M1<span class="sc">$</span>message, <span class="cn">NA_character_</span> )</span>
<span id="cb239-10"><a href="#cb239-10" tabindex="-1"></a>  warning <span class="ot">&lt;-</span> <span class="fu">ifelse</span>( <span class="fu">length</span>( M1<span class="sc">$</span>warning ) <span class="sc">&gt;</span> <span class="dv">0</span>, M1<span class="sc">$</span>warning, <span class="cn">NA_character_</span> )</span>
<span id="cb239-11"><a href="#cb239-11" tabindex="-1"></a>  error <span class="ot">&lt;-</span> <span class="fu">ifelse</span>( <span class="fu">length</span>( M1<span class="sc">$</span>result<span class="sc">$</span>error) <span class="sc">&gt;</span> <span class="dv">0</span>, M1<span class="sc">$</span>result<span class="sc">$</span>error<span class="sc">$</span>message, <span class="cn">NA_character_</span> )</span>
<span id="cb239-12"><a href="#cb239-12" tabindex="-1"></a>  </span>
<span id="cb239-13"><a href="#cb239-13" tabindex="-1"></a>  <span class="fu">tibble</span>( </span>
<span id="cb239-14"><a href="#cb239-14" tabindex="-1"></a>    <span class="at">ATE_hat =</span> M1<span class="sc">$</span>result<span class="sc">$</span>result<span class="sc">$</span>coefficients[<span class="st">&quot;Z&quot;</span>,<span class="st">&quot;Estimate&quot;</span>], </span>
<span id="cb239-15"><a href="#cb239-15" tabindex="-1"></a>    <span class="at">SE_hat =</span> M1<span class="sc">$</span>result<span class="sc">$</span>result<span class="sc">$</span>coefficients[<span class="st">&quot;Z&quot;</span>,<span class="st">&quot;Std. Error&quot;</span>], </span>
<span id="cb239-16"><a href="#cb239-16" tabindex="-1"></a>    <span class="at">p_value =</span> M1<span class="sc">$</span>result<span class="sc">$</span>result<span class="sc">$</span>coefficients[<span class="st">&quot;Z&quot;</span>, <span class="st">&quot;Pr(&gt;|t|)&quot;</span>],</span>
<span id="cb239-17"><a href="#cb239-17" tabindex="-1"></a>    <span class="at">message =</span> message,</span>
<span id="cb239-18"><a href="#cb239-18" tabindex="-1"></a>    <span class="at">warning =</span> warning,</span>
<span id="cb239-19"><a href="#cb239-19" tabindex="-1"></a>    <span class="at">error =</span> error</span>
<span id="cb239-20"><a href="#cb239-20" tabindex="-1"></a>  )</span>
<span id="cb239-21"><a href="#cb239-21" tabindex="-1"></a>}</span></code></pre></div>
<p>This quiet version runs without extraneous messages:</p>
<div class="sourceCode" id="cb240"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb240-1"><a href="#cb240-1" tabindex="-1"></a>mod <span class="ot">&lt;-</span> <span class="fu">analysis_MLM_safe</span>(dat)</span>
<span id="cb240-2"><a href="#cb240-2" tabindex="-1"></a>mod</span></code></pre></div>
<pre><code>## # A tibble: 1 × 6
##    ATE_hat SE_hat p_value message    warning error
##      &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;   &lt;chr&gt;
## 1 -0.00880 0.0278   0.751 &quot;boundary… &lt;NA&gt;    &lt;NA&gt;</code></pre>
<p>Now we have the estimation results along with any diagnostic information from messages or warnings.
Storing this information will let us evaluate what proportion of the time there was a warning or message, run additional analyses on the subset of replications where there was no such warning, or even modify the estimation procedure to take the diagnostics into account.</p>
</div>
<div id="adapting-for-errors" class="section level3 hasAnchor" number="7.4.2">
<h3 class="hasAnchor"><span class="header-section-number">7.4.2</span> Adapting estimation procedures for errors and warnings<a href="#adapting-for-errors" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>So far, we have seen techniques for handling technical hiccups that occur when data analysis procedures do not always produce results.
But how do we account for the absence of results in a simulation?
In Chapter @ref(performance-criteria), we will delve into the conceptual issues with summarizing the performance of methods that do not always provide an answer.
One of the best solutions to such problems still concerns the formulation of estimation functions, and so we introduce it here.
That solution is to <em>re-define the estimator</em> to include contingencies for handling lack of results.</p>
<p>Consider a data analyst who was planning to apply a fancy statistical model to their data, but then finds that the model does not converge.
What would that analyst do in practice (besides cussing and taking a snack break)?
Rather than giving up entirely, they would probably think of an alternative analysis and attempt to apply it, perhaps by simplifying the model in some way.
To the extent that we can anticipate such possibilities, we can build these error-contingent alternative analyses into our estimation function.</p>
<p>To illustrate, let’s look at an error (a not-particularly-subtle one) that can crop up in the cluster-randomized trial example when clusters are very small:</p>
<div class="sourceCode" id="cb242"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb242-1"><a href="#cb242-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">65842</span>)</span>
<span id="cb242-2"><a href="#cb242-2" tabindex="-1"></a>tiny_dat <span class="ot">&lt;-</span> <span class="fu">gen_cluster_RCT</span>( <span class="at">J =</span> <span class="dv">10</span>, <span class="at">n_bar =</span> <span class="dv">2</span>, <span class="at">alpha =</span> <span class="fl">0.5</span>)</span>
<span id="cb242-3"><a href="#cb242-3" tabindex="-1"></a><span class="fu">analysis_MLM_safe</span>(tiny_dat)</span></code></pre></div>
<pre><code>## # A tibble: 1 × 3
##   message warning error                           
##   &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;                           
## 1 &lt;NA&gt;    &lt;NA&gt;    number of levels of each groupi…</code></pre>
<div class="sourceCode" id="cb244"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb244-1"><a href="#cb244-1" tabindex="-1"></a><span class="fu">table</span>(tiny_dat<span class="sc">$</span>sid)</span></code></pre></div>
<pre><code>## 
##  1  2  3  4  5  6  7  8  9 10 
##  1  1  1  1  1  1  1  1  1  1</code></pre>
<p>The error occurs because all 10 simulated schools include a single student, making it impossible to estimate a random-intercepts multilevel model.
A natural fall-back analysis here would be to estimate an ordinary least squares regression analysis.</p>
<p>Suppose that our imaginary analyst is not especially into nuance, and so will fall back onto ordinary least squares whenever the multilevel model produces an error.
We can express this logic in our estimation function by first catching the error thrown by <code>lmer()</code> and then running an OLS regression in the event an error is thrown:</p>
<div class="sourceCode" id="cb246"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb246-1"><a href="#cb246-1" tabindex="-1"></a>analysis_MLM_contingent <span class="ot">&lt;-</span> <span class="cf">function</span>( dat, <span class="at">all_results =</span> <span class="cn">FALSE</span> ) {</span>
<span id="cb246-2"><a href="#cb246-2" tabindex="-1"></a>  </span>
<span id="cb246-3"><a href="#cb246-3" tabindex="-1"></a>  M1 <span class="ot">&lt;-</span> <span class="fu">quiet_safe_lmer</span>( Yobs <span class="sc">~</span> <span class="dv">1</span> <span class="sc">+</span> Z <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> sid), <span class="at">data=</span>dat )</span>
<span id="cb246-4"><a href="#cb246-4" tabindex="-1"></a>  </span>
<span id="cb246-5"><a href="#cb246-5" tabindex="-1"></a>  <span class="cf">if</span> (all_results) {</span>
<span id="cb246-6"><a href="#cb246-6" tabindex="-1"></a>    <span class="fu">return</span>(M1)</span>
<span id="cb246-7"><a href="#cb246-7" tabindex="-1"></a>  } </span>
<span id="cb246-8"><a href="#cb246-8" tabindex="-1"></a>  </span>
<span id="cb246-9"><a href="#cb246-9" tabindex="-1"></a>  <span class="cf">if</span> (<span class="sc">!</span><span class="fu">is.null</span>(M1<span class="sc">$</span>result<span class="sc">$</span>result)) { </span>
<span id="cb246-10"><a href="#cb246-10" tabindex="-1"></a>    <span class="co"># If lmer() returns a result</span></span>
<span id="cb246-11"><a href="#cb246-11" tabindex="-1"></a>    res <span class="ot">&lt;-</span> <span class="fu">tibble</span>( </span>
<span id="cb246-12"><a href="#cb246-12" tabindex="-1"></a>      <span class="at">ATE_hat =</span> M1<span class="sc">$</span>result<span class="sc">$</span>result<span class="sc">$</span>coefficients[<span class="st">&quot;Z&quot;</span>,<span class="st">&quot;Estimate&quot;</span>], </span>
<span id="cb246-13"><a href="#cb246-13" tabindex="-1"></a>      <span class="at">SE_hat =</span> M1<span class="sc">$</span>result<span class="sc">$</span>result<span class="sc">$</span>coefficients[<span class="st">&quot;Z&quot;</span>,<span class="st">&quot;Std. Error&quot;</span>], </span>
<span id="cb246-14"><a href="#cb246-14" tabindex="-1"></a>      <span class="at">p_value =</span> M1<span class="sc">$</span>result<span class="sc">$</span>result<span class="sc">$</span>coefficients[<span class="st">&quot;Z&quot;</span>, <span class="st">&quot;Pr(&gt;|t|)&quot;</span>],</span>
<span id="cb246-15"><a href="#cb246-15" tabindex="-1"></a>    )</span>
<span id="cb246-16"><a href="#cb246-16" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb246-17"><a href="#cb246-17" tabindex="-1"></a>    <span class="co"># If lmer() errors, fall back on OLS</span></span>
<span id="cb246-18"><a href="#cb246-18" tabindex="-1"></a>    M_ols <span class="ot">&lt;-</span> <span class="fu">summary</span>(<span class="fu">lm</span>(Yobs <span class="sc">~</span> Z, <span class="at">data =</span> dat))</span>
<span id="cb246-19"><a href="#cb246-19" tabindex="-1"></a>    res <span class="ot">&lt;-</span> <span class="fu">tibble</span>( </span>
<span id="cb246-20"><a href="#cb246-20" tabindex="-1"></a>      <span class="at">ATE_hat =</span> M_ols<span class="sc">$</span>coefficients[<span class="st">&quot;Z&quot;</span>,<span class="st">&quot;Estimate&quot;</span>], </span>
<span id="cb246-21"><a href="#cb246-21" tabindex="-1"></a>      <span class="at">SE_hat =</span> M_ols<span class="sc">$</span>coefficients[<span class="st">&quot;Z&quot;</span>, <span class="st">&quot;Std. Error&quot;</span>], </span>
<span id="cb246-22"><a href="#cb246-22" tabindex="-1"></a>      <span class="at">p_value =</span> M_ols<span class="sc">$</span>coefficients[<span class="st">&quot;Z&quot;</span>,<span class="st">&quot;Pr(&gt;|t|)&quot;</span>]</span>
<span id="cb246-23"><a href="#cb246-23" tabindex="-1"></a>    )</span>
<span id="cb246-24"><a href="#cb246-24" tabindex="-1"></a>  }</span>
<span id="cb246-25"><a href="#cb246-25" tabindex="-1"></a></span>
<span id="cb246-26"><a href="#cb246-26" tabindex="-1"></a>  <span class="co"># Store original messages, warnings, errors  </span></span>
<span id="cb246-27"><a href="#cb246-27" tabindex="-1"></a>  res<span class="sc">$</span>message <span class="ot">&lt;-</span> <span class="fu">ifelse</span>( <span class="fu">length</span>( M1<span class="sc">$</span>message ) <span class="sc">&gt;</span> <span class="dv">0</span>, M1<span class="sc">$</span>message, <span class="cn">NA_character_</span> )</span>
<span id="cb246-28"><a href="#cb246-28" tabindex="-1"></a>  res<span class="sc">$</span>warning <span class="ot">&lt;-</span> <span class="fu">ifelse</span>( <span class="fu">length</span>( M1<span class="sc">$</span>warning ) <span class="sc">&gt;</span> <span class="dv">0</span>, M1<span class="sc">$</span>warning, <span class="cn">NA_character_</span> )</span>
<span id="cb246-29"><a href="#cb246-29" tabindex="-1"></a>  res<span class="sc">$</span>error <span class="ot">&lt;-</span> <span class="fu">ifelse</span>( <span class="fu">length</span>( M1<span class="sc">$</span>result<span class="sc">$</span>error) <span class="sc">&gt;</span> <span class="dv">0</span>, M1<span class="sc">$</span>result<span class="sc">$</span>error<span class="sc">$</span>message, <span class="cn">NA_character_</span> )</span>
<span id="cb246-30"><a href="#cb246-30" tabindex="-1"></a>  </span>
<span id="cb246-31"><a href="#cb246-31" tabindex="-1"></a>  <span class="fu">return</span>(res)</span>
<span id="cb246-32"><a href="#cb246-32" tabindex="-1"></a>}</span></code></pre></div>
<p>We still store the messages, warnings, and errors from the initial <code>lmer()</code> fit so that we can keep track of how often errors occur.
The function now returns an treatment effect estimate even if <code>lmer()</code> errors:</p>
<div class="sourceCode" id="cb247"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb247-1"><a href="#cb247-1" tabindex="-1"></a><span class="fu">analysis_MLM_contingent</span>(tiny_dat)</span></code></pre></div>
<pre><code>## # A tibble: 1 × 6
##   ATE_hat SE_hat p_value message warning error    
##     &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;    
## 1   0.400  0.603   0.525 &lt;NA&gt;    &lt;NA&gt;    number o…</code></pre>
<p>Of course, we can easily anticipate the conditions under which this particular error will occur: all we need to do is check whether all the clusters are single observations.
Because it is easily anticipated, a better strategy for handling this error is to check <em>before</em> fitting the multilevel model and proceeding accordingly in the event that the clusters are all singletons.
Exercise @ref(contingent-estimator-processing) asks you to implement this approach and further refine this contingent analysis strategy.</p>
<p>Adapting estimation functions to address errors can be an effective—and often very interesting—strategy for studying the performance of estimation methods.
Rather than studying the performance of a data-analysis method that is only sometimes well-defined, we shift to studying a stylized cognitive model for the analyst’s decision-making process, which handles contingencies that might crop up whether analyzing simulated data or real empirical data.
Of course, studying such a model is only interesting to the extent that the decision-making process it implements is a plausible representation of what an analyst might actually do in practice.</p>
<p>The adaptive estimation approach does lead to more complex estimation functions, which entail implementing multiple estimation methods and a set of decision rules for applying them.
Often, the set of contingencies that need to be handled will not be immediately obvious, so you may find that you need to build and refine the decision rules as you learn more about how they work.
Running an estimation procedure over multiple, simulated datasets is an excellent (if aggravating!) way to identify errors and edge cases.
We turn to procedures for doing so in the next chapter.</p>
</div>
</div>
<div id="exercises-4" class="section level2 hasAnchor" number="7.5">
<h2 class="hasAnchor"><span class="header-section-number">7.5</span> Exercises<a href="#exercises-4" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<div id="BFFs-forever" class="section level3 hasAnchor" number="7.5.1">
<h3 class="hasAnchor"><span class="header-section-number">7.5.1</span> More Heteroskedastic ANOVA<a href="#BFFs-forever" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>In the classic simulation by Brown and Forsythe (1974), they not only looked at the performance of the homoskedastic ANOVA-F test and Welch’s heteroskedastic-F test, they also proposed their own new hypothesis testing procedure.</p>
<ol style="list-style-type: decimal">
<li><p>Write a function that implements the Brown-Forsythe F* test (the BFF* test!) as described on p. 130 of Brown and Forsythe (1974), using the following code skeleton:</p>
<div class="sourceCode" id="cb249"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb249-1"><a href="#cb249-1" tabindex="-1"></a>BF_F <span class="ot">&lt;-</span> <span class="cf">function</span>( data ) {</span>
<span id="cb249-2"><a href="#cb249-2" tabindex="-1"></a></span>
<span id="cb249-3"><a href="#cb249-3" tabindex="-1"></a>  <span class="co"># fill in the guts here</span></span>
<span id="cb249-4"><a href="#cb249-4" tabindex="-1"></a></span>
<span id="cb249-5"><a href="#cb249-5" tabindex="-1"></a>  <span class="fu">return</span>(pval)</span>
<span id="cb249-6"><a href="#cb249-6" tabindex="-1"></a>}</span></code></pre></div>
<p>Run the following code to check that your function produces a result:</p>
<div class="sourceCode" id="cb250"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb250-1"><a href="#cb250-1" tabindex="-1"></a>sim_data <span class="ot">&lt;-</span> <span class="fu">generate_ANOVA_data</span>(</span>
<span id="cb250-2"><a href="#cb250-2" tabindex="-1"></a>  <span class="at">mu =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">6</span>), </span>
<span id="cb250-3"><a href="#cb250-3" tabindex="-1"></a>  <span class="at">sigma_sq =</span> <span class="fu">c</span>(<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">1</span>),</span>
<span id="cb250-4"><a href="#cb250-4" tabindex="-1"></a>  <span class="at">sample_size =</span> <span class="fu">c</span>(<span class="dv">3</span>, <span class="dv">6</span>, <span class="dv">2</span>, <span class="dv">4</span>)</span>
<span id="cb250-5"><a href="#cb250-5" tabindex="-1"></a>)</span>
<span id="cb250-6"><a href="#cb250-6" tabindex="-1"></a><span class="fu">BF_F</span>( sim_data )</span></code></pre></div></li>
<li><p>Try calling your <code>BF_F</code> function on a variety of datasets of different sizes and shapes, to make sure it works. What kinds of datasets should you test out?</p></li>
<li><p>Add the BFF* test into the output of <code>Welch_ANOVA_F()</code> by calling your <code>BF_F()</code> function inside the body of <code>Welch_ANOVA_F()</code>.</p></li>
<li><p>The <a href="https://cran.r-project.org/package=onewaytests"><code>onewaytests</code> package</a> implements a variety of different hypothesis testing procedures for one-way ANOVA. Validate your <code>Welch_ANOVA_F()</code> function by comparing the results to the output of the relevant functions from <code>onewaytests</code>.</p></li>
</ol>
</div>
<div id="contingent-testing" class="section level3 hasAnchor" number="7.5.2">
<h3 class="hasAnchor"><span class="header-section-number">7.5.2</span> Contingent testing<a href="#contingent-testing" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>In the one-way ANOVA problem, one approach that an analyst might think to take is to conduct a preliminary significance test for heterogeneity of variances (such as Levene’s test or Bartlett’s test), and then report the <span class="math inline">\(p\)</span>-value from the homoskedastic ANOVA F test if variance heterogeneity is not detected but the <span class="math inline">\(p\)</span>-value from the BFF* test if variance heteogeneity is detected.
Modify the <code>Welch_ANOVA_F()</code> function to return the <span class="math inline">\(p\)</span>-value from this contingent BFF* test in addition to the <span class="math inline">\(p\)</span>-values from the (non-contingent) ANOVA-F, Welch, and BFF* tests.
Include an input option that allows the user to control the <span class="math inline">\(\alpha\)</span> level of the preliminary test for heterogeneity of variances, as in the following skeleton.</p>
<div class="sourceCode" id="cb251"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb251-1"><a href="#cb251-1" tabindex="-1"></a>Welch_ANOVA_F <span class="ot">&lt;-</span> <span class="cf">function</span>( data , <span class="at">pre_alpha =</span> .<span class="dv">05</span>) {</span>
<span id="cb251-2"><a href="#cb251-2" tabindex="-1"></a>  <span class="co"># preliminary test for variance heterogeneity</span></span>
<span id="cb251-3"><a href="#cb251-3" tabindex="-1"></a>  <span class="co"># compute non-contingent F tests for group differences</span></span>
<span id="cb251-4"><a href="#cb251-4" tabindex="-1"></a>  <span class="co"># compute contingent test</span></span>
<span id="cb251-5"><a href="#cb251-5" tabindex="-1"></a>  <span class="co"># compile results</span></span>
<span id="cb251-6"><a href="#cb251-6" tabindex="-1"></a>  <span class="fu">return</span>(result)</span>
<span id="cb251-7"><a href="#cb251-7" tabindex="-1"></a>}</span></code></pre></div>
</div>
<div id="cross-check-CRT-estimators" class="section level3 hasAnchor" number="7.5.3">
<h3 class="hasAnchor"><span class="header-section-number">7.5.3</span> Check the cluster-RCT functions<a href="#cross-check-CRT-estimators" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Section @ref(multiple-estimation-procedures) presented functions implementing several different strategies for estimating an average treatment effect from a cluster-randomized trial.
Write some code to validate these functions by comparing their output to the results of other tools for doing the same calculation.
Use one or more datasets simulated with <code>gen_cluster_RCT()</code>.
For each of these tests, you will need to figure out the appropriate syntax by reading the package documentation.</p>
<ol style="list-style-type: decimal">
<li><p>For <code>analysis_MLM()</code>, check the output by fitting the same model using <code>lme()</code> from the <code>nlme()</code> package or <code>glmmTMB()</code> from the package of the same name.</p></li>
<li><p>For <code>analysis_OLS()</code>, check the output by fitting the linear model using the base R function <code>lm()</code>, then computing standard errors using <code>vcovCL()</code> from the <code>sandwich</code> package. Also compare the output to the results of feeding the fitted model through <code>coef_test()</code> from the <code>clubSandwich</code> package.</p></li>
<li><p>For <code>analysis_agg()</code>, check the output by aggregating the data to the school-level, fitting the linear model using <code>lm()</code>, and computing standard errors using <code>vcovHC()</code> from the <code>sandwich</code> package.</p></li>
</ol>
</div>
<div id="CRT-ANCOVA-estimators" class="section level3 hasAnchor" number="7.5.4">
<h3 class="hasAnchor"><span class="header-section-number">7.5.4</span> Extending the cluster-RCT functions<a href="#CRT-ANCOVA-estimators" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Exercise @ref(cluster-RCT-baseline) from Chapter @ref(data-generating-processes) asked you to extend the data-generating function for the cluster-randomized trial to include generating a student-level covariate, <span class="math inline">\(X\)</span>, that is predictive of the outcome.
Use your modified function to generate a dataset.</p>
<ol style="list-style-type: decimal">
<li><p>Modify the estimation functions from Section @ref(multiple-estimation-procedures) to use models that include the covariate as a predictor.</p></li>
<li><p>Further extend the functions to include an input argument for the set of predictors to be included in the model, as in the following skeleton for the multi-level model estimator:</p>
<div class="sourceCode" id="cb252"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb252-1"><a href="#cb252-1" tabindex="-1"></a>analysis_MLM <span class="ot">&lt;-</span> <span class="cf">function</span>(dat, <span class="at">predictors =</span> <span class="st">&quot;Z&quot;</span>) {</span>
<span id="cb252-2"><a href="#cb252-2" tabindex="-1"></a></span>
<span id="cb252-3"><a href="#cb252-3" tabindex="-1"></a>}</span>
<span id="cb252-4"><a href="#cb252-4" tabindex="-1"></a></span>
<span id="cb252-5"><a href="#cb252-5" tabindex="-1"></a><span class="fu">analysis_MLM</span>( dat )</span>
<span id="cb252-6"><a href="#cb252-6" tabindex="-1"></a><span class="fu">analysis_MLM</span>( dat, <span class="at">predictors =</span> <span class="fu">c</span>(<span class="st">&quot;Z&quot;</span>,<span class="st">&quot;X&quot;</span>))</span>
<span id="cb252-7"><a href="#cb252-7" tabindex="-1"></a><span class="fu">analysis_MLM</span>( dat, <span class="at">predictors =</span> <span class="fu">c</span>(<span class="st">&quot;Z&quot;</span>,<span class="st">&quot;X&quot;</span>, <span class="st">&quot;X:Z&quot;</span>))</span></code></pre></div>
<p>Hint: Check out the <code>reformulate()</code> function, which makes it easy to build formulas for different sets of predictors.</p></li>
</ol>
</div>
<div id="contingent-estimator-processing" class="section level3 hasAnchor" number="7.5.5">
<h3 class="hasAnchor"><span class="header-section-number">7.5.5</span> Contingent estimator processing<a href="#contingent-estimator-processing" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>In Section @ref(adapting-for-errors) we developed a version of <code>analysis_MLM()</code> that fell back on OLS regression in the event that <code>lmer()</code> produced any error.
The implementation that we demonstrated is not especially smart.
For one, it does not anticipate that the error will occur.
For another, if we are using this function as one of several estimation strategies, it will require fitting the OLS regression multiple times.
Can you fix these problems?</p>
<ol style="list-style-type: decimal">
<li><p>Revise <code>analysis_MLM_contingent()</code> so that it checks whether all clusters are single observations <em>before</em> fitting the multilevel model.
Handle event the contingency where all clusters are singletons by skipping the model-fitting step, returning <code>NA</code> values for the point estimator, standard error, and p-value, and returning an informative message in the <code>error</code> variable. Test that the function is working as expected.</p></li>
<li><p>Revise <code>estimate_Tx_Fx()</code> to use your new version of <code>analysis_MLM_contingent()</code>. The revised function will sometimes return <code>NA</code> values for the <code>MLM</code> results. To implement the strategy of falling-back on OLS regression, add some code that replaces any <code>NA</code> values with corresponding results of <code>analysis_OLS()</code>. Test that the function is working as expected.</p></li>
</ol>
</div>
<div id="IRT-3PL-estimation" class="section level3 hasAnchor" number="7.5.6">
<h3 class="hasAnchor"><span class="header-section-number">7.5.6</span> Estimating 3-parameter item response theory models<a href="#IRT-3PL-estimation" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Exercise @ref(IRT-DGP-parameters) asked you to write a data-generating function for the 3-parameter IRT model described in described in Section @ref(three-parameter-IRT).
Use your function to generate a large dataset.
Using functions from the <a href="https://cran.r-project.org/package=ltm"><code>{ltm}</code></a>, <a href="https://cran.r-project.org/package=mirt"><code>{mirt}</code></a>, or <a href="https://cran.r-project.org/package=TAM"><code>{TAM}</code></a> packages, <em>estimate</em> the parameters of the 3-parameter IRT model based on the simulated dataset.</p>
<ol style="list-style-type: decimal">
<li><p>Write a function to <em>estimate</em> a 3-parameter IRT model and return a dataset containing estimates of the item characteristics <span class="math inline">\((\alpha_m,\beta_m, \gamma_m)\)</span>.</p></li>
<li><p>Add an option to the function to allow the user to specify known values of <span class="math inline">\(\gamma_m\)</span>.</p></li>
<li><p>Create a graphic showing how the item parameter estimates compare to the true item characteristics.</p></li>
<li><p>Write a function or set of functions to apply 1-parameter, 2-parameter, and 3-parameter models and return datasets containing the person ability estimates <span class="math inline">\(\theta_1,...,\theta_N\)</span> and corresponding standard errors of measurement.</p></li>
</ol>
</div>
<div id="Vevea-Hedges-estimation" class="section level3 hasAnchor" number="7.5.7">
<h3 class="hasAnchor"><span class="header-section-number">7.5.7</span> Meta-regression with selective reporting<a href="#Vevea-Hedges-estimation" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Exercise @ref(Vevea-Hedges-DGP) asked you to write a data-generating function for the <span class="citation">Vevea and Hedges (<a href="#ref-vevea1995general">1995</a>)</span> selection model.
The <code>{metafor}</code> package includes a function for fitting this model (as well as a variety of other selection models).
Here is an example of the syntax for estimating this model, using a dataset from the <code>{metadat}</code> package:</p>
<div class="sourceCode" id="cb253"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb253-1"><a href="#cb253-1" tabindex="-1"></a><span class="fu">library</span>(metafor)</span>
<span id="cb253-2"><a href="#cb253-2" tabindex="-1"></a><span class="fu">data</span>(<span class="st">&quot;dat.assink2016&quot;</span>, <span class="at">package =</span> <span class="st">&quot;metadat&quot;</span>)</span>
<span id="cb253-3"><a href="#cb253-3" tabindex="-1"></a></span>
<span id="cb253-4"><a href="#cb253-4" tabindex="-1"></a><span class="co"># rename variables and tidy up</span></span>
<span id="cb253-5"><a href="#cb253-5" tabindex="-1"></a>dat <span class="ot">&lt;-</span> </span>
<span id="cb253-6"><a href="#cb253-6" tabindex="-1"></a>  dat.assink2016 <span class="sc">%&gt;%</span></span>
<span id="cb253-7"><a href="#cb253-7" tabindex="-1"></a>  <span class="fu">mutate</span>( <span class="at">si =</span> <span class="fu">sqrt</span>(vi) ) <span class="sc">%&gt;%</span></span>
<span id="cb253-8"><a href="#cb253-8" tabindex="-1"></a>  <span class="fu">rename</span>( <span class="at">Ti =</span> yi, <span class="at">s_sq =</span> vi, <span class="at">Xi =</span> year )</span>
<span id="cb253-9"><a href="#cb253-9" tabindex="-1"></a></span>
<span id="cb253-10"><a href="#cb253-10" tabindex="-1"></a><span class="co"># fit a random effects meta-regression model</span></span>
<span id="cb253-11"><a href="#cb253-11" tabindex="-1"></a>rma_fit <span class="ot">&lt;-</span> <span class="fu">rma.uni</span>(<span class="at">yi =</span> Ti, <span class="at">sei =</span> si, <span class="at">mods =</span> <span class="sc">~</span> Xi, <span class="at">data =</span> dat)</span>
<span id="cb253-12"><a href="#cb253-12" tabindex="-1"></a><span class="co"># fit two-step selection model</span></span>
<span id="cb253-13"><a href="#cb253-13" tabindex="-1"></a><span class="fu">selmodel</span>(rma_fit, <span class="at">type =</span> <span class="st">&quot;step&quot;</span>, <span class="at">steps =</span> <span class="fu">c</span>(.<span class="dv">025</span>, .<span class="dv">500</span>))</span></code></pre></div>
<pre><code>## 
## Mixed-Effects Model (k = 100; tau^2 estimator: ML)
## 
## tau^2 (estimated amount of residual heterogeneity): 0.2314 (SE = 0.0500)
## tau (square root of estimated tau^2 value):         0.4810
## 
## Test for Residual Heterogeneity:
## LRT(df = 1) = 349.3718, p-val &lt; .0001
## 
## Test of Moderators (coefficient 2):
## QM(df = 1) = 42.1433, p-val &lt; .0001
## 
## Model Results:
## 
##          estimate      se     zval    pval 
## intrcpt    0.4149  0.1013   4.0942  &lt;.0001 
## Xi        -0.0782  0.0120  -6.4918  &lt;.0001 
##            ci.lb    ci.ub      
## intrcpt   0.2163   0.6135  *** 
## Xi       -0.1018  -0.0546  *** 
## 
## Test for Selection Model Parameters:
## LRT(df = 2) = 1.7814, p-val = 0.4104
## 
## Selection Model Results:
## 
##                      k  estimate      se     zval 
## 0     &lt; p &lt;= 0.025  59    1.0000     ---      --- 
## 0.025 &lt; p &lt;= 0.5    23    0.6990  0.2307  -1.3049 
## 0.5   &lt; p &lt;= 1      18    0.5027  0.2743  -1.8132 
##                       pval   ci.lb   ci.ub    
## 0     &lt; p &lt;= 0.025     ---     ---     ---    
## 0.025 &lt; p &lt;= 0.5    0.1919  0.2470  1.1511    
## 0.5   &lt; p &lt;= 1      0.0698  0.0000  1.0403  . 
## 
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<p>The <code>selmodel()</code> function can also be used to fit selection models in which one or both of the selection parameters are fixed to user-specified values.
For example:</p>
<div class="sourceCode" id="cb255"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb255-1"><a href="#cb255-1" tabindex="-1"></a><span class="co"># Fixing lambda_1 = 0.5, lambda_2 = 0.2</span></span>
<span id="cb255-2"><a href="#cb255-2" tabindex="-1"></a>fix_both <span class="ot">&lt;-</span> <span class="fu">selmodel</span>(rma_fit, <span class="at">type =</span> <span class="st">&quot;step&quot;</span>, <span class="at">steps =</span> <span class="fu">c</span>(.<span class="dv">025</span>, .<span class="dv">500</span>), </span>
<span id="cb255-3"><a href="#cb255-3" tabindex="-1"></a>                     <span class="at">delta =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="fl">0.5</span>, <span class="fl">0.2</span>))</span>
<span id="cb255-4"><a href="#cb255-4" tabindex="-1"></a></span>
<span id="cb255-5"><a href="#cb255-5" tabindex="-1"></a><span class="co"># Fixing lambda_1 = 0.5, estimating lambda_2</span></span>
<span id="cb255-6"><a href="#cb255-6" tabindex="-1"></a>fix_one <span class="ot">&lt;-</span> <span class="fu">selmodel</span>(rma_fit, <span class="at">type =</span> <span class="st">&quot;step&quot;</span>, <span class="at">steps =</span> <span class="fu">c</span>(.<span class="dv">025</span>, .<span class="dv">500</span>), </span>
<span id="cb255-7"><a href="#cb255-7" tabindex="-1"></a>                    <span class="at">delta =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="fl">0.5</span>, <span class="cn">NA</span>))</span></code></pre></div>
<ol style="list-style-type: decimal">
<li><p>Write an estimation function that fits the selection model and returns estimates, standard errors, and confidence intervals for each of the model parameters <span class="math inline">\((\beta_0,\beta_1,\tau,\lambda_1,\lambda_2)\)</span>.</p></li>
<li><p>The <code>selmodel()</code> fitting function sometimes returns errors, as in the following example:</p>
<div class="sourceCode" id="cb256"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb256-1"><a href="#cb256-1" tabindex="-1"></a>dat_sig <span class="ot">&lt;-</span> dat <span class="sc">%&gt;%</span> <span class="fu">filter</span>(Ti <span class="sc">/</span> si <span class="sc">&gt;</span> <span class="dv">0</span>)</span>
<span id="cb256-2"><a href="#cb256-2" tabindex="-1"></a>rma_pos <span class="ot">&lt;-</span> <span class="fu">rma.uni</span>(<span class="at">yi =</span> Ti, <span class="at">sei =</span> si, <span class="at">mods =</span> <span class="sc">~</span> Xi, <span class="at">data =</span> dat_sig)</span>
<span id="cb256-3"><a href="#cb256-3" tabindex="-1"></a><span class="co"># fit two-step selection model</span></span>
<span id="cb256-4"><a href="#cb256-4" tabindex="-1"></a>sel_fit <span class="ot">&lt;-</span> <span class="fu">selmodel</span>(rma_pos, <span class="at">type =</span> <span class="st">&quot;step&quot;</span>, <span class="at">steps =</span> <span class="fu">c</span>(.<span class="dv">025</span>, .<span class="dv">500</span>))</span></code></pre></div>
<pre><code>## Warning: One or more intervals do not contain any
## observed p-values.</code></pre>
<pre><code>## Warning: One or more &#39;delta&#39; estimates are (almost) equal to their lower or upper bound.
## Treat results with caution (or consider adjusting &#39;delta.min&#39; and/or &#39;delta.max&#39;).</code></pre>
<p>Modify your estimation function to catch and return warnings such as these.
Write code demonstrating that the function works as expected.</p></li>
<li><p>The <code>selmodel()</code> throws warnings when the dataset contains no observations with <span class="math inline">\(p_i\)</span> in one of the specified intervals.
Modify your estimation function to set the selection probability for an interval to <span class="math inline">\(\lambda_1 = 0.1\)</span> if there are no <span class="math inline">\(p_i\)</span> values between .025 and .500 and to set <span class="math inline">\(\lambda_2 = 0.1\)</span> if there are no <span class="math inline">\(p_i\)</span> values larger than .500.
Write code demonstrating that the function works as expected.</p></li>
</ol>
<!--chapter:end:030-Estimation-procedures.Rmd-->
</div>
</div>
</div>
<div id="running-the-simulation-process" class="section level1 hasAnchor" number="8">
<h1 class="hasAnchor"><span class="header-section-number">8</span> Running the Simulation Process<a href="#running-the-simulation-process" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p>In the prior two chapters we saw how to write functions that generate data according to a particular model and functions that implement data-analysis procedures on the simulated data.
The next step in a simulation involves putting these two pieces together, running the DGP function and the data-analysis function repeatedly to obtain results (in the form of point estimates, standard errors, confidence intervals, p-values, or other quantities) from many replications of the whole process.</p>
<p>As with most things R-related, there are many different techniques that can be used to repeat a set of calculations over and over.
In this chapter, we will demonstrate several techniques for doing so.
We will then explain how to ensure reproducibility of simulation results by setting the seed used by R’s random number generator.</p>
<div id="repeating-oneself" class="section level2 hasAnchor" number="8.1">
<h2 class="hasAnchor"><span class="header-section-number">8.1</span> Repeating oneself<a href="#repeating-oneself" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Suppose that we want to simulate Pearson’s correlation coefficient calculated based on a sample from the bivariate Poisson function.
We saw a DGP function for the bivariate Poisson in Section @ref(DGP-functions), and an estimation function in Section @ref(estimation-functions).
To produce a simulated correlation coefficient, we need to run these two functions in turn:</p>
<div class="sourceCode" id="cb259"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb259-1"><a href="#cb259-1" tabindex="-1"></a>dat <span class="ot">&lt;-</span> <span class="fu">r_bivariate_Poisson</span>( <span class="at">N =</span> <span class="dv">30</span>, <span class="at">rho =</span> <span class="fl">0.4</span>, <span class="at">mu1 =</span> <span class="dv">8</span>, <span class="at">mu2 =</span> <span class="dv">14</span> )</span>
<span id="cb259-2"><a href="#cb259-2" tabindex="-1"></a><span class="fu">r_and_z</span>(dat)</span></code></pre></div>
<pre><code>## # A tibble: 1 × 4
##       r     z CI_lo CI_hi
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 0.533 0.595 0.214 0.750</code></pre>
<p>To execute a simulation with these components, we need to repeat this set of calculations over and over.
R has many different functions for doing exactly this.
As one of many alternatives, the <code>{simhelpers}</code> package includes a function called <code>repeat_and_stack()</code>, which can be used to evaluate an arbitrary expression many times over.
We can use it to generate five replications of our correlation coefficient:</p>
<div class="sourceCode" id="cb261"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb261-1"><a href="#cb261-1" tabindex="-1"></a><span class="fu">library</span>(simhelpers)</span>
<span id="cb261-2"><a href="#cb261-2" tabindex="-1"></a><span class="fu">repeat_and_stack</span>(</span>
<span id="cb261-3"><a href="#cb261-3" tabindex="-1"></a>  <span class="at">n =</span> <span class="dv">5</span>, </span>
<span id="cb261-4"><a href="#cb261-4" tabindex="-1"></a>  {</span>
<span id="cb261-5"><a href="#cb261-5" tabindex="-1"></a>    dat <span class="ot">&lt;-</span> <span class="fu">r_bivariate_Poisson</span>( <span class="at">N =</span> <span class="dv">30</span>, <span class="at">rho =</span> <span class="fl">0.4</span>, <span class="at">mu1 =</span> <span class="dv">8</span>, <span class="at">mu2 =</span> <span class="dv">14</span> )</span>
<span id="cb261-6"><a href="#cb261-6" tabindex="-1"></a>    <span class="fu">r_and_z</span>(dat)</span>
<span id="cb261-7"><a href="#cb261-7" tabindex="-1"></a>  }, </span>
<span id="cb261-8"><a href="#cb261-8" tabindex="-1"></a>  <span class="at">id =</span> <span class="st">&quot;rep&quot;</span>, </span>
<span id="cb261-9"><a href="#cb261-9" tabindex="-1"></a>  <span class="at">stack =</span> <span class="cn">TRUE</span></span>
<span id="cb261-10"><a href="#cb261-10" tabindex="-1"></a>)</span></code></pre></div>
<pre><code>##           r         z      CI_lo     CI_hi rep
## 1 0.6406898 0.7593429  0.3645711 0.8132451   1
## 2 0.2165457 0.2200290 -0.1558849 0.5350714   2
## 3 0.5664693 0.6423085  0.2590719 0.7696643   3
## 4 0.4534481 0.4890323  0.1113731 0.6994524   4
## 5 0.5044732 0.5552884  0.1762338 0.7317497   5</code></pre>
<p>The first argument specifies the number of times to repeat the calculation.
The second argument is an R expression that will be evaluated.
The expression is wrapped in curly braces (<code>{}</code>) because it involves more than a single line of code.
Including the option <code>id = "rep"</code> returns a dataset that includes a variable called <code>rep</code> to identify each replication of the process.
Setting the option <code>stack = TRUE</code> will stack up the output of each expression into a single tibble, which will facilitate later calculations on the results.
Setting this option is not necessary because it is <code>TRUE</code> by default; setting <code>stack = FALSE</code> will return the results in a list rather than a tibble (try this for yourself to see!).</p>
<p>There are many other functions that work very much like <code>repeat_and_stack()</code>, including the base-R function <code>replicate()</code> and the now-deprecated function <code>rerun()</code> from <code>{purrr}</code>.
The functions in the <code>map()</code> family from <code>{purrr}</code> can also be used to do the same thing as <code>repeat_and_stack()</code>.
See Appendix @ref(more-repeating-oneself) for more discussion of these alternatives.</p>
</div>
<div id="one-run-at-a-time" class="section level2 hasAnchor" number="8.2">
<h2 class="hasAnchor"><span class="header-section-number">8.2</span> One run at a time<a href="#one-run-at-a-time" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>A slightly different technique for running multiple replications of a process is to first write a function that executes a single run of the simulation, and then repeatedly evaluate that single function.
For instance, here is a function that stitches together the two steps in the bivariate-Poisson correlation simulation:</p>
<div class="sourceCode" id="cb263"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb263-1"><a href="#cb263-1" tabindex="-1"></a>one_bivariate_Poisson_r <span class="ot">&lt;-</span> <span class="cf">function</span>(N, rho, mu1, mu2) {</span>
<span id="cb263-2"><a href="#cb263-2" tabindex="-1"></a>  dat <span class="ot">&lt;-</span> <span class="fu">r_bivariate_Poisson</span>( <span class="at">N =</span> N, <span class="at">rho =</span> rho, <span class="at">mu1 =</span> mu1, <span class="at">mu2 =</span> mu2 )</span>
<span id="cb263-3"><a href="#cb263-3" tabindex="-1"></a>  res <span class="ot">&lt;-</span> <span class="fu">r_and_z</span>(dat)</span>
<span id="cb263-4"><a href="#cb263-4" tabindex="-1"></a>  <span class="fu">return</span>(res)</span>
<span id="cb263-5"><a href="#cb263-5" tabindex="-1"></a>}</span></code></pre></div>
<p>Calling the function produces a nicely formatted set of results:</p>
<div class="sourceCode" id="cb264"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb264-1"><a href="#cb264-1" tabindex="-1"></a><span class="fu">one_bivariate_Poisson_r</span>(<span class="at">N =</span> <span class="dv">30</span>, <span class="at">rho =</span> <span class="fl">0.4</span>, <span class="at">mu1 =</span> <span class="dv">8</span>, <span class="at">mu2 =</span> <span class="dv">14</span>)</span></code></pre></div>
<pre><code>## # A tibble: 1 × 4
##       r     z CI_lo CI_hi
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 0.571 0.650 0.266 0.773</code></pre>
<p>We can then evaluate the function over and over using <code>repeat_and_stack()</code>:</p>
<div class="sourceCode" id="cb266"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb266-1"><a href="#cb266-1" tabindex="-1"></a><span class="fu">repeat_and_stack</span>(</span>
<span id="cb266-2"><a href="#cb266-2" tabindex="-1"></a>  <span class="at">n =</span> <span class="dv">5</span>, </span>
<span id="cb266-3"><a href="#cb266-3" tabindex="-1"></a>  <span class="fu">one_bivariate_Poisson_r</span>( <span class="at">N =</span> <span class="dv">30</span>, <span class="at">rho =</span> <span class="fl">0.4</span>, <span class="at">mu1 =</span> <span class="dv">8</span>, <span class="at">mu2 =</span> <span class="dv">14</span> ), </span>
<span id="cb266-4"><a href="#cb266-4" tabindex="-1"></a>  <span class="at">id =</span> <span class="st">&quot;rep&quot;</span></span>
<span id="cb266-5"><a href="#cb266-5" tabindex="-1"></a>)</span></code></pre></div>
<pre><code>##           r         z       CI_lo     CI_hi rep
## 1 0.6920971 0.8519697  0.44204893 0.8423369   1
## 2 0.4639223 0.5022978  0.12445393 0.7061652   2
## 3 0.5054484 0.5565974  0.17750188 0.7323572   3
## 4 0.3102351 0.3208056 -0.05632999 0.6030973   4
## 5 0.2699476 0.2768073 -0.10005206 0.5743583   5</code></pre>
<p>This technique of wrapping the data-generating function and estimation function inside of another function might strike you as a bit cumbersome because the wrapper is only two lines of code and writing it requires repeating many of the function argument names when calling the data-generating function (<code>N = N, rho = rho</code>, etc.).
However, the wrapper technique can be useful for more complicated simulations, such as those that involve comparison of multiple estimation methods.</p>
<p>Consider the cluster-randomized experiment case study presented in Section @ref(case-cluster) and @ref(multiple-estimation-procedures).
In this simulation, we are interested in comparing the performance of three different estimation methods: a multi-level model, a linear regression with clustered standard errors, and a linear regression on the data aggregated to the school level.
A single replication of the simulation entails generating a dataset and then apply three different estimation functions to it.
Here is a function that takes our simulation parameters and runs a single trial of the full process:</p>
<div class="sourceCode" id="cb268"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb268-1"><a href="#cb268-1" tabindex="-1"></a>one_run <span class="ot">&lt;-</span> <span class="cf">function</span>( </span>
<span id="cb268-2"><a href="#cb268-2" tabindex="-1"></a>  <span class="at">n_bar =</span> <span class="dv">30</span>, <span class="at">J =</span> <span class="dv">20</span>, <span class="at">gamma_1 =</span> <span class="fl">0.3</span>, <span class="at">gamma_2 =</span> <span class="fl">0.5</span>,</span>
<span id="cb268-3"><a href="#cb268-3" tabindex="-1"></a>  <span class="at">sigma2_u =</span> <span class="fl">0.20</span>, <span class="at">sigma2_e =</span> <span class="fl">0.80</span>, <span class="at">alpha =</span> <span class="fl">0.75</span> </span>
<span id="cb268-4"><a href="#cb268-4" tabindex="-1"></a>) {</span>
<span id="cb268-5"><a href="#cb268-5" tabindex="-1"></a>  </span>
<span id="cb268-6"><a href="#cb268-6" tabindex="-1"></a>  dat <span class="ot">&lt;-</span> <span class="fu">gen_cluster_RCT</span>(</span>
<span id="cb268-7"><a href="#cb268-7" tabindex="-1"></a>    <span class="at">n_bar =</span> n_bar, <span class="at">J =</span> J, <span class="at">gamma_1 =</span> gamma_1, <span class="at">gamma_2 =</span> gamma_2,</span>
<span id="cb268-8"><a href="#cb268-8" tabindex="-1"></a>    <span class="at">sigma2_u =</span> sigma2_u, <span class="at">sigma2_e =</span> sigma2_e, <span class="at">alpha =</span> alpha </span>
<span id="cb268-9"><a href="#cb268-9" tabindex="-1"></a>  )</span>
<span id="cb268-10"><a href="#cb268-10" tabindex="-1"></a>  MLM <span class="ot">&lt;-</span> <span class="fu">analysis_MLM</span>( dat )</span>
<span id="cb268-11"><a href="#cb268-11" tabindex="-1"></a>  LR <span class="ot">&lt;-</span> <span class="fu">analysis_OLS</span>( dat )</span>
<span id="cb268-12"><a href="#cb268-12" tabindex="-1"></a>  Agg <span class="ot">&lt;-</span> <span class="fu">analysis_agg</span>( dat )</span>
<span id="cb268-13"><a href="#cb268-13" tabindex="-1"></a>  </span>
<span id="cb268-14"><a href="#cb268-14" tabindex="-1"></a>  <span class="fu">bind_rows</span>( <span class="at">MLM =</span> MLM, <span class="at">LR =</span> LR, <span class="at">Agg =</span> Agg, <span class="at">.id =</span> <span class="st">&quot;method&quot;</span> )</span>
<span id="cb268-15"><a href="#cb268-15" tabindex="-1"></a>}</span></code></pre></div>
<p>We have added a bunch of defaults to our function, so that we can run it without having to remember all the various input parameters.
When we call the function, we get a nicely structured table of results:</p>
<div class="sourceCode" id="cb269"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb269-1"><a href="#cb269-1" tabindex="-1"></a><span class="fu">one_run</span>( <span class="at">n_bar =</span> <span class="dv">30</span>, <span class="at">J =</span> <span class="dv">20</span>, <span class="at">alpha=</span><span class="fl">0.5</span> )</span></code></pre></div>
<pre><code>## # A tibble: 3 × 4
##   method ATE_hat SE_hat p_value
##   &lt;chr&gt;    &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;
## 1 MLM      0.506  0.255  0.0630
## 2 LR       0.474  0.261  0.0881
## 3 Agg      0.511  0.255  0.0609</code></pre>
<p>We organize the output in a tibble to make it easier to do subsequent data processing and analysis.
The results for each method are organized in separate lines.
For each method, we record the impact estimate, its (estimated) standard error, and a nominal <span class="math inline">\(p\)</span>-value.
Note how the <code>bind_rows()</code> method can take naming on the fly, and give us a column of <code>method</code>, which will be very useful for keeping track of which results come from which estimation.</p>
<p>Once we have a function to execute a single run of the simulation, we can produce multiple results using <code>repeat_and_stack()</code>:</p>
<div class="sourceCode" id="cb271"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb271-1"><a href="#cb271-1" tabindex="-1"></a>R <span class="ot">&lt;-</span> <span class="dv">1000</span></span>
<span id="cb271-2"><a href="#cb271-2" tabindex="-1"></a>ATE <span class="ot">&lt;-</span> <span class="fl">0.30</span></span>
<span id="cb271-3"><a href="#cb271-3" tabindex="-1"></a>runs <span class="ot">&lt;-</span> <span class="fu">repeat_and_stack</span>(R, <span class="fu">one_run</span>( <span class="at">n_bar =</span> <span class="dv">30</span>, <span class="at">J=</span><span class="dv">20</span>, <span class="at">gamma_1 =</span> ATE ), <span class="at">id =</span> <span class="st">&quot;runID&quot;</span>) </span>
<span id="cb271-4"><a href="#cb271-4" tabindex="-1"></a><span class="fu">saveRDS</span>( runs, <span class="at">file =</span> <span class="st">&quot;results/cluster_RCT_simulation.rds&quot;</span> )</span></code></pre></div>
<p>Setting <code>id = "runID"</code> lets us keep track of which iteration number produced which result.
Once our simulation is complete, we save our results to a file for future use.
so that we can avoid having to re-run these calculations each time we want to explore the results.</p>
<p>We now have results for each of our estimation methods applied to each of 1000 generated datasets.
The next step is to evaluate how well the estimators did.
For example, we will want to examine questions about bias, precision, and accuracy of the point estimators.
In Chapter @ref(performance-criteria), we look systematically at ways to quantify the performance of estimation methods.</p>
<div id="one-run-reparameterization" class="section level3 hasAnchor" number="8.2.1">
<h3 class="hasAnchor"><span class="header-section-number">8.2.1</span> Reparameterizing<a href="#one-run-reparameterization" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>In Section @ref(DGP-standardization), we discussed how to index the DGP of the cluster-randomized experiment using an intra-class correlation (ICC) instead of using two separate variance components.
This type of re-parameterization can be handled as part of writing a wrapper function for executing the DGP and estimation procedures.
Here is a revised version of <code>one_run()</code>, which also renames some of the more obscure model parameters using terms that are easier to interpret:</p>
<div class="sourceCode" id="cb272"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb272-1"><a href="#cb272-1" tabindex="-1"></a>one_run <span class="ot">&lt;-</span> <span class="cf">function</span>( </span>
<span id="cb272-2"><a href="#cb272-2" tabindex="-1"></a>  <span class="at">n_bar =</span> <span class="dv">30</span>, <span class="at">J =</span> <span class="dv">20</span>, <span class="at">ATE =</span> <span class="fl">0.3</span>, <span class="at">size_coef =</span> <span class="fl">0.5</span>,</span>
<span id="cb272-3"><a href="#cb272-3" tabindex="-1"></a>  <span class="at">ICC =</span> <span class="fl">0.4</span>, <span class="at">alpha =</span> <span class="fl">0.75</span> </span>
<span id="cb272-4"><a href="#cb272-4" tabindex="-1"></a>) {</span>
<span id="cb272-5"><a href="#cb272-5" tabindex="-1"></a>  <span class="fu">stopifnot</span>( ICC <span class="sc">&gt;=</span> <span class="dv">0</span> <span class="sc">&amp;&amp;</span> ICC <span class="sc">&lt;</span> <span class="dv">1</span> )</span>
<span id="cb272-6"><a href="#cb272-6" tabindex="-1"></a></span>
<span id="cb272-7"><a href="#cb272-7" tabindex="-1"></a>  dat <span class="ot">&lt;-</span> <span class="fu">gen_cluster_RCT</span>( </span>
<span id="cb272-8"><a href="#cb272-8" tabindex="-1"></a>    <span class="at">n_bar =</span> n_bar, <span class="at">J=</span>J, <span class="at">gamma_1 =</span> ATE, <span class="at">gamma_2 =</span> size_coef,</span>
<span id="cb272-9"><a href="#cb272-9" tabindex="-1"></a>    <span class="at">sigma2_u =</span> ICC, <span class="at">sigma2_e =</span> <span class="dv">1</span><span class="sc">-</span>ICC, <span class="at">alpha =</span> alpha </span>
<span id="cb272-10"><a href="#cb272-10" tabindex="-1"></a>  )</span>
<span id="cb272-11"><a href="#cb272-11" tabindex="-1"></a>  </span>
<span id="cb272-12"><a href="#cb272-12" tabindex="-1"></a>  MLM <span class="ot">=</span> <span class="fu">analysis_MLM</span>( dat )</span>
<span id="cb272-13"><a href="#cb272-13" tabindex="-1"></a>  LR <span class="ot">=</span> <span class="fu">analysis_OLS</span>( dat )</span>
<span id="cb272-14"><a href="#cb272-14" tabindex="-1"></a>  Agg <span class="ot">=</span> <span class="fu">analysis_agg</span>( dat )</span>
<span id="cb272-15"><a href="#cb272-15" tabindex="-1"></a>  </span>
<span id="cb272-16"><a href="#cb272-16" tabindex="-1"></a>  <span class="fu">bind_rows</span>( <span class="at">MLM =</span> MLM, <span class="at">LR =</span> LR, <span class="at">Agg =</span> Agg, <span class="at">.id =</span> <span class="st">&quot;method&quot;</span> )</span>
<span id="cb272-17"><a href="#cb272-17" tabindex="-1"></a>}</span></code></pre></div>
<p>Note the <code>stopifnot</code>: it is wise to ensure our parameter transforms are all reasonable, so we do not get unexplained errors or strange results later on.
It is best if your code fails as soon as possible! Otherwise debugging can be quite hard.
<!-- JEP: This seems like a tangent. --></p>
<p>Controlling how we use the foundational elements such as our data generating code is a key technique for making the higher level simulations sensible and more easily interpretable.
In the revised <code>one_run()</code> function, we transform the <code>ICC</code> input parameter into the parameters used by <code>gen_cluster_RCT()</code> so as to maintain the effect size interpretation of our simulation.
We have not modified <code>gen_cluster_RCT()</code> at all: instead, we specify the parameters of the DGP function in terms of the parameters we want to directly control in the simulation.
Here we have put our entire simulation into effect size units, and are now providing “knobs” to the simulation that are directly interpretable.</p>
</div>
</div>
<div id="bundle-sim-demo" class="section level2 hasAnchor" number="8.3">
<h2 class="hasAnchor"><span class="header-section-number">8.3</span> Bundling simulations with <code>{simhelpers}</code><a href="#bundle-sim-demo" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>The techniques that we have demonstrated for repeating a set of calculations each involve a very specific coding pattern, which will often have the same structure even if the details of the data-generating model or the names of the input parameters are very different from the examples we have presented.
The <code>simhelpers</code> package provides a function <code>bundle_sim()</code> that abstracts this common pattern and allows you to automatically stitch together (or “bundle”) a DGP function and an estimation function, so that they can be run once or multiple times.
Thus, <code>bundle_sim()</code> provides a convenient alternative to writing your own <code>one_run()</code> function for each simulation, thereby saving a bit of typing (and avoiding an opportunity for bugs to creep into your code).</p>
<p><code>bundle_sim()</code> takes a DGP function and an estimation function as inputs and gives us back a new function that will run a simulation using whatever parameters we give it.
Here is a basic example, which creates a function for simulating Pearson correlation coefficients with a bivariate Poisson distribution:</p>
<div class="sourceCode" id="cb273"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb273-1"><a href="#cb273-1" tabindex="-1"></a>sim_r_Poisson <span class="ot">&lt;-</span> <span class="fu">bundle_sim</span>(<span class="at">f_generate =</span> r_bivariate_Poisson, <span class="at">f_analyze =</span> r_and_z, <span class="at">id =</span> <span class="st">&quot;rep&quot;</span>)</span></code></pre></div>
<p>If we specify the optional argument <code>id = "rep"</code>, the function will include a variable called <code>rep</code> with a unique identifier for each replication of the simulation process.
We can use the newly created function like so:</p>
<div class="sourceCode" id="cb274"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb274-1"><a href="#cb274-1" tabindex="-1"></a><span class="fu">sim_r_Poisson</span>( <span class="dv">4</span>, <span class="at">N =</span> <span class="dv">30</span>, <span class="at">rho =</span> <span class="fl">0.4</span>, <span class="at">mu1 =</span> <span class="dv">8</span>, <span class="at">mu2 =</span> <span class="dv">14</span>)</span></code></pre></div>
<pre><code>##           r         z      CI_lo     CI_hi rep
## 1 0.4584003 0.4952841  0.1175430 0.7026316   1
## 2 0.2136916 0.2170364 -0.1588034 0.5329322   2
## 3 0.4675940 0.5069866  0.1290674 0.7085081   3
## 4 0.6562349 0.7861718  0.3876033 0.8221341   4</code></pre>
<p>To create this simulation function, <code>bundle_sim()</code> examined <code>r_bivariate_Poisson()</code>, figured out what its input arguments are, and made sure that the simulation function includes the same input arguments.
You can see the full set of arguments for <code>sim_r_Poisson()</code> by evaluating it with <code>args()</code>:</p>
<div class="sourceCode" id="cb276"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb276-1"><a href="#cb276-1" tabindex="-1"></a><span class="fu">args</span>(sim_r_Poisson)</span></code></pre></div>
<pre><code>## function (reps, N, rho, mu1, mu2, seed = NA_integer_) 
## NULL</code></pre>
<p>In addition to the expected arguments from <code>r_bivariate_Poisson()</code>, the function has some additional inputs.
Its first argument is <code>reps</code>, which controls the number of times that the simulation process will be evaluated.
Its last argument is <code>seed</code>, which we will discuss in Section @ref(seeds-and-pseudo-RNGs).</p>
<p>The <code>bundle_sim()</code> function requires specifying a DGP function and a <em>single</em> estimation function, with the data as the first argument. Our cluster-randomized experiment example involved three separate estimation functions, so we first need to write a single function that organizes all of the estimators:</p>
<div class="sourceCode" id="cb278"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb278-1"><a href="#cb278-1" tabindex="-1"></a>analyze_data <span class="ot">=</span> <span class="cf">function</span>( dat ) {</span>
<span id="cb278-2"><a href="#cb278-2" tabindex="-1"></a>  MLM <span class="ot">=</span> <span class="fu">analysis_MLM</span>( dat )</span>
<span id="cb278-3"><a href="#cb278-3" tabindex="-1"></a>  LR <span class="ot">=</span> <span class="fu">analysis_OLS</span>( dat )</span>
<span id="cb278-4"><a href="#cb278-4" tabindex="-1"></a>  Agg <span class="ot">=</span> <span class="fu">analysis_agg</span>( dat )</span>
<span id="cb278-5"><a href="#cb278-5" tabindex="-1"></a>  </span>
<span id="cb278-6"><a href="#cb278-6" tabindex="-1"></a>  <span class="fu">bind_rows</span>( <span class="at">MLM =</span> MLM, <span class="at">LR =</span> LR, <span class="at">Agg =</span> Agg, <span class="at">.id =</span> <span class="st">&quot;method&quot;</span> )</span>
<span id="cb278-7"><a href="#cb278-7" tabindex="-1"></a>}</span></code></pre></div>
<p>This is simply the <code>one_run()</code> method from above, but without the data generating part.
When we pass a dataset to it, we get a nice table of results, just as before:</p>
<div class="sourceCode" id="cb279"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb279-1"><a href="#cb279-1" tabindex="-1"></a>dat <span class="ot">&lt;-</span> <span class="fu">gen_cluster_RCT</span>( <span class="at">n=</span><span class="dv">30</span>, <span class="at">J =</span> <span class="dv">20</span>, <span class="at">gamma_1 =</span> <span class="fl">0.30</span> )</span>
<span id="cb279-2"><a href="#cb279-2" tabindex="-1"></a><span class="fu">analyze_data</span>( dat )</span></code></pre></div>
<pre><code>## boundary (singular) fit: see help(&#39;isSingular&#39;)</code></pre>
<pre><code>## # A tibble: 3 × 4
##   method ATE_hat SE_hat   p_value
##   &lt;chr&gt;    &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;
## 1 MLM      0.534 0.132  0.0000650
## 2 LR       0.534 0.0844 0.0000660
## 3 Agg      0.261 0.229  0.269</code></pre>
<p>We can now use <code>bundle_sim()</code> to create a function for running an entire simulation:</p>
<div class="sourceCode" id="cb282"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb282-1"><a href="#cb282-1" tabindex="-1"></a>sim_cluster_RCT <span class="ot">&lt;-</span> <span class="fu">bundle_sim</span>( gen_cluster_RCT, analyze_data, <span class="at">id =</span> <span class="st">&quot;runID&quot;</span> )</span></code></pre></div>
<p>We can call the newly created function like so:</p>
<div class="sourceCode" id="cb283"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb283-1"><a href="#cb283-1" tabindex="-1"></a><span class="fu">sim_cluster_RCT</span>( <span class="dv">2</span>, <span class="at">n_bar =</span> <span class="dv">30</span>, <span class="at">J =</span> <span class="dv">20</span>, <span class="at">gamma_1 =</span> ATE, <span class="at">sigma2_u =</span> <span class="fl">0.3</span>, <span class="at">sigma2_e =</span> <span class="fl">0.7</span> )</span></code></pre></div>
<pre><code>##   method    ATE_hat    SE_hat   p_value runID
## 1    MLM -0.2220811 0.2112882 0.3070589     1
## 2     LR -0.3118805 0.2436926 0.2225359     1
## 3    Agg -0.1479897 0.2026064 0.4745281     1
## 4    MLM  0.3036305 0.2248424 0.1956698     2
## 5     LR  0.3277870 0.2147519 0.1523052     2
## 6    Agg  0.3884213 0.2589027 0.1508837     2</code></pre>
<p>Note that <code>bundle_sim()</code> produces a function with input names that exactly match the inputs of the DGP function that we give it.
It is not possible to re-parameterize or change argument names, as we did with <code>one_run()</code> in Section @ref(one-run-reparameterization).
See Exercise @ref() for further discussion of this limitation.</p>
<p>To use the simulation function in practice, we call it by specifying the number of replications desired (which we have stored in <code>R</code>) and any relevant input parameters.</p>
<div class="sourceCode" id="cb285"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb285-1"><a href="#cb285-1" tabindex="-1"></a>runs <span class="ot">&lt;-</span> <span class="fu">sim_cluster_RCT</span>( R, <span class="at">n_bar =</span> <span class="dv">30</span>, <span class="at">J =</span> <span class="dv">20</span>, <span class="at">gamma_1 =</span> ATE, <span class="at">sigma2_u =</span> <span class="fl">0.3</span>, <span class="at">sigma2_e =</span> <span class="fl">0.7</span> )</span>
<span id="cb285-2"><a href="#cb285-2" tabindex="-1"></a><span class="fu">saveRDS</span>( runs, <span class="at">file =</span> <span class="st">&quot;results/cluster_RCT_simulation.rds&quot;</span> )</span></code></pre></div>
<p>The <code>bundle_sim()</code> function is just a convenient way to create a function that pieces together the steps in the simulation process, which is especially useful when the component functions include many input parameters.
The function has several further features, which we will demonstrate in subsequent chapters.</p>
</div>
<div id="seeds-and-pseudo-RNGs" class="section level2 hasAnchor" number="8.4">
<h2 class="hasAnchor"><span class="header-section-number">8.4</span> Seeds and pseudo-random number generators<a href="#seeds-and-pseudo-RNGs" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>In prior chapters, we have used built-in functions to generate random numbers and also written our own data-generating functions that produce artificial data following a specific random process.
With either type of function, re-running it with the exact same input parameters will produce different results.
For instance, running the <code>rchisq</code> function with the same set of inputs will produce two different sequences of <span class="math inline">\(\chi^2\)</span> random variables:</p>
<div class="sourceCode" id="cb286"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb286-1"><a href="#cb286-1" tabindex="-1"></a>c1 <span class="ot">&lt;-</span> <span class="fu">rchisq</span>(<span class="dv">4</span>, <span class="at">df =</span> <span class="dv">3</span>)</span>
<span id="cb286-2"><a href="#cb286-2" tabindex="-1"></a>c2 <span class="ot">&lt;-</span> <span class="fu">rchisq</span>(<span class="dv">4</span>, <span class="at">df =</span> <span class="dv">3</span>)</span>
<span id="cb286-3"><a href="#cb286-3" tabindex="-1"></a><span class="fu">rbind</span>(c1, c2)</span></code></pre></div>
<pre><code>##         [,1]     [,2]    [,3]     [,4]
## c1 0.8928948 4.685652 1.94097 5.593987
## c2 0.9632513 2.454760 2.48962 1.463933</code></pre>
<p>If you run the same code as above, you will get different results from these.
Likewise, running the bivariate Poisson function from Section @ref(DGP-functions) or the <code>sim_r_Poisson()</code> function from Section @ref(bundle-sim-demo) multiple times will produce different datasets:</p>
<div class="sourceCode" id="cb288"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb288-1"><a href="#cb288-1" tabindex="-1"></a>dat_A <span class="ot">&lt;-</span> <span class="fu">r_bivariate_Poisson</span>(<span class="dv">20</span>, <span class="at">rho =</span> <span class="fl">0.5</span>, <span class="at">mu1 =</span> <span class="dv">4</span>, <span class="at">mu2 =</span> <span class="dv">7</span>)</span>
<span id="cb288-2"><a href="#cb288-2" tabindex="-1"></a>dat_B <span class="ot">&lt;-</span> <span class="fu">r_bivariate_Poisson</span>(<span class="dv">20</span>, <span class="at">rho =</span> <span class="fl">0.5</span>, <span class="at">mu1 =</span> <span class="dv">4</span>, <span class="at">mu2 =</span> <span class="dv">7</span>)</span>
<span id="cb288-3"><a href="#cb288-3" tabindex="-1"></a><span class="fu">identical</span>(dat_A, dat_B)</span></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<div class="sourceCode" id="cb290"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb290-1"><a href="#cb290-1" tabindex="-1"></a>sim_A <span class="ot">&lt;-</span> <span class="fu">sim_r_Poisson</span>( <span class="dv">10</span>, <span class="at">N =</span> <span class="dv">30</span>, <span class="at">rho =</span> <span class="fl">0.4</span>, <span class="at">mu1 =</span> <span class="dv">8</span>, <span class="at">mu2 =</span> <span class="dv">14</span>)</span>
<span id="cb290-2"><a href="#cb290-2" tabindex="-1"></a>sim_B <span class="ot">&lt;-</span> <span class="fu">sim_r_Poisson</span>( <span class="dv">10</span>, <span class="at">N =</span> <span class="dv">30</span>, <span class="at">rho =</span> <span class="fl">0.4</span>, <span class="at">mu1 =</span> <span class="dv">8</span>, <span class="at">mu2 =</span> <span class="dv">14</span>)</span>
<span id="cb290-3"><a href="#cb290-3" tabindex="-1"></a><span class="fu">identical</span>(sim_A, sim_B)</span></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<p>Of course, this is the intended behavior of these functions, but it has an important consequence that needs some care and attention.
Using functions like <code>rchisq()</code>, <code>r_bivariate_Poisson()</code>, or <code>r_bivariate_Poisson()</code> in a simulation study means that the results will not be fully reproducible.</p>
<p>When using DGP functions for simulations, it is useful to be able to exactly control the process of generating random numbers.
This is much more feasible than it sounds: Monte Carlo simulations are random, at least in theory, but computers are deterministic.
When we use R to generate what we have been referring to as “random numbers,” the functions produce what are actually <em>pseudo-random</em> numbers.
Pseudo-random numbers are generated from chains of mathematical equations designed to produce sequences of numbers that appear random, but actually follow a deterministic sequence.
Each subsequent random number is a calculated by starting from the previously generated value (i.e., the current state of the random number generator), applying a complicated function, and storing the result (i.e., updating the state).
The numbers returned by the generator form a chain that, ideally, cycles through an extremely long list of values in a way that looks stochastic and unpredictable.</p>
<p>The state of the pseudo-random number generator is shared across different functions that produce pseudo-random numbers, so it does not matter if we are generating numbers with <code>rnorm()</code> or <code>rchisq()</code> or <code>r_bivariate_Poisson()</code>.
Each time we ask for a random number from the generator, its state is updated.
Functions like <code>rnorm()</code> and <code>rchisq()</code> all call the low-level generator and then transform the result to be of the correct distribution.</p>
<p>Because the generator is actually deterministic, we can control its output by specify a starting value or initial state,
In R, the state of the random number generator can be controlled by setting what its known as the seed.
The <code>set.seed()</code> function allows us to specify a seed value, so that we can exactly reproduce a calculation.
For example,</p>
<div class="sourceCode" id="cb292"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb292-1"><a href="#cb292-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">6</span>)</span>
<span id="cb292-2"><a href="#cb292-2" tabindex="-1"></a>c1 <span class="ot">&lt;-</span> <span class="fu">rchisq</span>(<span class="dv">4</span>, <span class="at">df =</span> <span class="dv">3</span>)</span>
<span id="cb292-3"><a href="#cb292-3" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">6</span>)</span>
<span id="cb292-4"><a href="#cb292-4" tabindex="-1"></a>c2 <span class="ot">&lt;-</span> <span class="fu">rchisq</span>(<span class="dv">4</span>, <span class="at">df =</span> <span class="dv">3</span>)</span>
<span id="cb292-5"><a href="#cb292-5" tabindex="-1"></a><span class="fu">rbind</span>(c1, c2)</span></code></pre></div>
<pre><code>##        [,1]    [,2]     [,3]     [,4]
## c1 2.575556 0.93847 8.062264 3.685932
## c2 2.575556 0.93847 8.062264 3.685932</code></pre>
<p>Similarly, we can set the seed and run a series of calculations involving multiple functions that make use of the random number generator:</p>
<div class="sourceCode" id="cb294"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb294-1"><a href="#cb294-1" tabindex="-1"></a><span class="co"># First time</span></span>
<span id="cb294-2"><a href="#cb294-2" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">6</span>)</span>
<span id="cb294-3"><a href="#cb294-3" tabindex="-1"></a>c1 <span class="ot">&lt;-</span> <span class="fu">rchisq</span>(<span class="dv">4</span>, <span class="at">df =</span> <span class="dv">3</span>)</span>
<span id="cb294-4"><a href="#cb294-4" tabindex="-1"></a>dat_A <span class="ot">&lt;-</span> <span class="fu">r_bivariate_Poisson</span>(<span class="dv">20</span>, <span class="at">rho =</span> <span class="fl">0.5</span>, <span class="at">mu1 =</span> <span class="dv">4</span>, <span class="at">mu2 =</span> <span class="dv">7</span>)</span>
<span id="cb294-5"><a href="#cb294-5" tabindex="-1"></a></span>
<span id="cb294-6"><a href="#cb294-6" tabindex="-1"></a><span class="co"># Exactly reproduce the calculations</span></span>
<span id="cb294-7"><a href="#cb294-7" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">6</span>)</span>
<span id="cb294-8"><a href="#cb294-8" tabindex="-1"></a>c2 <span class="ot">&lt;-</span> <span class="fu">rchisq</span>(<span class="dv">4</span>, <span class="at">df =</span> <span class="dv">3</span>)</span>
<span id="cb294-9"><a href="#cb294-9" tabindex="-1"></a>dat_B <span class="ot">&lt;-</span> <span class="fu">r_bivariate_Poisson</span>(<span class="dv">20</span>, <span class="at">rho =</span> <span class="fl">0.5</span>, <span class="at">mu1 =</span> <span class="dv">4</span>, <span class="at">mu2 =</span> <span class="dv">7</span>)</span>
<span id="cb294-10"><a href="#cb294-10" tabindex="-1"></a></span>
<span id="cb294-11"><a href="#cb294-11" tabindex="-1"></a><span class="fu">bind_rows</span>(<span class="at">A =</span> <span class="fu">r_and_z</span>(dat_A), <span class="at">B =</span> <span class="fu">r_and_z</span>(dat_B), <span class="at">.id =</span> <span class="st">&quot;Rep&quot;</span>)</span></code></pre></div>
<pre><code>## # A tibble: 2 × 5
##   Rep       r     z  CI_lo CI_hi
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;
## 1 A     0.299 0.308 -0.165 0.655
## 2 B     0.299 0.308 -0.165 0.655</code></pre>
<p>The <code>bundle_sim()</code> function demonstrated in Section @ref(bundle-sim-demo) creates a function for repeating the process of generating and analyzing data.
By default, the function it produces includes an argument <code>seed</code>, which allows the user to set a seed value before repeatedly evaluating the DGP function and estimation function.
By default, the <code>seed</code> argument is <code>NULL</code> and so the current seed is not modified.
Specifying an integer-valued seed will make the results exactly reproducible:</p>
<div class="sourceCode" id="cb296"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb296-1"><a href="#cb296-1" tabindex="-1"></a>sim_A <span class="ot">&lt;-</span> <span class="fu">sim_r_Poisson</span>( <span class="dv">10</span>, <span class="at">N =</span> <span class="dv">30</span>, <span class="at">rho =</span> <span class="fl">0.4</span>, <span class="at">mu1 =</span> <span class="dv">8</span>, <span class="at">mu2 =</span> <span class="dv">14</span>, <span class="at">seed =</span> <span class="dv">25</span>)</span>
<span id="cb296-2"><a href="#cb296-2" tabindex="-1"></a>sim_B <span class="ot">&lt;-</span> <span class="fu">sim_r_Poisson</span>( <span class="dv">10</span>, <span class="at">N =</span> <span class="dv">30</span>, <span class="at">rho =</span> <span class="fl">0.4</span>, <span class="at">mu1 =</span> <span class="dv">8</span>, <span class="at">mu2 =</span> <span class="dv">14</span>, <span class="at">seed =</span> <span class="dv">25</span>)</span>
<span id="cb296-3"><a href="#cb296-3" tabindex="-1"></a><span class="fu">identical</span>(sim_A, sim_B)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>In practice, it is a good idea to always set seed values for your simulations, so that you (or someone else) can exactly reproduce the results.
Attending to reproducibility allows us to easily check if we are running the same code that generated a set of results.
For instance, try running the previous blocks of code on your machine; if you set the seed to the same value as we did, you should get identical output.</p>
<p>Setting seeds is also very helpful for debugging.
Suppose we had an error that showed up in one of a thousand replications, causing the simulation to crash sometimes.
If we set a seed and find that the code crashes, we can debug and then rerun the simulation.
If it now runs without error, we know we fixed the problem.
If we had not set the seed, we would not know if we were just getting (un)lucky, and avoiding the error by chance.</p>
<!-- JEP: Seems an odd place to end. Any short concluding thoughts about the whole chapter? -->
</div>
<div id="exercises-5" class="section level2 hasAnchor" number="8.5">
<h2 class="hasAnchor"><span class="header-section-number">8.5</span> Exercises<a href="#exercises-5" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<div id="Welch-simulation" class="section level3 hasAnchor" number="8.5.1">
<h3 class="hasAnchor"><span class="header-section-number">8.5.1</span> Welch simulations<a href="#Welch-simulation" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>In the prior chapter’s exercises, you made a new <code>BF_F</code> function for the Welch simulation. Now incorporate the <code>BF_F</code> function into the <code>one_run()</code> function, and use your revised function to generate simulation results for this additional estimator.</p>
</div>
<div id="Pearson-sampling-distributions" class="section level3 hasAnchor" number="8.5.2">
<h3 class="hasAnchor"><span class="header-section-number">8.5.2</span> Compare sampling distributions of Pearson’s correlation coefficients<a href="#Pearson-sampling-distributions" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<ol style="list-style-type: decimal">
<li><p>Use <code>sim_r_Poisson()</code> to generate 5000 replications of the Fisher-z-transformed correlation coefficient under a bivariate Poisson distribution for a sample of <span class="math inline">\(N = 40\)</span> observations, with <span class="math inline">\(\rho = 0.7\)</span> and your own choice for the remaining parameters.</p></li>
<li><p>Create a bundled simulation function by combining the data-generating function from Exercise @ref(BVNB1) or @ref(BVNB2) with the <code>r_and_z()</code> estimation function. Run the function to generate 5000 replications of the Fisher-z-transformed correlation coefficient under a bivariate negative binomial distribution, with the same parameter values as above.</p></li>
<li><p>Create a plot that shows both sampling distributions, making it easy to compare the distributions.</p></li>
</ol>
</div>
<div id="reparameterization-redux" class="section level3 hasAnchor" number="8.5.3">
<h3 class="hasAnchor"><span class="header-section-number">8.5.3</span> Reparameterization, redux<a href="#reparameterization-redux" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>In Section @ref(one-run-reparameterization), we illustrated how the <code>one_run()</code> simulation wrapper function could be tweaked in order to reparameterize the model in terms of a single intra-class correlation rather than two variance parameters.
But what if you want to avoid having to write your own simulation wrapper and instead use <code>bundle_sim()</code>?
Revise <code>gen_cluster_RCT()</code> to accomplish the reparameterization, then bundle it with <code>analyze_data()</code>.</p>
</div>
<div id="fancy-cluster-RCT-sims" class="section level3 hasAnchor" number="8.5.4">
<h3 class="hasAnchor"><span class="header-section-number">8.5.4</span> Fancy clustered RCT simulations<a href="#fancy-cluster-RCT-sims" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>In Exercise @ref(cluster-RCT-baseline), your task was to write a data-generating function for a cluster-randomized trial that includes a baseline covariate.
Then in Exercise @ref(CRT-ANCOVA-estimators), your task was to create an estimation function that could be applied to data from such a trial.</p>
<ol style="list-style-type: decimal">
<li><p>Now, using your work from these exercises, create a bundled simulation function that combines the data-generating function and the estimation function. Ensure that the estimation function returns average treatment effect estimates both with and without controlling for the baseline covariate.</p></li>
<li><p>Use the resulting function to simulate results from 1000 replications of a cluster-randomized trial, each analyzed two ways (with and without covariate adjustment).</p></li>
<li><p>Create a plot that shows the sampling distribution of each average treatment effect estimator and makes it easy to compare the distributions.</p></li>
</ol>
<!--chapter:end:035-running-simulation.Rmd-->
</div>
</div>
</div>
<div id="performance-criteria" class="section level1 hasAnchor" number="9">
<h1 class="hasAnchor"><span class="header-section-number">9</span> Performance criteria<a href="#performance-criteria" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p>Once we have run our simulation, we have a pile of results to sort through.
Given these results, the question is now: how do we assess how well our evaluated analysis procedures worked? In this chapter, we look at a variety of <strong>performance criteria</strong> that can answer this question. Once we have a set performance criteria, we can also compare multiple estimators to each other by seeing which have better performance.</p>
<p>Performance criteria are generally assessments of how an analytic strategy behaves on average if you repeat the experimental process an infinite number of times.
For example, the bias of an estimator in a given scenario is how far off, on average, the estimator would be from the true parameter value if you repeated the experiment an infinite number of times.</p>
<p>Although we cannot generally work out the exact performance of our analysis procedure in full mathematical detail, our set of simulation results do constitute a (typically large) <em>sample</em> of how well things will tend to worked out given the specified scenario.
We can then use that sample to <em>estimate</em> the performance criteria of interest.
For example, when we wanted to know what percent of the time we would reject the null hypothesis (for a given, specified situation) we estimated that by seeing how often we rejected in 1000 trials.</p>
<p>Now, because we have only a sample of trials rather than the full distribution, our estimates of performance are merely estimates.
In other words, they can be wrong, just due to random chance.
We can describe how wrong with the <strong>Monte Carlo standard error (MCSE)</strong>.
The MCSE is the standard error of our estimate of performance due to the simulation only having a finite number of trials.
Just as with statistical uncertainty when analyzing data, we can estimate our MCSE and even use them to generate confidence intervals for our performance estimates.
The MCSE is <em>not</em> related to the estimators or analytic procedures being evaluated; the MCSE is a function of how much simulation we can do.
In a simulation study, we could, in theory, know <em>exactly</em> how well we would do for a given context, if we ran an infinite number of simulations; the MCSE tells us how far we are from this ideal, given how many simulation trials we actually ran.
Given a desired MCSE, we could similarly determine how many replications were needed to ensure our performance estimates have a desired level of precision.</p>
<div id="different-kinds-of-performance" class="section level2 hasAnchor" number="9.1">
<h2 class="hasAnchor"><span class="header-section-number">9.1</span> Different kinds of performance<a href="#different-kinds-of-performance" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>There are several classes of performance criteria we might be interested in, depending on what we are evaluating.
In particular, we can as how well we are
We talk through them in the following sections after giving a high-level overview.</p>
<p><strong>Point Estimation.</strong>
Point estimation is when we try to measure the size of an estimand such as an actual average treatment effect <span class="math inline">\(\gamma_1\)</span>.
Estimation has two major components, the point estimator and the uncertainty estimator.
We generally evaluate both the properties of the point estimator and the performance of the properties of the point estimator.</p>
<p>For the point estimate, we generally need to know our target <em>estimand</em>, which is the “right answer” that we are trying to estimate in our scenario.
Continuing our running example of exploring best practices for analyzing a cluster randomized experiment, we might want to assess how well our estimate of the treatment effect <span class="math inline">\(\hat\gamma_1\)</span> does for the <em>estimand</em> of the site-average treatment effect, <span class="math inline">\(\gamma_1\)</span>, for example.</p>
<p>Given our estimate <span class="math inline">\(\hat{\gamma_1}\)</span> and our estimand <span class="math inline">\(\gamma_1\)</span>, we can ask whether we will get the right answer on average (if not, we have <em>bias</em>).
We can also ask how variable our estimate will tend to be (this is estimating the <em>variance</em> or <em>true standard error</em> of our estimator).
For estimation, we generally are concerned with two things: bias and variance.
An estimator is biased if it would generally give estimates that are systematically higher (or lower) than the parameter being estimated in a given scenario.
The variance of an estimator is a measure of how much the estimates vary from trial to trial.
The variance is the true standard error, squared.
We can ask how far off the truth we are likely to be on average (this is the <em>root mean squared error</em>).
These are its actual properties.</p>
<p><strong>Uncertainty Estimation.</strong>
Point estimates also usually come with estimates of uncertainty: when we estimate the average treatment effect, we will also get an estimated standard error, <span class="math inline">\(\widehat{SE}\)</span>, that tells us how far we are likely to be from our target.
We need to understand the properties of <span class="math inline">\(\widehat{SE}\)</span> as well.
We can ask whether our standard error estimator tends to be too large or too small, when compared to the true standard error. We can also assess whether the estimated standard error is usually accurate, or unstable across our simulation scenarios.</p>
<p><strong>Inference.</strong>
Inference is when we do hypothesis testing, asking whether there is evidence for some sort of effect, or asking whether there is evidence that some coefficient is greater than or less than some specified value.
In particular, for our example, to know if there is evidence that there is an average treatment effect at all we would test the null of <span class="math inline">\(H_0: \gamma_1 = 0\)</span>.
We would then</p>
<p>For inference, we first might ask whether our methods are valid, i.e., ask whether the methods work correctly when we test for a treatment effect when there is none.
For example, we might wonder whether using multilevel models could open the door to inference problems if we had model misspecification, such as in a scenario where the residuals had some non-normal distribution.
These sorts of questions are questions of validity.</p>
<p>Also for inference, we might ask which method is better for detecting an effect when there is one.
Here, we want to know how our estimators perform in circumstances with a non-zero average treatment effect.
Do they reject the null often, or rarely?
How much does using aggregation decrease (or increase?) our chances of rejection?
These are questions about power.</p>
<p><strong>Confidence Intervals.</strong>
Finally, we might want to know how well confidence intervals based on our methods work.
Do the intervals capture the true estimands with the desired level of accuracy, across the simulation trials?
Are the intervals for one method generally shorter or longer than those of another?</p>
<p><strong>Final thoughts.</strong>
Inference and estimation are clearly highly related–if we have a good estimate of the treatment effect and it is not zero (this is estimation), then we are willing to say that there is a treatment effect (this is inference)–but depending on the framing, the way you would set up a simulation to investigate the behavior of your estimators could be different.
For example, if you were interested in inference, you might want to know how often you would reject the null hypothesis of no treatment effect—if just focused on estimation, you may not have a simulation that looks at this question of validity as directly.</p>
<p>In the above, we discussed how to assess the performance of a single procedure, but in general we often have different methods for obtaining some estimate, and want to know which is best.
For example, we want to identify which estimation strategy (aggregation, linear regression, or multilevel modeling) we should generally use when analyzing cluster randomized trial data—this is comparison.
The goals for a simulation comparing different approaches should be to identify whether the strategies are different, when and how one is superior to the other, and what the salient differences are driven by.
To fully understand the trade-offs and benefits, we will generally need to compare the different approaches with respect to a variety of metrics of success.</p>
</div>
<div id="assessing-a-point-estimator" class="section level2 hasAnchor" number="9.2">
<h2 class="hasAnchor"><span class="header-section-number">9.2</span> Assessing a Point Estimator<a href="#assessing-a-point-estimator" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Assessing the actual properties of a point estimator is generally fairly simple.
For a given scenario, repeatedly generate data and estimate effects.
Then take summary measures such as the mean and standard deviation of these repeated trials’ estimates to estimate the actual properties of the estimator via Monte Carlo.
Given sufficient simulation trials, we can obtain arbitrarily accurate measures.</p>
<p>The most common measures of an estimator are the bias, variance, and mean squared error.
For example, we can ask what the variance (or standard error) of our estimator is.
We can ask if our estimator is biased.
We can ask what the overall <span class="math inline">\(RMSE\)</span> (root mean squared error) of our estimator is.</p>
<p>To be more formal, consider an estimator <span class="math inline">\(T\)</span> that is targeting a parameter <span class="math inline">\(\theta\)</span>.
We call the targeted parameter the <em>estimand</em>.
In most cases, to run our simulation we set the estimand <span class="math inline">\(\theta\)</span> and then generate a (typically large) series of datasets where <span class="math inline">\(\theta\)</span> is the true target.
We then analyze each dataset, obtaining a sample of estimates <span class="math inline">\(T_1,...,T_R\)</span>, all of the target <span class="math inline">\(\theta\)</span>.
With this approach, we know <span class="math inline">\(\theta\)</span>, but in some cases our estimand is not one of the data generation parameters; we then have to obtain <span class="math inline">\(\theta\)</span> in some other manner.
See below for further discussion and an example of this</p>
<p>With our target <span class="math inline">\(\theta\)</span> and our estimates <span class="math inline">\(T_r\)</span> in hand, we first assess whether our estimator is biased by comparing the mean of our <span class="math inline">\(R\)</span> estimates,
<span class="math display">\[ \bar{T} = \frac{1}{R}\sum_{r=1}^R T_r \;,\]</span>
to <span class="math inline">\(\theta\)</span>.
The bias of our estimator is
<span class="math display">\[bias = \bar{T} - \theta .\]</span></p>
<p>We can also ask how variable our estimator is, by calculating the variance of our <span class="math inline">\(R\)</span> estimates
<span class="math display">\[\displaystyle{S_T^2 = \frac{1}{R - 1}\sum_{r=1}^R \left(T_r - \bar{T}\right)^2} . \]</span></p>
<p>Importantly, the square root of <span class="math inline">\(S^2_T\)</span>, <span class="math inline">\(S_T\)</span> is the true standard error of our estimator (up to Monte Carlo simulation uncertainty).
The true SE <span class="math inline">\(S_T\)</span> is more interpretable due to being on the same metric as our initial estimates.</p>
<p>Finally, the Root Mean Square Error (RMSE) is a combination of the above two measures:
<span class="math display">\[ RMSE = \left\{ \frac{1}{R} \sum_{r = 1}^R \left( T_r - \theta\right)^2 \right\}^{1/2}. \]</span>
Often people talk about the MSE (Mean Squared Error)–this is just the RMSE squared.
Just like the true SE is versus the variance, the RMSE is more interpretable than the MSE.</p>
<p>An important relationship connecting these three measures is
<span class="math display">\[ RMSE^2 = bias^2 + variance = bias^2 + SE^2 .\]</span>
It is important to clarify an important point: the <em>true standard error</em> of an estimator <span class="math inline">\(\hat{\gamma_1}\)</span> is the standard deviation of <span class="math inline">\(\hat{\gamma_1}\)</span> across multiple datasets.
In practice, we never know this value, but in a simulation we can obtain it as the standard deviation of our simulation trial estimates.
Generally, when people say “Standard Error” they actually mean <em>estimated</em> Standard Error, (<span class="math inline">\(\widehat{SE}\)</span>), obtained when we use empirical data to estimate the <span class="math inline">\(SE\)</span>.
In general research, we often neglect to monitor that the standard errors themselves are estimates of a true parameter, and thus have their own uncertainty.
For assessing actual properties in a simulation, by contrast, we can actually have the true standard error (up to Monte Carlo simulation error), along with our set of estimates.</p>
<p>For absolute assessments of performance, an estimator with low bias, low variance, and thus low RMSE is desired.
For comparisons of relative performance, an estimator with lower RMSE is usually preferable to an estimator with higher RMSE; if two estimators have comparable RMSE, then the estimator with lower bias would usually be preferable.</p>
<p>It is important to recognize that the above performance measures depend on the scale of the parameter.
For example, if our estimators are measuring a treatment impact in dollars, then our bias, SE, and RMSE are all in dollars.
The variance and MSE would be in dollars squared, which is why we take their square roots to put them back on an intepretable dollars scale.</p>
<p>Often the scale of the outcome is irrelevant in our simulations.
This is especially the case if we are comparing one estimator to the other.
To ease interpretation, we might want to assess estimators relative to the baseline variation.
To achieve this, we can generate data so the outcome has unit variance (i.e., we generate <em>standardized data</em>).
Then the bias, median bias, and root mean-squared error would all be in standard deviation units.</p>
<p>By contrast, a nonlinear change of scale of a parameter can lead to nonlinear changes in performance.
For instance, suppose that <span class="math inline">\(\theta\)</span> is a measure of the proportion of time that a behavior occurs.
A natural way to transform this parameter would be to put it on the log-odds (logit) scale.
However, because of the nonlinear aspect of the logit,
<span class="math display">\[\text{Bias}\left[\text{logit}(T)\right] \neq \text{logit}\left(\text{Bias}[T]\right), \qquad \text{RMSE}\left[\text{logit}(T)\right] \neq \text{logit}\left(\text{RMSE}[T]\right),\]</span>
and so on.
This is fine, but one should be aware that this can happen and do it on purpose.</p>
<div id="comparing-the-performances-of-the-cluster-rct-estimation-procedures" class="section level3 hasAnchor" number="9.2.1">
<h3 class="hasAnchor"><span class="header-section-number">9.2.1</span> Comparing the Performances of the Cluster RCT Estimation Procedures<a href="#comparing-the-performances-of-the-cluster-rct-estimation-procedures" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Given our simulation results generated in the last chapter, we next assess the bias, standard error, and RMSE of our three different estimators of the ATE.
These performance criteria address these primary questions:</p>
<ul>
<li>Is the estimator systematically off? (bias)</li>
<li>Is it precise? (standard error)</li>
<li>Does it predict well? (RMSE)</li>
</ul>
<p>Let us see how the three estimators compare on these criteria.</p>
<p><strong>Are the estimators biased?</strong>
Bias is with respect to a target estimand.
Here we assess whether our estimates are systematically different from the <span class="math inline">\(\gamma_1\)</span> parameter we used to generate the data (this is the ATE parameter, which we had set to 0.30).</p>
<div class="sourceCode" id="cb298"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb298-1"><a href="#cb298-1" tabindex="-1"></a>runs <span class="sc">%&gt;%</span> </span>
<span id="cb298-2"><a href="#cb298-2" tabindex="-1"></a>  <span class="fu">group_by</span>( method ) <span class="sc">%&gt;%</span></span>
<span id="cb298-3"><a href="#cb298-3" tabindex="-1"></a>  <span class="fu">summarise</span>( </span>
<span id="cb298-4"><a href="#cb298-4" tabindex="-1"></a>    <span class="at">mean_ATE_hat =</span> <span class="fu">mean</span>( ATE_hat ),</span>
<span id="cb298-5"><a href="#cb298-5" tabindex="-1"></a>    <span class="at">bias =</span> <span class="fu">mean</span>( ATE_hat <span class="sc">-</span> ATE )  )</span></code></pre></div>
<pre><code>## # A tibble: 3 × 3
##   method mean_ATE_hat    bias
##   &lt;chr&gt;         &lt;dbl&gt;   &lt;dbl&gt;
## 1 Agg           0.306 0.00561
## 2 LR            0.390 0.0899 
## 3 MLM           0.308 0.00788</code></pre>
<p>Linear regression, with a bias of about 0.09 effect size units, appears about ten times as biased as the other estimators.
There is no evidence of major bias for Agg or MLM.
This is because the linear regression is targeting the person-average average treatment effect.
Our data generating process makes larger sites have larger effects, so the person average is going to be higher since those larger sites will count more.
Our estimand, by contrast, is the site average treatment effect, i.e., the simple average of each site’s true impact, which our DGP has set to 0.30.
The Agg and MLM methods, by contrast, estimate this site-average effect, putting them in line with our DGP.</p>
<p>If we had instead decided our target estimand was the person average effect, then we would see linear regression as unbiased, and Agg and MLM as biased; it is important to think carefully about what the estimators are targeting, and report bias with respect to a clearly articulated goal.</p>
<p><strong>Which method has the smallest standard error?</strong>
The true Standard Error is simply how variable a point estimator is, and is calculated as the standard deviation of the point estimates for a given estimator.
The Standard Error reflects how stable our estimates are across datasets that all came from the same data generating process.
We calculate the standard error, and also the relative standard error using linear regression as a baseline:</p>
<div class="sourceCode" id="cb300"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb300-1"><a href="#cb300-1" tabindex="-1"></a>true_SE <span class="ot">&lt;-</span> runs <span class="sc">%&gt;%</span> </span>
<span id="cb300-2"><a href="#cb300-2" tabindex="-1"></a>  <span class="fu">group_by</span>( method ) <span class="sc">%&gt;%</span></span>
<span id="cb300-3"><a href="#cb300-3" tabindex="-1"></a>  <span class="fu">summarise</span>( </span>
<span id="cb300-4"><a href="#cb300-4" tabindex="-1"></a>    <span class="at">SE =</span> <span class="fu">sd</span>( ATE_hat )</span>
<span id="cb300-5"><a href="#cb300-5" tabindex="-1"></a>  )</span>
<span id="cb300-6"><a href="#cb300-6" tabindex="-1"></a>true_SE <span class="sc">%&gt;%</span></span>
<span id="cb300-7"><a href="#cb300-7" tabindex="-1"></a>  <span class="fu">mutate</span>( <span class="at">per_SE =</span> SE <span class="sc">/</span> SE[method<span class="sc">==</span><span class="st">&quot;LR&quot;</span>] )</span></code></pre></div>
<pre><code>## # A tibble: 3 × 3
##   method    SE per_SE
##   &lt;chr&gt;  &lt;dbl&gt;  &lt;dbl&gt;
## 1 Agg    0.168  0.916
## 2 LR     0.183  1    
## 3 MLM    0.168  0.916</code></pre>
<p>These standard errors are all what we would be trying to estimate with a standard error estimator in a normal data analysis.
The other methods appear to have SEs about 8% smaller than Linear Regression.</p>
<p><strong>Which method has the smallest Root Mean Squared Error?</strong></p>
<p>So far linear regression is not doing well: it has more bias and a larger standard error than the other two.
We can assess overall performance by combining these two quantities with the RMSE:</p>
<div class="sourceCode" id="cb302"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb302-1"><a href="#cb302-1" tabindex="-1"></a>runs <span class="sc">%&gt;%</span> </span>
<span id="cb302-2"><a href="#cb302-2" tabindex="-1"></a>  <span class="fu">group_by</span>( method ) <span class="sc">%&gt;%</span></span>
<span id="cb302-3"><a href="#cb302-3" tabindex="-1"></a>  <span class="fu">summarise</span>( </span>
<span id="cb302-4"><a href="#cb302-4" tabindex="-1"></a>    <span class="at">bias =</span> <span class="fu">mean</span>( ATE_hat <span class="sc">-</span> ATE ),</span>
<span id="cb302-5"><a href="#cb302-5" tabindex="-1"></a>    <span class="at">SE =</span> <span class="fu">sd</span>( ATE_hat ),</span>
<span id="cb302-6"><a href="#cb302-6" tabindex="-1"></a>    <span class="at">RMSE =</span> <span class="fu">sqrt</span>( <span class="fu">mean</span>( (ATE_hat <span class="sc">-</span> ATE)<span class="sc">^</span><span class="dv">2</span> ) )</span>
<span id="cb302-7"><a href="#cb302-7" tabindex="-1"></a>  ) <span class="sc">%&gt;%</span></span>
<span id="cb302-8"><a href="#cb302-8" tabindex="-1"></a>  <span class="fu">mutate</span>( <span class="at">per_RMSE =</span> RMSE <span class="sc">/</span> RMSE[method<span class="sc">==</span><span class="st">&quot;LR&quot;</span>] )</span></code></pre></div>
<pre><code>## # A tibble: 3 × 5
##   method    bias    SE  RMSE per_RMSE
##   &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;
## 1 Agg    0.00561 0.168 0.168    0.823
## 2 LR     0.0899  0.183 0.204    1    
## 3 MLM    0.00788 0.168 0.168    0.823</code></pre>
<p>We also include SE and bias as reference.</p>
<p>RMSE is a way of taking both bias and variance into account, all at once.
For Agg and MLM, the RMSE is basically the standard error; this makes sense as they are not biased.
For LR, the combination of bias plus increased variability gives a higher RMSE.
That said, clearly the standard error dominates the bias term (note how RMSE and SE are more similar than RMSE and bias).
This is especially the case as RMSE is the square root of the bias and standard errors <em>squared</em>; this makes difference between them even more extreme.
Overall, Agg and MLM have RMSEs around 16% smaller than LR–this seems notable.</p>
</div>
<div id="estimands-not-represented-by-a-parameter" class="section level3 hasAnchor" number="9.2.2">
<h3 class="hasAnchor"><span class="header-section-number">9.2.2</span> Estimands Not Represented By a Parameter<a href="#estimands-not-represented-by-a-parameter" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>In our Cluster RCT example, we focused on the estimand of the ATE as captured by our model parameter <span class="math inline">\(\gamma_1\)</span>.
But say we were interested in the person-average effect.
This is not represented by any number in our data generating process, so we would have to calculate it and then compare all of our estimates to it.</p>
<p>We offer two ways of doing this.
The first is to simply generate a massive dataset, and then average across it to get a good estimate of the true person-average effect.
If our dataset is big enough, then the uncertainty in this estimate will be negligible compared to the uncertainty in our simulation.</p>
<p>Here we try this:</p>
<div class="sourceCode" id="cb304"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb304-1"><a href="#cb304-1" tabindex="-1"></a>dat <span class="ot">=</span> <span class="fu">gen_cluster_RCT</span>( <span class="at">n_bar =</span> <span class="dv">30</span>, <span class="at">J=</span><span class="dv">100000</span>, </span>
<span id="cb304-2"><a href="#cb304-2" tabindex="-1"></a>                     <span class="at">gamma_1 =</span> <span class="fl">0.3</span>, <span class="at">gamma_2 =</span> <span class="fl">0.5</span>,</span>
<span id="cb304-3"><a href="#cb304-3" tabindex="-1"></a>                     <span class="at">sigma2_u =</span> <span class="fl">0.20</span>, <span class="at">sigma2_e =</span> <span class="fl">0.80</span>,</span>
<span id="cb304-4"><a href="#cb304-4" tabindex="-1"></a>                     <span class="at">alpha =</span> <span class="fl">0.75</span>  )</span>
<span id="cb304-5"><a href="#cb304-5" tabindex="-1"></a>ATE_person <span class="ot">=</span> <span class="fu">mean</span>( dat<span class="sc">$</span>Yobs[dat<span class="sc">$</span>Z<span class="sc">==</span><span class="dv">1</span>] ) <span class="sc">-</span> <span class="fu">mean</span>( dat<span class="sc">$</span>Yobs[dat<span class="sc">$</span>Z<span class="sc">==</span><span class="dv">0</span>] )</span>
<span id="cb304-6"><a href="#cb304-6" tabindex="-1"></a>ATE_person</span></code></pre></div>
<pre><code>## [1] 0.3919907</code></pre>
<p>Note our estimate of the person-average effect of 0 is about what we would expect given the bias we saw earlier for the linear model!</p>
<p>With respect to the <code>ATE_person</code> estimand, the bias and RMSE of our estimators will shift, but SE will stay the same:</p>
<div class="sourceCode" id="cb306"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb306-1"><a href="#cb306-1" tabindex="-1"></a>runs <span class="sc">%&gt;%</span> </span>
<span id="cb306-2"><a href="#cb306-2" tabindex="-1"></a>  <span class="fu">group_by</span>( method ) <span class="sc">%&gt;%</span></span>
<span id="cb306-3"><a href="#cb306-3" tabindex="-1"></a>  <span class="fu">summarise</span>( </span>
<span id="cb306-4"><a href="#cb306-4" tabindex="-1"></a>    <span class="at">bias =</span> <span class="fu">mean</span>( ATE_hat <span class="sc">-</span> ATE_person ),</span>
<span id="cb306-5"><a href="#cb306-5" tabindex="-1"></a>    <span class="at">SE =</span> <span class="fu">sd</span>( ATE_hat ),</span>
<span id="cb306-6"><a href="#cb306-6" tabindex="-1"></a>    <span class="at">RMSE =</span> <span class="fu">sqrt</span>( <span class="fu">mean</span>( (ATE_hat <span class="sc">-</span> ATE_person)<span class="sc">^</span><span class="dv">2</span> ) )</span>
<span id="cb306-7"><a href="#cb306-7" tabindex="-1"></a>  ) <span class="sc">%&gt;%</span></span>
<span id="cb306-8"><a href="#cb306-8" tabindex="-1"></a>  <span class="fu">mutate</span>( <span class="at">per_RMSE =</span> RMSE <span class="sc">/</span> RMSE[method<span class="sc">==</span><span class="st">&quot;LR&quot;</span>] )</span></code></pre></div>
<pre><code>## # A tibble: 3 × 5
##   method     bias    SE  RMSE per_RMSE
##   &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;
## 1 Agg    -0.0864  0.168 0.189     1.03
## 2 LR     -0.00212 0.183 0.183     1   
## 3 MLM    -0.0841  0.168 0.188     1.02</code></pre>
<p>For the person-weighted estimand, Agg and MLM are biased, and LR is unbiased.
RMSE is now a tension between bias and reduced variance.
Overall, Agg and MLM are 4% worse than LR in terms of RMSE, because they have lower SEs but more bias.</p>
<p>The second method of calculating <code>ATE_person</code> would be to record the true person average effect of the dataset with each simulation iteration, and then average those at the end. This is in effect generating our massive dataset in pieces; the overall average of our dataset-specific <code>ATE_person</code>s gives our population person-weighted ATE.
To do this we would need to modify our <code>gen_cluster_RCT()</code> DGP code to track this additional information.
We might have, for example</p>
<div class="sourceCode" id="cb308"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb308-1"><a href="#cb308-1" tabindex="-1"></a>tx_effect <span class="ot">=</span> gamma_1 <span class="sc">+</span> gamma_2 <span class="sc">*</span> (nj<span class="sc">-</span>n_bar)<span class="sc">/</span>n_bar</span>
<span id="cb308-2"><a href="#cb308-2" tabindex="-1"></a>beta_0j <span class="ot">=</span> gamma_0 <span class="sc">+</span> Zj <span class="sc">*</span> tx_effect <span class="sc">+</span> u0j</span></code></pre></div>
<p>and then we would return <code>tx_effect</code> as well as <code>Yobs</code> and <code>Z</code> as a column in our dataset.
This is similar to directly calculating <em>potential outcomes</em>, as discussed in Chapter @ref(potential-outcomes).</p>
<p>Once we modified our DGP code, we <em>also</em> need to modify our analysis functions to record this information.
We might have, for example:</p>
<div class="sourceCode" id="cb309"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb309-1"><a href="#cb309-1" tabindex="-1"></a>analyze_data <span class="ot">=</span> <span class="cf">function</span>( dat ) {</span>
<span id="cb309-2"><a href="#cb309-2" tabindex="-1"></a>  MLM <span class="ot">=</span> <span class="fu">analysis_MLM</span>( dat )</span>
<span id="cb309-3"><a href="#cb309-3" tabindex="-1"></a>  LR <span class="ot">=</span> <span class="fu">analysis_OLS</span>( dat )</span>
<span id="cb309-4"><a href="#cb309-4" tabindex="-1"></a>  Agg <span class="ot">=</span> <span class="fu">analysis_agg</span>( dat )</span>
<span id="cb309-5"><a href="#cb309-5" tabindex="-1"></a>  res <span class="ot">&lt;-</span> <span class="fu">bind_rows</span>( <span class="at">MLM =</span> MLM, <span class="at">LR =</span> LR, <span class="at">Agg =</span> Agg,</span>
<span id="cb309-6"><a href="#cb309-6" tabindex="-1"></a>             <span class="at">.id =</span> <span class="st">&quot;method&quot;</span> )</span>
<span id="cb309-7"><a href="#cb309-7" tabindex="-1"></a>  res<span class="sc">$</span>ATE_person <span class="ot">=</span> <span class="fu">mean</span>( dat<span class="sc">$</span>tx_effect )</span>
<span id="cb309-8"><a href="#cb309-8" tabindex="-1"></a>  <span class="fu">return</span>( res )</span>
<span id="cb309-9"><a href="#cb309-9" tabindex="-1"></a>}</span></code></pre></div>
<p>Now when we run our simulation, we would have a column which is the true person average treatment effect for each dataset.
We could then take the average of those across our datasets to estimate the true person average treatment effect in the population, and then compare our point estimators to that value.</p>
<p>Clearly, an estimand that is not represented by a parameter is more difficult to work with, but it is not impossible.
The key is to be clear as to what you are trying to estimate: the performance of an estimator depends on the estimand the estimator is compared to.</p>
</div>
</div>
<div id="assessing-a-standard-error-estimator" class="section level2 hasAnchor" number="9.3">
<h2 class="hasAnchor"><span class="header-section-number">9.3</span> Assessing a Standard Error Estimator<a href="#assessing-a-standard-error-estimator" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Statistics is perhaps more about assessing how good an estimate is than making an estimate in the first place.
This translates to simulation studies: in our simulation we can know an estimator’s actual properties, but if we were to use this estimator in practice we would have to also estimate its associated standard error, and generate confidence intervals and so forth using this standard error estimate.
To understand if this would work in practice, we would need to evaluate not only the behavior of the estimator itself, but the behavior of these associated things.
In other words, we generally not only want to know whether our point estimator is doing a good job, but we usually want to know whether we are able to get a good standard error for that point estimator as well.</p>
<p>To do this we first compare the expected value of <span class="math inline">\(\widehat{SE}\)</span> (estimated with the average <span class="math inline">\(\widehat{SE}\)</span> across our simulation trials) to the actual <span class="math inline">\(SE\)</span>.
This tells us whether our uncertainty estimates are <em>biased</em>.
We could also examine the standard deviation of <span class="math inline">\(\widehat{SE}\)</span> across trials, which tells us whether our estimates of uncertainty are relatively stable.
We finally could examine whether there is correlation between <span class="math inline">\(\widehat{SE}\)</span> and the actual error (e.g., <span class="math inline">\(\left|T - \theta \right|\)</span>).
Good estimates of uncertainty should predict error in a given context (especially if calculating conditional estimates); see <span class="citation">Sundberg (<a href="#ref-sundberg2003conditional">2003</a>)</span>.</p>
<p>For the first assessment, we usually assess the quality of a standard error estimator with a relative performance criteria, rather than an absolute one, meaning we compare the estimated standard error to the true standard error as a ratio.</p>
<p>For an example, suppose that in our simulation we are examining the performance of a point-estimator <span class="math inline">\(T\)</span> for a parameter <span class="math inline">\(\theta\)</span> along with an estimator <span class="math inline">\(\widehat{SE}\)</span> for the standard error of <span class="math inline">\(T\)</span>.
In this case, we likely do not know the true standard error of <span class="math inline">\(T\)</span>, for our simulation context, prior to the simulation.
However, we can use the variance of <span class="math inline">\(T\)</span> across the replications (<span class="math inline">\(S_T^2\)</span>) to directly estimate the true sampling variance <span class="math inline">\(\text{Var}(T) = SE^2(T)\)</span>.
The <em>relative bias</em> of <span class="math inline">\(\widehat{SE}^2\)</span> would then be estimated by <span class="math inline">\(RB = \bar{V} / S_T^2\)</span>, where <span class="math inline">\(\bar{V}\)</span> is the average of <span class="math inline">\(\widehat{SE}^2\)</span> across simulation runs.
Note that a value of 1 for relative bias corresponds to exact unbiasedness of the variance estimator.
The relative bias measure is a measure of <em>proportionate</em> under- or over-estimation.
For example, a relative bias of 1.12 would mean the standard error was, on average, 12% too large.
We discuss relative performance measures further in Section @ref(sec-relative-performance).</p>
<div id="why-not-assess-the-estimated-se-directly" class="section level3 hasAnchor" number="9.3.1">
<h3 class="hasAnchor"><span class="header-section-number">9.3.1</span> Why Not Assess the Estimated SE directly?<a href="#why-not-assess-the-estimated-se-directly" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>We typically see assessment of <span class="math inline">\(\widehat{SE}^2\)</span>, not <span class="math inline">\(\widehat{SE}\)</span>.
In other words, we typically work with assessing whether the variance estimator is unbiased, etc., rather than the standard error estimator.
This comes out of a few reasons.
First, in practice, so-called unbiased standard errors usually are not in fact actually unbiased (see the delightfully titled section 11.5, “The Joke Is on Us: The Standard Deviation Estimator is Biased after All,” in <span class="citation">Westfall and Henning (<a href="#ref-westfall2013understanding">2013</a>)</span> for further discussion).
For linear regression, for example, the classic standard error estimator is an unbiased <em>variance</em> estimator, meaning that we have a small amount of bias due to the square-rooting because:</p>
<p><span class="math display">\[ E[ \sqrt{ V } ] \neq \sqrt{ E[ V ] } . \]</span></p>
<p>Variance is also the component that gives us the classic bias-variance breakdown of <span class="math inline">\(MSE = Variance + Bias^2\)</span>, so if we are trying to assign whether an overall MSE is due to instability or systematic bias, operating in this squared space may be preferable.</p>
<p>That being said, to put things in terms of performance criteria humans understand, it is usually nicer to put final evaluation metrics back into standard error units.
For example, saying there is a 10% reduction in the standard error is more meaningful (even if less impressive sounding) than saying there is a 19% reduction in the variance.</p>
</div>
<div id="assessing-ses-for-our-cluster-rct-simulation" class="section level3 hasAnchor" number="9.3.2">
<h3 class="hasAnchor"><span class="header-section-number">9.3.2</span> Assessing SEs for Our Cluster RCT Simulation<a href="#assessing-ses-for-our-cluster-rct-simulation" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>To assess whether our estimated SEs are about right, we can look at the average <em>estimated</em> (squared) standard error and compare it to the true standard error.
Our standard errors are <em>inflated</em> if they are systematically larger than they should be, across the simulation runs.
We can also look at how stable our standard error estimates are, by taking the standard deviation of our standard error estimates.
We interpret this quantity relative to the actual standard error to get how far off, as a percent of the actual standard error, we tend to be.</p>
<div class="sourceCode" id="cb310"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb310-1"><a href="#cb310-1" tabindex="-1"></a>runs <span class="sc">%&gt;%</span>  <span class="fu">group_by</span>( method ) <span class="sc">%&gt;%</span></span>
<span id="cb310-2"><a href="#cb310-2" tabindex="-1"></a>  <span class="fu">summarise</span>( </span>
<span id="cb310-3"><a href="#cb310-3" tabindex="-1"></a>    <span class="at">SE =</span> <span class="fu">sd</span>( ATE_hat ),</span>
<span id="cb310-4"><a href="#cb310-4" tabindex="-1"></a>    <span class="at">mean_SEhat =</span> <span class="fu">sqrt</span>( <span class="fu">mean</span>( SE_hat<span class="sc">^</span><span class="dv">2</span> ) ),</span>
<span id="cb310-5"><a href="#cb310-5" tabindex="-1"></a>    <span class="at">infl =</span> <span class="dv">100</span> <span class="sc">*</span> mean_SEhat <span class="sc">/</span> SE,</span>
<span id="cb310-6"><a href="#cb310-6" tabindex="-1"></a>    <span class="at">sd_SEhat =</span> <span class="fu">sd</span>( SE_hat ),</span>
<span id="cb310-7"><a href="#cb310-7" tabindex="-1"></a>    <span class="at">stability =</span> <span class="dv">100</span> <span class="sc">*</span> sd_SEhat <span class="sc">/</span> SE )</span></code></pre></div>
<pre><code>## # A tibble: 3 × 6
##   method    SE mean_SEhat  infl sd_SEhat stability
##   &lt;chr&gt;  &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;
## 1 Agg    0.168      0.174  104.   0.0232      13.8
## 2 LR     0.183      0.185  101.   0.0309      16.8
## 3 MLM    0.168      0.174  104.   0.0232      13.8</code></pre>
<p>The SEs for Agg and MLM appear to be a bit conservative on average. (3 or 4 percentage points too big).</p>
<p>The last column (<code>stability</code>) shows how variable the standard error estimates are relative to the true standard error.
50% would mean the standard error estimates can easily be off by 50% of the truth, which would not be particularly good.
Here we see the linear regression is more unstable than the other methods (cluster-robust standard errors are generally known to be a bit unstable, so this is not too surprising).
It is a bad day for linear regression.</p>
</div>
</div>
<div id="assessing-an-inferential-procedure-hypothesis-testing" class="section level2 hasAnchor" number="9.4">
<h2 class="hasAnchor"><span class="header-section-number">9.4</span> Assessing an Inferential Procedure (Hypothesis Testing)<a href="#assessing-an-inferential-procedure-hypothesis-testing" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>When hypothesis tests are used in practice, the researcher specifies a null (e.g., no treatment effect), collects data, and generates a <span class="math inline">\(p\)</span>-value, which is a measure of how extreme the observed data are from what we would expect to naturally occur, if the null were true.
When we assess a method for hypothesis testing, we are therefore typically concerned with two aspects: <em>validity</em> and <em>power</em>.</p>
<div id="validity" class="section level3 hasAnchor" number="9.4.1">
<h3 class="hasAnchor"><span class="header-section-number">9.4.1</span> Validity<a href="#validity" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Validity revolves around whether we erroneously reject a true null more than we should.
Put another way, we say an inference method is valid if it has no more than an <span class="math inline">\(\alpha\)</span> chance of rejecting the null, when it is true, when we are testing at the <span class="math inline">\(\alpha\)</span> level.
This means if we used this method 1000 times, where the null was true for all of those 1000 times, we should not see more than about <span class="math inline">\(1000 \alpha\)</span> rejections (so, 50, if we were using the classic <span class="math inline">\(\alpha = 0.05\)</span> rule).</p>
<p>To assess validity we would therefore specify a data generating process where the null is in fact true.
We then, for a series of such data sets with a true null, conduct our inferential processes on the data, record the <span class="math inline">\(p\)</span>-value, and score whether we reject the null hypothesis or not.</p>
<p>We might then test our methods by exploring more extreme data generation processes, where the null is true but other aspects of the data (such as outliers or heavy skew) make estimation difficult.
This allows us to understand if our methods are robust to strange data patterns in finite sample contexts.</p>
<p>The key concept for validity is that the date we generate, no matter how we do it, must be data with a true null.
The check is always then to see if we reject the null more than we should.</p>
</div>
<div id="power" class="section level3 hasAnchor" number="9.4.2">
<h3 class="hasAnchor"><span class="header-section-number">9.4.2</span> Power<a href="#power" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Power is, loosely speaking, how often we notice an effect when one is there.
Power is a much more nebulous concept than validity, because some effects (e.g. large effects) are clearly easier to notice than others.
If we are comparing estimators to each other, the overall chance of noticing is less of a concern, because we are typically interested in relative performance.
That being said, in order to generate data for a power evaluation, we have to generate data where there is something to detect.
In other words, we need to commit to what the alternative is, and this can be a tricky business.</p>
<p>Typically, we think of power as a function of sample size or effect size. Therefore, we will typically examine a sequence of scenarios with steadily increasing sample size or effect size, estimating the power for each scenario in the sequence.</p>
<p>We then, for each sample in our series, estimate the power by the same process as for validity, above.
When assessing validity, we want rejection rates to be low, below <span class="math inline">\(\alpha\)</span>, and when assessing power we want them to be as high as possible. But the simulation process itself, other than the data generating process, is exactly the same.</p>
</div>
<div id="the-rejection-rate" class="section level3 hasAnchor" number="9.4.3">
<h3 class="hasAnchor"><span class="header-section-number">9.4.3</span> The Rejection Rate<a href="#the-rejection-rate" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>To put some technical terms to this framing, for both validity and power assessment the main performance criterion is the <strong>rejection rate</strong> of the hypothesis test. When the data are simulated from a model in which the null hypothesis being tested is true, then the rejection rate is equivalent to the <strong>Type-I error rate</strong> of the test. When the data are simulated from a model in which the null hypothesis is false, then the rejection rate is equivalent to the <strong>power</strong> of the test (for the given alternate hypothesis represented by the DGP).
Ideally, a testing procedure should have actual Type-I error equal to the nominal level <span class="math inline">\(\alpha\)</span> (this is the definition of validity), but such exact tests are rare.</p>
<p>There are some different perspectives on how close the actual Type-I error rate should be in order to qualify as suitable for use in practice. Following a strict statistical definition, a hypothesis testing procedure is said to be <strong>level-<span class="math inline">\(\alpha\)</span></strong> if its actual Type-I error rate is <em>always</em> less than or equal to <span class="math inline">\(\alpha\)</span>.
Among a set of level-<span class="math inline">\(\alpha\)</span> tests, the test with highest power would be preferred.
If looking only at null rejection rates, then the test with Type-I error closest to <span class="math inline">\(\alpha\)</span> would usually be preferred.
A less stringent criteria is sometimes used instead, where type I error would be considered acceptable if it is within 50% of the desired <span class="math inline">\(\alpha\)</span>.</p>
<p>Often, it is of interest to evaluate the performance of the test at several different <span class="math inline">\(\alpha\)</span> levels.
A convenient way to calculate a set of different rejection rates is to record the simulated <span class="math inline">\(p\)</span>-values and then calculate from those.
To illustrate, suppose that <span class="math inline">\(P_r\)</span> is the <span class="math inline">\(p\)</span>-value from simulation replication <span class="math inline">\(k\)</span>, for <span class="math inline">\(k = 1,...,R\)</span>.
Then the rejection rate for a level-<span class="math inline">\(\alpha\)</span> test is defined as <span class="math inline">\(\rho_\alpha = \text{Pr}\left(P_r &lt; \alpha\right)\)</span> and estimated as, using the recorded <span class="math inline">\(p\)</span>-values,
<span class="math display">\[r_\alpha = \frac{1}{R} \sum_{r=1}^R I(P_r &lt; \alpha).\]</span></p>
<p>For a null DGP, one can also plot the emperical cumulative density function of the <span class="math inline">\(p\)</span>-values; a valid test should give a <span class="math inline">\(45^\circ\)</span> line as the <span class="math inline">\(p\)</span>-values should be standard uniform in distribution.</p>
</div>
<div id="inference-in-our-cluster-rct-simulation" class="section level3 hasAnchor" number="9.4.4">
<h3 class="hasAnchor"><span class="header-section-number">9.4.4</span> Inference in our Cluster RCT Simulation<a href="#inference-in-our-cluster-rct-simulation" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>For our scenario, we generated data with an actual treatment effect.
Without further simulation, we therefore could only assess power, not validity.
This is easily solved!
We simply rerun our simulation code that we made last chapter with <code>simhelpers</code>, but with setting <code>ATE = 0</code>.</p>
<div class="sourceCode" id="cb312"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb312-1"><a href="#cb312-1" tabindex="-1"></a><span class="fu">set.seed</span>( <span class="dv">404044</span> )</span>
<span id="cb312-2"><a href="#cb312-2" tabindex="-1"></a>runs_val <span class="ot">&lt;-</span> <span class="fu">sim_function</span>( R, <span class="at">n_bar =</span> <span class="dv">30</span>, <span class="at">J =</span> <span class="dv">20</span>, <span class="at">gamma_1 =</span> <span class="dv">0</span> )</span>
<span id="cb312-3"><a href="#cb312-3" tabindex="-1"></a><span class="fu">saveRDS</span>( runs_val, <span class="at">file =</span> <span class="st">&quot;results/cluster_RCT_simulation_validity.rds&quot;</span> )</span></code></pre></div>
<p>Assessing power and validity is exactly the same calculation: we see how often we have a <span class="math inline">\(p\)</span>-value less than 0.05.
For power we have:</p>
<div class="sourceCode" id="cb313"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb313-1"><a href="#cb313-1" tabindex="-1"></a>runs <span class="sc">%&gt;%</span> <span class="fu">group_by</span>( method ) <span class="sc">%&gt;%</span></span>
<span id="cb313-2"><a href="#cb313-2" tabindex="-1"></a>  <span class="fu">summarise</span>( <span class="at">power =</span> <span class="fu">mean</span>( p_value <span class="sc">&lt;=</span> <span class="fl">0.05</span> ) )</span></code></pre></div>
<pre><code>## # A tibble: 3 × 2
##   method power
##   &lt;chr&gt;  &lt;dbl&gt;
## 1 Agg    0.376
## 2 LR     0.503
## 3 MLM    0.383</code></pre>
<p>For validity:</p>
<div class="sourceCode" id="cb315"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb315-1"><a href="#cb315-1" tabindex="-1"></a>runs_val <span class="sc">%&gt;%</span> <span class="fu">group_by</span>( method ) <span class="sc">%&gt;%</span></span>
<span id="cb315-2"><a href="#cb315-2" tabindex="-1"></a>  <span class="fu">summarise</span>( <span class="at">power =</span> <span class="fu">mean</span>( p_value <span class="sc">&lt;=</span> <span class="fl">0.05</span> ) )</span></code></pre></div>
<pre><code>## # A tibble: 3 × 2
##   method power
##   &lt;chr&gt;  &lt;dbl&gt;
## 1 Agg    0.051
## 2 LR     0.059
## 3 MLM    0.048</code></pre>
<p>The power when there is an effect (for this specific scenario) is not particularly high, and the validity is around 0.05, as desired.</p>
<p>Linear regression has notabily higher power… but this may be in part due to the invalidity of the test (note the rejection rate is around 6%, rather than the target of 5%).
The elevated power is also likely due to the upward bias in estimation.
As discussed above, LR is targeting the person-average impact which, in this case, is not 0 even under our null because we have kept our impact heterogeniety parameter to its default of <span class="math inline">\(\gamma_2=0.2\)</span>, meaning we have treatment variation around 0.
We could run our simulation with truly null effects to see if the false rejection rate goes down.</p>
</div>
</div>
<div id="assessing-confidence-intervals" class="section level2 hasAnchor" number="9.5">
<h2 class="hasAnchor"><span class="header-section-number">9.5</span> Assessing Confidence Intervals<a href="#assessing-confidence-intervals" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Some estimation procedures result in confidence intervals (or sets) which are ranges of values that should contain the true answer with some specified degree of confidence.
For example, a normal-based confidence interval is a combination of an estimator and its estimated uncertainty.</p>
<p>We typically score a confidence interval along two dimensions, <strong>coverage rate</strong> and <strong>average length</strong>.
To calculate coverage rate, we score whether each interval “captured” the true parameter.
A success is if the true parameter is inside the interval.
To calculate average length, we record each confidence interval’s length, and then average across simulation runs.
We say an estimator has good properties if it has good coverage, i.e. it is capturing the true value at least <span class="math inline">\(1-\alpha\)</span> of the time, and if it is generally short (i.e., the average length of the interval is less than the average length for other methods).</p>
<p>Confidence interval coverage is simultaneously evaluating the estimators in terms of how well they estimate (precision) and their inferential properties.
We have combined inference and estimation.</p>
<p>Suppose that the confidence intervals are for the target parameter <span class="math inline">\(\theta\)</span> and have coverage level <span class="math inline">\(\beta\)</span>.
Let <span class="math inline">\(A_r\)</span> and <span class="math inline">\(B_r\)</span> denote the lower and upper end-points of the confidence interval from simulation replication <span class="math inline">\(r\)</span>, and let <span class="math inline">\(W_r = B_r - A_r\)</span>, all for <span class="math inline">\(r = 1,...,R\)</span>.
The coverage rate <span class="math inline">\(\omega_\beta\)</span> and average length <span class="math inline">\(\text{E}(W)\)</span> criteria are then as defined in the table below.</p>
<table>
<colgroup>
<col width="25%" />
<col width="42%" />
<col width="32%" />
</colgroup>
<thead>
<tr class="header">
<th>Criterion</th>
<th>Definition</th>
<th>Estimate</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Coverage</td>
<td><span class="math inline">\(\omega_\beta = \text{Pr}(A \leq \theta \leq B)\)</span></td>
<td><span class="math inline">\(\frac{1}{R}\sum_{r=1}^R I(A_r \leq \theta \leq B_r)\)</span></td>
</tr>
<tr class="even">
<td>Expected length</td>
<td><span class="math inline">\(\text{E}(W) = \text{E}(B - A)\)</span></td>
<td><span class="math inline">\(\bar{W} = \bar{B} - \bar{A}\)</span></td>
</tr>
</tbody>
</table>
<p>Just as with hypothesis testing, a strict statistical interpretation would deem a hypothesis testing procedure acceptable if it has actual coverage rate greater than or equal to <span class="math inline">\(\beta\)</span>.
If multiple tests satisfy this criterion, then the test with the lowest expected length would be preferable. Some analysts prefer to look at lower and upper coverage separately, where lower coverage is <span class="math inline">\(\text{Pr}(A \leq \theta)\)</span> and upper coverage is <span class="math inline">\(\text{Pr}(\theta \leq B)\)</span>.</p>
<div id="confidence-intervals-in-our-cluster-rct-example" class="section level3 hasAnchor" number="9.5.1">
<h3 class="hasAnchor"><span class="header-section-number">9.5.1</span> Confidence Intervals in our Cluster RCT Example<a href="#confidence-intervals-in-our-cluster-rct-example" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>For our CRT simulation, we first have to calculate confidence intervals, and then assess coverage.
We could have used methods such as <code>confint()</code> in the estimation approaches; this would be preferred if we wanted more accurately calculated confidence intervals that used <span class="math inline">\(t\)</span>-distributions and so forth to account for the moderate number of clusters.</p>
<p>But if we want to use normal assumption confidence intervals we can calculate them post-hoc:</p>
<div class="sourceCode" id="cb317"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb317-1"><a href="#cb317-1" tabindex="-1"></a>runs <span class="sc">%&gt;%</span> <span class="fu">mutate</span>( <span class="at">CI_l =</span> ATE_hat <span class="sc">-</span> <span class="fl">1.96</span><span class="sc">*</span>SE_hat,</span>
<span id="cb317-2"><a href="#cb317-2" tabindex="-1"></a>                 <span class="at">CI_h =</span> ATE_hat <span class="sc">+</span> <span class="fl">1.96</span><span class="sc">*</span>SE_hat,</span>
<span id="cb317-3"><a href="#cb317-3" tabindex="-1"></a>                 <span class="at">covered =</span> CI_l <span class="sc">&lt;=</span> ATE <span class="sc">&amp;</span> ATE <span class="sc">&lt;=</span> CI_h,</span>
<span id="cb317-4"><a href="#cb317-4" tabindex="-1"></a>                 <span class="at">width =</span> CI_h <span class="sc">-</span> CI_l ) <span class="sc">%&gt;%</span></span>
<span id="cb317-5"><a href="#cb317-5" tabindex="-1"></a>  <span class="fu">group_by</span>( method ) <span class="sc">%&gt;%</span></span>
<span id="cb317-6"><a href="#cb317-6" tabindex="-1"></a>  <span class="fu">summarise</span>( <span class="at">coverage =</span> <span class="fu">mean</span>( covered ),</span>
<span id="cb317-7"><a href="#cb317-7" tabindex="-1"></a>             <span class="at">width =</span> <span class="fu">mean</span>( width ))</span></code></pre></div>
<pre><code>## # A tibble: 3 × 3
##   method coverage width
##   &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt;
## 1 Agg       0.942 0.677
## 2 LR        0.908 0.717
## 3 MLM       0.943 0.677</code></pre>
<p>Our coverage is about right for Agg and MLM, and around 5 percentage points too low for LR.
Linear regression is taking a hit from the bias term.
The CIs of LR are a bit wider than the other methods due to the estimated SEs being slightly larger.</p>
</div>
</div>
<div id="additional-thoughts-on-measuring-performance" class="section level2 hasAnchor" number="9.6">
<h2 class="hasAnchor"><span class="header-section-number">9.6</span> Additional Thoughts on Measuring Performance<a href="#additional-thoughts-on-measuring-performance" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>In this section we provide some additional thoughts on performance measures.
We first discuss relative vs. absolute criteria some more, then touch on robust measures of performance.
We finally summarize the measures we discuss in this chapter.</p>
<div id="sec-relative-performance" class="section level3 hasAnchor" number="9.6.1">
<h3 class="hasAnchor"><span class="header-section-number">9.6.1</span> Selecting Relative vs. Absolute Criteria<a href="#sec-relative-performance" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>We have primarily examined performance estimators for point estimators using absolute criteria, focusing on measures like bias directly on the scale of the outcome.
In contrast, for evaluation things such as estimated standard errors, which are always positive and scale-dependent, it often makes sense to use relative criteria, i.e., criteria calculated as proportions of the target parameter (<span class="math inline">\(T/\theta\)</span>) rather than as differences (<span class="math inline">\(T - \theta\)</span>).
We typically apply absolute criteria to point estimators and relative criteria to standard error estimators (we are setting aside, for the moment, the relative criteria of a measure from one estimation procedure to another, as we saw earlier when we compared the SEs to a baseline SE of linear regression for the cluster randomized trial simulation.
So how do we select when to use what?</p>
<p>As a first piece of guidance, establish whether we expect the performance (e.g., bias, standard error, or RMSE) of a point estimate to depend on the magnitude of the estimand.
For example, if we are estimating some mean <span class="math inline">\(\theta\)</span>, and we generate data where <span class="math inline">\(\theta = 100\)</span> vs where <span class="math inline">\(\theta = 1000\)</span> (or any other arbitrary number), we would not generally expect the value of <span class="math inline">\(\theta\)</span> to change the magnitude of bias, variance, or MSE.
On the other hand, these different <span class="math inline">\(\theta\)</span>s would have a large impact on the <em>relative</em> bias and <em>relative</em> MSE.
(Want smaller relative bias? Just add a million to the parameter!)
For these sorts of “location parameters” we generally use absolute measures of performance.</p>
<p>That being said, a more principled approach for determining whether to use absolute or relative performance criteria depends on assessing performance for <em>multiple</em> values of the parameter.
In many simulation studies, replications are generated and performance criteria are calculated for several different values of a parameter, say <span class="math inline">\(\theta = \theta_1,...,\theta_p\)</span>.
Let’s focus on bias for now, and say that we’ve estimated (from a large number of replications) the bias at each parameter value.
We present two hypothetical scenarios, A and B, in the figures below.</p>
<p><img src="Designing-Simulations-in-R_files/figure-html/unnamed-chunk-176-1.png" width="75%" style="display: block; margin: auto;" /></p>
<p>If the absolute bias is roughly the same for all values of <span class="math inline">\(\theta\)</span> (as in Scenario A), then it makes sense to report absolute bias as the summary performance criterion.
On the other hand, if the bias grows roughly in proportion to <span class="math inline">\(\theta\)</span> (as in Scenario B), then relative bias might be a better summary criterion.</p>
<p><strong>Performance relative to a baseline estimator.</strong></p>
<p>Another relative measure, as we saw earlier, is to calculate performance relative to some baseline.
For example, if one of the estimators is the “generic method,” we could calculate ratios of the RMSE of our estimators to the baseline RMSE.
This can provide a way of standardizing across simulation scenarios where the overall scale of the RMSE changes radically.
This could be critical to, for example, examining trends across simulations that have different sample sizes, where we would expect all estimators’ performance measures to improve as sample size grows.
This kind of relative standardization allows us to make statements such as “Aggregation has standard errors around 8% smaller than linear regression”–which is very interpretable, more interpretable than saying “Aggregation has standard errors around 0.01 smaller than linear regression.”
In the latter case, we do not know if that is big or small.</p>
<p>While a powerful tool, standardization is not without risks: if you scale relative to something, then higher or lower ratios can either be due to the primary method of interest (the numerator) or due to the behavior of the reference method in the denominator.
These relative ratios can end up being confusing to interpret due to this tension.</p>
<p>They can also break when everything is on a constrained scale, like power.
If we have a power of 0.05, and we improve it to 0.10, we have doubled our power, but if it is 0.10 and we increase to 0.15, we have only increased by 50%.
Ratios when near zero can be very deceiving.</p>
</div>
<div id="robust-measures-of-performance" class="section level3 hasAnchor" number="9.6.2">
<h3 class="hasAnchor"><span class="header-section-number">9.6.2</span> Robust Measures of Performance<a href="#robust-measures-of-performance" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Depending on the model and estimation procedures being examined, a range of different criteria might be used to assess estimator performance.
For point estimation, we have seen bias, variance and MSE as the three core measures of performance.
Other criteria exist, such as the median bias and the median absolute deviation of <span class="math inline">\(T\)</span>, where we use the median <span class="math inline">\(\tilde{T}\)</span> of our estimates rather than the mean <span class="math inline">\(\bar{T}\)</span>.</p>
<p>The usual bias, variance and MSE measures can be sensitive to outliers.
If an estimator generally does well, except for an occasional large mistake, these classic measures can return very poor overall performance.
Instead, we might turn to quantities such as the median bias (sort all the estimation errors across the simulation scenarios, and take the middle), or the Median Absolute Distance (MAD, where you take the median of the absolute values of the errors, which is an alternative to RMSE) as a measure of performance.</p>
<p>Other robust measures are also possible, such as simply truncating all errors to a maximum size (this is called Windsorizing).
This is a way of saying “I don’t care if you are off by 1000, I am only going to count it as 10.”</p>
</div>
<div id="summary-of-peformance-measures" class="section level3 hasAnchor" number="9.6.3">
<h3 class="hasAnchor"><span class="header-section-number">9.6.3</span> Summary of Peformance Measures<a href="#summary-of-peformance-measures" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>We list most of the performance criteria we saw in this chapter in the table below, for reference:</p>
<table>
<colgroup>
<col width="25%" />
<col width="38%" />
<col width="36%" />
</colgroup>
<thead>
<tr class="header">
<th>Criterion</th>
<th>Definition</th>
<th>Estimate</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Bias</td>
<td><span class="math inline">\(\text{E}(T) - \theta\)</span></td>
<td><span class="math inline">\(\bar{T} - \theta\)</span></td>
</tr>
<tr class="even">
<td>Median bias</td>
<td><span class="math inline">\(\text{M}(T) - \theta\)</span></td>
<td><span class="math inline">\(\tilde{T} - \theta\)</span></td>
</tr>
<tr class="odd">
<td>Variance</td>
<td><span class="math inline">\(\text{E}\left[\left(T - \text{E}(T)\right)^2\right]\)</span></td>
<td><span class="math inline">\(S_T^2\)</span></td>
</tr>
<tr class="even">
<td>MSE</td>
<td><span class="math inline">\(\text{E}\left[\left(T - \theta\right)^2\right]\)</span></td>
<td><span class="math inline">\(\left(\bar{T} - \theta\right)^2 + S_T^2\)</span></td>
</tr>
<tr class="odd">
<td>MAD</td>
<td><span class="math inline">\(\text{M}\left[\left|T - \theta\right|\right]\)</span></td>
<td><span class="math inline">\(\left[\left|T - \theta\right|\right]_{R/2}\)</span></td>
</tr>
<tr class="even">
<td>Relative bias</td>
<td><span class="math inline">\(\text{E}(T) / \theta\)</span></td>
<td><span class="math inline">\(\bar{T} / \theta\)</span></td>
</tr>
<tr class="odd">
<td>Relative median bias</td>
<td><span class="math inline">\(\text{M}(T) / \theta\)</span></td>
<td><span class="math inline">\(\tilde{T} / \theta\)</span></td>
</tr>
<tr class="even">
<td>Relative MSE</td>
<td><span class="math inline">\(\text{E}\left[\left(T - \theta\right)^2\right] / \theta^2\)</span></td>
<td><span class="math inline">\(\frac{\left(\bar{T} - \theta\right)^2 + S_T^2}{\theta^2}\)</span></td>
</tr>
</tbody>
</table>
<ul>
<li>Bias and median bias are measures of whether the estimator is systematically higher or lower than the target parameter.</li>
<li>Variance is a measure of the <strong>precision</strong> of the estimator—that is, how far it deviates <em>from its average</em>. We might look at the square root of this, to assess the precision in the units of the original measure. This is the true SE of the estimator.</li>
<li>Mean-squared error is a measure of <strong>overall accuracy</strong>, i.e. is a measure how far we typically are from the truth. We more frequently use the root mean-squared error, or RMSE, which is just the square root of the MSE.</li>
<li>The median absolute deviation (MAD) is another measure of overall accuracy that is less sensitive to outlier estimates. The RMSE can be driven up by a single bad egg. The MAD is less sensitive to this.</li>
</ul>
</div>
</div>
<div id="uncertainty-in-performance-estimates-the-monte-carlo-standard-error" class="section level2 hasAnchor" number="9.7">
<h2 class="hasAnchor"><span class="header-section-number">9.7</span> Uncertainty in Performance Estimates (the Monte Carlo Standard Error)<a href="#uncertainty-in-performance-estimates-the-monte-carlo-standard-error" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Our performance criteria are defined as average performance across an infinite number of trials.
Of course, in our simulations we only run a finite number of trials, and estimate the performance criteria with the sample of trials we generate.
For example, if we are assessing coverage across 100 trials, we can calculate what fraction rejected the null for that 100.
This is an <em>estimate</em> of the true coverage rate.
Due to random chance, we might see a higher, or lower, proportion rejected than what we would see if we ran the simulation forever.</p>
<p>To account for estimation uncertainty we want associated uncertainty estimates to go with our point estimates of performance.
We want to, in other words, treat our simulation results as a dataset in its own right.
(And yes, this is quite meta!)</p>
<p>Once we frame the problem in these terms, it is relatively straightforward to calculate standard errors for most of the performance critera because we have an independent and identically distributed set of measurements.
We call these standard errors Monte Carlo Simulation Errors, or MCSEs.
For some of the performance criteria we have to be a bit more clever, as we will discuss below.</p>
<p>We list MCSE expressions for many of our straightforward performance measures on the following table.
In reading the table, recall that, for an estimator <span class="math inline">\(T\)</span>, we have <span class="math inline">\(S_T\)</span> being the standard deviation of <span class="math inline">\(T\)</span> across our simulation runs (i.e., our estimated true Standard Error).
We also have</p>
<ul>
<li>Sample skewness (standardized): <span class="math inline">\(\displaystyle{g_T = \frac{1}{R S_T^3}\sum_{r=1}^R \left(T_r - \bar{T}\right)^3}\)</span></li>
<li>Sample kurtosis (standardized): <span class="math inline">\(\displaystyle{k_T = \frac{1}{R S_T^4} \sum_{r=1}^R \left(T_r - \bar{T}\right)^4}\)</span></li>
</ul>
<table>
<colgroup>
<col width="66%" />
<col width="33%" />
</colgroup>
<thead>
<tr class="header">
<th>Criterion for T</th>
<th>MCSE</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Bias (<span class="math inline">\(T-\theta\)</span>)</td>
<td><span class="math inline">\(\sqrt{S_T^2/ R}\)</span></td>
</tr>
<tr class="even">
<td>Variance (<span class="math inline">\(S_T^2\)</span>)</td>
<td><span class="math inline">\(\displaystyle{S_T^2 \sqrt{\frac{k_T - 1}{R}}}\)</span></td>
</tr>
<tr class="odd">
<td>MSE</td>
<td>see below</td>
</tr>
<tr class="even">
<td>MAD</td>
<td>-</td>
</tr>
<tr class="odd">
<td>Power &amp; Validity (<span class="math inline">\(r_\alpha\)</span>)</td>
<td><span class="math inline">\(\sqrt{ r_\alpha \left(1 - r_\alpha\right) / R}\)</span></td>
</tr>
<tr class="even">
<td>Coverage (<span class="math inline">\(\omega_\beta\)</span>)</td>
<td><span class="math inline">\(\sqrt{\omega_\beta \left(1 - \omega_\beta\right) / R}\)</span></td>
</tr>
<tr class="odd">
<td>Average length (<span class="math inline">\(\text{E}(W)\)</span>)</td>
<td><span class="math inline">\(\sqrt{S_W^2 / R}\)</span></td>
</tr>
</tbody>
</table>
<p>The MCSE for the MSE is a bit more complicated, and does not quite fit on our table:
<span class="math display">\[ \widehat{MCSE}( \widehat{MSE} ) = \displaystyle{\sqrt{\frac{1}{R}\left[S_T^4 (k_T - 1) + 4 S_T^3 g_T\left(\bar{T} - \theta\right) + 4 S_T^2 \left(\bar{T} - \theta\right)^2\right]}} .\]</span></p>
<p>For relative quantities with respect to an estimand, simply divide the criterion by the target estimand.
E.g., for relative bias <span class="math inline">\(T / \theta\)</span>, the standard error would be
<span class="math display">\[ SE\left( \frac{T}{\theta} \right) = \frac{1}{\theta} SE(T) = \sqrt{\frac{S_T^2}{R\theta^2}} .\]</span></p>
<p>For square rooted quantities, such as the SE for the true SE (square root of the Variance) or the RMSE (square root of MSE) we can use the Delta method.
The Delta method says (with some conditions), that if we assume <span class="math inline">\(X \sim N( \phi, V )\)</span>, then we can approximate the distribution of <span class="math inline">\(g(X)\)</span> for some continuous function <span class="math inline">\(g(\cdot)\)</span> as
<span class="math display">\[ g(X) \sim N\left( g(\phi), \;\; g&#39;(\phi)^2\cdot V \right) , \]</span>
where <span class="math inline">\(g&#39;(\phi)\)</span> is the derivative of <span class="math inline">\(g(\cdot)\)</span> evaluated at <span class="math inline">\(\phi\)</span>.
In other words,
<span class="math display">\[ SE( g(\hat{X}) ) \approx g&#39;(\theta)  \times SE(\hat{X}) .\]</span>
For estimation, we plug in <span class="math inline">\(\hat{\theta}\)</span> and our estimate of <span class="math inline">\(SE(\hat{X})\)</span> into the above.
Back to the square root, we have <span class="math inline">\(g(x) = \sqrt(x)\)</span> and <span class="math inline">\(g&#39;(x) = 1/2\sqrt(x)\)</span>.
This gives, for example, the estimated MCSE of the SE as
<span class="math display">\[ \widehat{SE}( \widehat{SE} ) = \widehat{SE}( S^2_T ) = \frac{1}{2S^2_T} \widehat{SE}( S^2_T ) = \frac{1}{2S^2_T} S_T^2 \sqrt{\frac{k_T - 1}{R}} = \frac{1}{2} \sqrt{\frac{k_T - 1}{R}} .\]</span></p>
<div id="mcse-for-relative-variance-estimators" class="section level3 hasAnchor" number="9.7.1">
<h3 class="hasAnchor"><span class="header-section-number">9.7.1</span> MCSE for Relative Variance Estimators<a href="#mcse-for-relative-variance-estimators" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Estimating the MCSE of the relative bias or relative MSE of a (squared) standard error estimator, i.e., of <span class="math inline">\(E( \widehat{SE^2} - SE^2 ) / SE^2 )\)</span> or <span class="math inline">\(\widehat{MSE} / MSE\)</span>, is complicated by the appearance of an estimated quantity, <span class="math inline">\(SE^2\)</span> or <span class="math inline">\(MSE\)</span>, in the denominator of the ratio.
This renders the simple division approach from above unusable, technically speaking.
The problem is we cannot use our clean expressions for MCSEs of relative performance measures since we are not taking the uncertainty of our denominator into account.</p>
<p>To properly assess the overall MCSE, we need to do something else.
One approach is to use the <em>jackknife</em> technique.
Let <span class="math inline">\(\bar{V}_{(j)}\)</span> and <span class="math inline">\(S_{T(j)}^2\)</span> be the average squared standard error estimate and the true variance estimate calculated from the set of replicates <strong><em>that excludes replicate <span class="math inline">\(j\)</span></em></strong>, for <span class="math inline">\(j = 1,...,R\)</span>.
The relative bias estimate, excluding replicate <span class="math inline">\(j\)</span> would then be <span class="math inline">\(\bar{V}_{(j)} / S_{T(j)}^2\)</span>.
Calculating all <span class="math inline">\(R\)</span> versions of this relative bias estimate and taking the variance of these <span class="math inline">\(R\)</span> versions yields the jackknife variance estimator:</p>
<p><span class="math display">\[
MCSE\left( \frac{ \widehat{SE}^2 }{SE^2} \right) = \frac{1}{R} \sum_{j=1}^R \left(\frac{\bar{V}_{(j)}}{S_{T(j)}^2} - \frac{\bar{V}}{S_T^2}\right)^2.
\]</span></p>
<p>This would be quite time-consuming to compute if we did it by brute force. However, a few algebra tricks provide a much quicker way. The tricks come from observing that</p>
<p><span class="math display">\[
\begin{aligned}
\bar{V}_{(j)} &amp;= \frac{1}{R - 1}\left(R \bar{V} - V_j\right) \\
S_{T(j)}^2 &amp;= \frac{1}{R - 2} \left[(R - 1) S_T^2 - \frac{R}{R - 1}\left(T_j - \bar{T}\right)^2\right]
\end{aligned}
\]</span>
These formulas can be used to avoid re-computing the mean and sample variance from every subsample.
Instead, you calculate the overall mean and overall variance, and then do a small adjustment with each jackknife iteration.
You can even implement this with vector processing in R!</p>
</div>
<div id="calculating-mcses-with-the-simhelpers-package" class="section level3 hasAnchor" number="9.7.2">
<h3 class="hasAnchor"><span class="header-section-number">9.7.2</span> Calculating MCSEs With the <code>simhelpers</code> Package<a href="#calculating-mcses-with-the-simhelpers-package" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>The <code>simhelper</code> package is designed to calculate MCSEs (and the performance metrics themselves) for you.
It is easy to use: take this set of simulation runs on the Welch dataset:</p>
<div class="sourceCode" id="cb319"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb319-1"><a href="#cb319-1" tabindex="-1"></a><span class="fu">library</span>( simhelpers )</span>
<span id="cb319-2"><a href="#cb319-2" tabindex="-1"></a><span class="fu">data</span>( welch_res )</span>
<span id="cb319-3"><a href="#cb319-3" tabindex="-1"></a>welch <span class="ot">&lt;-</span> welch_res <span class="sc">%&gt;%</span></span>
<span id="cb319-4"><a href="#cb319-4" tabindex="-1"></a>  <span class="fu">filter</span>( method <span class="sc">==</span> <span class="st">&quot;t-test&quot;</span> ) <span class="sc">%&gt;%</span></span>
<span id="cb319-5"><a href="#cb319-5" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">select</span>( <span class="sc">-</span>method, <span class="sc">-</span>seed, <span class="sc">-</span>iterations )</span>
<span id="cb319-6"><a href="#cb319-6" tabindex="-1"></a></span>
<span id="cb319-7"><a href="#cb319-7" tabindex="-1"></a>welch</span></code></pre></div>
<pre><code>## # A tibble: 8,000 × 8
##       n1    n2 mean_diff      est    var p_val
##    &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;
##  1    50    50         0  0.0258  0.0954 0.934
##  2    50    50         0  0.00516 0.0848 0.986
##  3    50    50         0 -0.0798  0.0818 0.781
##  4    50    50         0 -0.0589  0.102  0.854
##  5    50    50         0  0.0251  0.118  0.942
##  6    50    50         0 -0.115   0.106  0.725
##  7    50    50         0  0.157   0.115  0.645
##  8    50    50         0 -0.213   0.121  0.543
##  9    50    50         0  0.509   0.117  0.139
## 10    50    50         0 -0.354   0.0774 0.206
## # ℹ 7,990 more rows
## # ℹ 2 more variables: lower_bound &lt;dbl&gt;,
## #   upper_bound &lt;dbl&gt;</code></pre>
<p>We can calculate performance metrics across all the range of scenarios.
Here is the rejection rate:</p>
<div class="sourceCode" id="cb321"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb321-1"><a href="#cb321-1" tabindex="-1"></a>welch_sub <span class="ot">=</span> <span class="fu">filter</span>( welch, n1 <span class="sc">==</span> <span class="dv">50</span>, n2 <span class="sc">==</span> <span class="dv">50</span>, mean_diff<span class="sc">==</span><span class="dv">0</span> )</span>
<span id="cb321-2"><a href="#cb321-2" tabindex="-1"></a><span class="fu">calc_rejection</span>(welch_sub, p_val)</span></code></pre></div>
<pre><code>##   K_rejection rej_rate rej_rate_mcse
## 1        1000    0.048   0.006759882</code></pre>
<p>And coverage:</p>
<div class="sourceCode" id="cb323"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb323-1"><a href="#cb323-1" tabindex="-1"></a><span class="fu">calc_coverage</span>(welch_sub, lower_bound, upper_bound, mean_diff)</span></code></pre></div>
<pre><code>## # A tibble: 1 × 5
##   K_coverage coverage coverage_mcse width
##        &lt;int&gt;    &lt;dbl&gt;         &lt;dbl&gt; &lt;dbl&gt;
## 1       1000    0.952       0.00676  1.25
## # ℹ 1 more variable: width_mcse &lt;dbl&gt;</code></pre>
<p>Using <code>tidyverse</code> it is easy to process across scenarios (more on experimental design and multiple scenarios later):</p>
<div class="sourceCode" id="cb325"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb325-1"><a href="#cb325-1" tabindex="-1"></a>welch <span class="sc">%&gt;%</span> <span class="fu">group_by</span>(n1,n2,mean_diff) <span class="sc">%&gt;%</span></span>
<span id="cb325-2"><a href="#cb325-2" tabindex="-1"></a>  <span class="fu">summarise</span>( <span class="fu">calc_rejection</span>( <span class="at">p_values =</span> p_val ) )</span></code></pre></div>
<pre><code>## # A tibble: 8 × 6
## # Groups:   n1, n2 [2]
##      n1    n2 mean_diff K_rejection rej_rate
##   &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;       &lt;int&gt;    &lt;dbl&gt;
## 1    50    50       0          1000    0.048
## 2    50    50       0.5        1000    0.34 
## 3    50    50       1          1000    0.876
## 4    50    50       2          1000    1    
## 5    50    70       0          1000    0.027
## 6    50    70       0.5        1000    0.341
## 7    50    70       1          1000    0.904
## 8    50    70       2          1000    1    
## # ℹ 1 more variable: rej_rate_mcse &lt;dbl&gt;</code></pre>
</div>
<div id="mcse-calculation-in-our-cluster-rct-example" class="section level3 hasAnchor" number="9.7.3">
<h3 class="hasAnchor"><span class="header-section-number">9.7.3</span> MCSE Calculation in our Cluster RCT Example<a href="#mcse-calculation-in-our-cluster-rct-example" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>We can check our MCSEs for our performance measures to see if we have enough simulation trials to give us precise enough estimates to believe the differences we reported earlier.
In particular, we have:</p>
<div class="sourceCode" id="cb327"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb327-1"><a href="#cb327-1" tabindex="-1"></a><span class="fu">library</span>( simhelpers )</span>
<span id="cb327-2"><a href="#cb327-2" tabindex="-1"></a>runs<span class="sc">$</span>ATE <span class="ot">=</span> ATE</span>
<span id="cb327-3"><a href="#cb327-3" tabindex="-1"></a>runs <span class="sc">%&gt;%</span> </span>
<span id="cb327-4"><a href="#cb327-4" tabindex="-1"></a>  <span class="fu">summarise</span>( <span class="fu">calc_absolute</span>( <span class="at">estimates =</span> ATE_hat,</span>
<span id="cb327-5"><a href="#cb327-5" tabindex="-1"></a>                            <span class="at">true_param =</span> ATE,</span>
<span id="cb327-6"><a href="#cb327-6" tabindex="-1"></a>                            <span class="at">criteria =</span> <span class="fu">c</span>(<span class="st">&quot;bias&quot;</span>,<span class="st">&quot;stddev&quot;</span>, <span class="st">&quot;rmse&quot;</span>)) ) <span class="sc">%&gt;%</span></span>
<span id="cb327-7"><a href="#cb327-7" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">select</span>( <span class="sc">-</span>K_absolute ) <span class="sc">%&gt;%</span></span>
<span id="cb327-8"><a href="#cb327-8" tabindex="-1"></a>  knitr<span class="sc">::</span><span class="fu">kable</span>(<span class="at">digits=</span><span class="dv">3</span>)</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="right">bias</th>
<th align="right">bias_mcse</th>
<th align="right">stddev</th>
<th align="right">stddev_mcse</th>
<th align="right">rmse</th>
<th align="right">rmse_mcse</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">0.034</td>
<td align="right">0.003</td>
<td align="right">0.178</td>
<td align="right">0.002</td>
<td align="right">0.181</td>
<td align="right">0.003</td>
</tr>
</tbody>
</table>
<p>We see the MCSEs are quite small relative to the linear regression bias term and all the SEs (<code>stddev</code>) and RMSEs: we have simulated enough runs to see the gross trends identified.
We have <em>not</em> simulated enough to for sure know if MLM and Agg are not slightly biased. Given our MCSEs, they could have true bias of around 0.01 (two MCSEs).</p>
</div>
</div>
<div id="exercises-6" class="section level2 hasAnchor" number="9.8">
<h2 class="hasAnchor"><span class="header-section-number">9.8</span> Exercises<a href="#exercises-6" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<ol style="list-style-type: decimal">
<li><p>Continuing the exercises from the prior chapters, estimate rejection rates of the BFF* test for the parameter values in the fifth line of Table 1 of Brown and Forsythe (1974).</p></li>
<li><p>Implement the jackknife as described above in code. Check your answers against the <code>simhelpers</code> package for the built-in <code>t_res</code> dataset:</p></li>
</ol>
<div class="sourceCode" id="cb328"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb328-1"><a href="#cb328-1" tabindex="-1"></a><span class="fu">library</span>( simhelpers )</span>
<span id="cb328-2"><a href="#cb328-2" tabindex="-1"></a><span class="fu">calc_relative</span>(<span class="at">data =</span> t_res, <span class="at">estimates =</span> est, <span class="at">true_param =</span> true_param)</span></code></pre></div>
<pre><code>## # A tibble: 1 × 7
##   K_relative rel_bias rel_bias_mcse rel_mse
##        &lt;int&gt;    &lt;dbl&gt;         &lt;dbl&gt;   &lt;dbl&gt;
## 1       1000     1.00        0.0128   0.163
## # ℹ 3 more variables: rel_mse_mcse &lt;dbl&gt;,
## #   rel_rmse &lt;dbl&gt;, rel_rmse_mcse &lt;dbl&gt;</code></pre>
<ol start="3" style="list-style-type: decimal">
<li>As foreground to the following chapters, can you explore multiple scenarios for the cluster RCT example to see if the trends are common? First write a function that takes a parameter, runs the entire simulation, and returns the results as a small table. You pick which parameter, e.g., average treatment effect, <code>alpha</code>, or whatever you like), that you wish to vary. Here is a skeleton for the function:</li>
</ol>
<div class="sourceCode" id="cb330"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb330-1"><a href="#cb330-1" tabindex="-1"></a>my_simulation <span class="ot">&lt;-</span> <span class="cf">function</span>( my_param ) {</span>
<span id="cb330-2"><a href="#cb330-2" tabindex="-1"></a>  <span class="co"># call the sim_function() simulation function from the end of last</span></span>
<span id="cb330-3"><a href="#cb330-3" tabindex="-1"></a>  <span class="co"># chapter, setting the parameter you want to vary to my_param</span></span>
<span id="cb330-4"><a href="#cb330-4" tabindex="-1"></a>  </span>
<span id="cb330-5"><a href="#cb330-5" tabindex="-1"></a>  <span class="co"># Analyze the results, generating a table of performance metrics,</span></span>
<span id="cb330-6"><a href="#cb330-6" tabindex="-1"></a>  <span class="co"># e.g., bias or coverage. Make sure your analysis is a data frame,</span></span>
<span id="cb330-7"><a href="#cb330-7" tabindex="-1"></a>  <span class="co"># like we saw earlier this chapter.</span></span>
<span id="cb330-8"><a href="#cb330-8" tabindex="-1"></a>  </span>
<span id="cb330-9"><a href="#cb330-9" tabindex="-1"></a>  <span class="co"># Return results</span></span>
<span id="cb330-10"><a href="#cb330-10" tabindex="-1"></a>}</span></code></pre></div>
<p>Then use code like the following to generate a set of results measured as a function of a varying parameter:</p>
<div class="sourceCode" id="cb331"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb331-1"><a href="#cb331-1" tabindex="-1"></a>vals <span class="ot">=</span> <span class="fu">seq</span>( start, stop, <span class="at">length.out =</span> <span class="dv">5</span> )</span>
<span id="cb331-2"><a href="#cb331-2" tabindex="-1"></a>res <span class="ot">=</span> <span class="fu">map_df</span>( vals, my_simulation ) </span></code></pre></div>
<p>The above code will give you a data frame of results, one column for each performance measure.
Finally, you can use this table and plot the performance measure as a function of the varying parameter.</p>
<!--chapter:end:040-Performance-criteria.Rmd-->
</div>
</div>
<div id="case_Cronbach" class="section level1 hasAnchor" number="10">
<h1 class="hasAnchor"><span class="header-section-number">10</span> Project: Cronbach Alpha<a href="#case_Cronbach" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p>In this section we walk through a case study of Cronbach Alpha to give an extended “project,” or series of exercises, that walk you through writing a complete simulation starting with the filling out of the code skeleton we get from <code>simhelpers</code>’s <code>create_skeleton()</code> package.</p>
<div id="background" class="section level2 hasAnchor" number="10.1">
<h2 class="hasAnchor"><span class="header-section-number">10.1</span> Background<a href="#background" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Cronbach’s <span class="math inline">\(\alpha\)</span> coefficient is commonly reported as a measure of the internal consistency among a set of test items. Consider a set of <span class="math inline">\(p\)</span> test items with population variance-covariance matrix <span class="math inline">\(\boldsymbol\Phi = \left[\phi_{ij}\right]_{i,j=1}^p\)</span>, where <span class="math inline">\(\phi_{ij}\)</span> is the covariance of item <span class="math inline">\(i\)</span> and item <span class="math inline">\(j\)</span> on the test, across all students taking the test.
This population variance-covariance matrix describes how our <span class="math inline">\(p\)</span> test items co-vary.</p>
<p>Cronback’s <span class="math inline">\(\alpha\)</span> is, under this model, defined as
<span class="math display">\[
\alpha = \frac{p}{p - 1}\left(1 - \frac{\sum_{i=1}^p \phi_{ii}}{\sum_{i=1}^p \sum_{j=1}^p \phi_{ij}}\right).
\]</span></p>
<p>Given a sample of size <span class="math inline">\(n\)</span>, the usual estimate of <span class="math inline">\(\alpha\)</span> is obtained by replacing the population variances and covariances with corresponding sample estimates. Letting <span class="math inline">\(s_{ij}\)</span> denote the sample covariance of items <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span></p>
<p><span class="math display">\[
A = \frac{p}{p - 1}\left(1 - \frac{\sum_{i=1}^p s_{ii}}{\sum_{i=1}^p \sum_{j=1}^p s_{ij}}\right).
\]</span></p>
<p>If we assume that the items follow a multivariate normal distribution, then <span class="math inline">\(A\)</span> corresponds to the maximum likelihood estimator of <span class="math inline">\(\alpha\)</span>.</p>
<p>Our goal is to examine the properties of our estimator <span class="math inline">\(A\)</span> when the set of <span class="math inline">\(P\)</span> items is <em>not</em> multi-variate normal, but rather follows a multivariate <span class="math inline">\(t\)</span> distribution with <span class="math inline">\(v\)</span> degrees of freedom.
For simplicity, we shall assume that the items have common variance and have a <strong>compound symmetric</strong> covariance matrix, such that <span class="math inline">\(\phi_{11} = \phi_{22} = \cdots = \phi_{pp} = \phi\)</span> and <span class="math inline">\(\phi_{ij} = \rho \phi\)</span>. In this case we can simplify our expression for <span class="math inline">\(\alpha\)</span> to</p>
<p><span class="math display">\[
\alpha = \frac{p \rho}{1 + \rho (p - 1)}.
\]</span></p>
<p>In particular, we are interested in whether <span class="math inline">\(A\)</span> is a biased estimator for <span class="math inline">\(\alpha\)</span>, when we have items that are not multi-variate normal.
We are also interested in the standard error of <span class="math inline">\(A\)</span>, and how that changes as features of our DGP change.
Finally, we have a corresponding asymptotic variance estimator to get estimated standard errors for <span class="math inline">\(A\)</span>, and we want to know if this variance estimator has generally good properties as well.</p>
</div>
<div id="getting-started" class="section level2 hasAnchor" number="10.2">
<h2 class="hasAnchor"><span class="header-section-number">10.2</span> Getting started<a href="#getting-started" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>First create the skeleton of our simulation.
We will then walk through filling in all the pieces.</p>
<div class="sourceCode" id="cb332"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb332-1"><a href="#cb332-1" tabindex="-1"></a><span class="fu">library</span>( simhelpers )</span>
<span id="cb332-2"><a href="#cb332-2" tabindex="-1"></a><span class="fu">create_skeleton</span>()</span></code></pre></div>
</div>
<div id="the-data-generating-function" class="section level2 hasAnchor" number="10.3">
<h2 class="hasAnchor"><span class="header-section-number">10.3</span> The data-generating function<a href="#the-data-generating-function" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>The first two sections in the skeleton are about the data-generating model:</p>
<div class="sourceCode" id="cb333"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb333-1"><a href="#cb333-1" tabindex="-1"></a><span class="fu">rm</span>(<span class="at">list =</span> <span class="fu">ls</span>())</span>
<span id="cb333-2"><a href="#cb333-2" tabindex="-1"></a></span>
<span id="cb333-3"><a href="#cb333-3" tabindex="-1"></a><span class="co">#------------------------------------------------------</span></span>
<span id="cb333-4"><a href="#cb333-4" tabindex="-1"></a><span class="co"># Set development values for simulation parameters</span></span>
<span id="cb333-5"><a href="#cb333-5" tabindex="-1"></a><span class="co">#------------------------------------------------------</span></span>
<span id="cb333-6"><a href="#cb333-6" tabindex="-1"></a></span>
<span id="cb333-7"><a href="#cb333-7" tabindex="-1"></a><span class="co"># What are your model parameters?</span></span>
<span id="cb333-8"><a href="#cb333-8" tabindex="-1"></a><span class="co"># What are your design parameters?</span></span>
<span id="cb333-9"><a href="#cb333-9" tabindex="-1"></a></span>
<span id="cb333-10"><a href="#cb333-10" tabindex="-1"></a><span class="co">#------------------------------------------------------</span></span>
<span id="cb333-11"><a href="#cb333-11" tabindex="-1"></a><span class="co"># Data Generating Model</span></span>
<span id="cb333-12"><a href="#cb333-12" tabindex="-1"></a><span class="co">#------------------------------------------------------</span></span>
<span id="cb333-13"><a href="#cb333-13" tabindex="-1"></a></span>
<span id="cb333-14"><a href="#cb333-14" tabindex="-1"></a>dgm <span class="ot">&lt;-</span> <span class="cf">function</span>(model_params) {</span>
<span id="cb333-15"><a href="#cb333-15" tabindex="-1"></a></span>
<span id="cb333-16"><a href="#cb333-16" tabindex="-1"></a>  <span class="fu">return</span>(dat)</span>
<span id="cb333-17"><a href="#cb333-17" tabindex="-1"></a>}</span>
<span id="cb333-18"><a href="#cb333-18" tabindex="-1"></a></span>
<span id="cb333-19"><a href="#cb333-19" tabindex="-1"></a><span class="co"># Test the data-generating model - How can you verify that it is correct?</span></span></code></pre></div>
<p>We need to create and test a function that takes model parameters (and sample sizes and such) as inputs, and produces a simulated dataset.
The following function generates a sample of <span class="math inline">\(n\)</span> observations of <span class="math inline">\(p\)</span> items from a multivariate <span class="math inline">\(t\)</span>-distribution with a compound symmetric covariance matrix, intra-class correlation <span class="math inline">\(\rho\)</span>, and <span class="math inline">\(v\)</span> degrees of freedom:</p>
<div class="sourceCode" id="cb334"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb334-1"><a href="#cb334-1" tabindex="-1"></a><span class="co"># model parameters</span></span>
<span id="cb334-2"><a href="#cb334-2" tabindex="-1"></a>alpha <span class="ot">&lt;-</span> <span class="fl">0.73</span> <span class="co"># true alpha</span></span>
<span id="cb334-3"><a href="#cb334-3" tabindex="-1"></a>df <span class="ot">&lt;-</span> <span class="dv">12</span> <span class="co"># degrees of freedom</span></span>
<span id="cb334-4"><a href="#cb334-4" tabindex="-1"></a></span>
<span id="cb334-5"><a href="#cb334-5" tabindex="-1"></a><span class="co"># design parameters</span></span>
<span id="cb334-6"><a href="#cb334-6" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="dv">50</span> <span class="co"># sample size</span></span>
<span id="cb334-7"><a href="#cb334-7" tabindex="-1"></a>p <span class="ot">&lt;-</span> <span class="dv">6</span> <span class="co"># number of items</span></span>
<span id="cb334-8"><a href="#cb334-8" tabindex="-1"></a></span>
<span id="cb334-9"><a href="#cb334-9" tabindex="-1"></a></span>
<span id="cb334-10"><a href="#cb334-10" tabindex="-1"></a><span class="fu">library</span>(mvtnorm)</span>
<span id="cb334-11"><a href="#cb334-11" tabindex="-1"></a></span>
<span id="cb334-12"><a href="#cb334-12" tabindex="-1"></a>r_mvt_items <span class="ot">&lt;-</span> <span class="cf">function</span>(n, p, alpha, df) {</span>
<span id="cb334-13"><a href="#cb334-13" tabindex="-1"></a>  icc <span class="ot">&lt;-</span> alpha <span class="sc">/</span> (p <span class="sc">-</span> alpha <span class="sc">*</span> (p <span class="sc">-</span> <span class="dv">1</span>))</span>
<span id="cb334-14"><a href="#cb334-14" tabindex="-1"></a>  V_mat <span class="ot">&lt;-</span> icc <span class="sc">+</span> <span class="fu">diag</span>(<span class="dv">1</span> <span class="sc">-</span> icc, <span class="at">nrow =</span> p)</span>
<span id="cb334-15"><a href="#cb334-15" tabindex="-1"></a>  X <span class="ot">&lt;-</span> <span class="fu">rmvt</span>(<span class="at">n =</span> n, <span class="at">sigma =</span> V_mat, <span class="at">df =</span> df)</span>
<span id="cb334-16"><a href="#cb334-16" tabindex="-1"></a>  <span class="fu">colnames</span>(X) <span class="ot">&lt;-</span> LETTERS[<span class="dv">1</span><span class="sc">:</span>p]</span>
<span id="cb334-17"><a href="#cb334-17" tabindex="-1"></a>  X</span>
<span id="cb334-18"><a href="#cb334-18" tabindex="-1"></a>}</span></code></pre></div>
<p>Note how we translate the target <span class="math inline">\(\alpha\)</span> to <span class="math inline">\(ICC\)</span> for our DGP; we will see this type of translation more later on.</p>
<p>We check our method first to see if we get the right kind of data:</p>
<div class="sourceCode" id="cb335"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb335-1"><a href="#cb335-1" tabindex="-1"></a>small_sample <span class="ot">&lt;-</span> <span class="fu">r_mvt_items</span>(<span class="at">n =</span> <span class="dv">8</span>, <span class="at">p =</span> <span class="dv">3</span>, <span class="at">alpha =</span> <span class="fl">0.73</span>, <span class="at">df =</span> <span class="dv">5</span>)</span>
<span id="cb335-2"><a href="#cb335-2" tabindex="-1"></a>small_sample</span></code></pre></div>
<pre><code>##                A           B           C
## [1,]  0.84178327  0.79667212  0.89763338
## [2,] -0.22368394  0.03461279  0.18828500
## [3,] -1.04857817  1.57395368 -0.45917554
## [4,] -0.62138749 -1.71804224  0.07028801
## [5,]  1.01420764  0.82780069  0.27966729
## [6,] -0.09936605  0.29165411  0.60147379
## [7,]  1.55303030  0.64559263  1.27739829
## [8,]  2.54590497  0.69538104  1.48876612</code></pre>
<p>It looks like we have 8 observations of 3 items, as desired.</p>
<p>To check that the function is indeed simulating data following the intended distribution, let’s next generate a very large sample of items. We can then verify that the correlation matrix of the items is compound-symmetric and that the marginal distributions of the items follow <span class="math inline">\(t\)</span>-distributions with specified degrees of freedom.</p>
<div class="sourceCode" id="cb337"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb337-1"><a href="#cb337-1" tabindex="-1"></a>big_sample <span class="ot">&lt;-</span> <span class="fu">r_mvt_items</span>(<span class="at">n =</span> <span class="dv">100000</span>, <span class="at">p =</span> <span class="dv">4</span>, <span class="at">alpha =</span> <span class="fl">0.73</span>, <span class="at">df =</span> <span class="dv">5</span>)</span>
<span id="cb337-2"><a href="#cb337-2" tabindex="-1"></a><span class="fu">round</span>(<span class="fu">cor</span>(big_sample), <span class="dv">3</span>)</span></code></pre></div>
<pre><code>##       A     B     C     D
## A 1.000 0.403 0.402 0.403
## B 0.403 1.000 0.409 0.403
## C 0.402 0.409 1.000 0.408
## D 0.403 0.403 0.408 1.000</code></pre>
<p>Is this what it should look like?</p>
<p>We can also check normality:</p>
<div class="sourceCode" id="cb339"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb339-1"><a href="#cb339-1" tabindex="-1"></a><span class="fu">qqplot</span>(<span class="fu">qt</span>(<span class="fu">ppoints</span>(<span class="dv">200</span>), <span class="at">df =</span> <span class="dv">5</span>), big_sample[,<span class="dv">2</span>], <span class="at">ylim =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">4</span>,<span class="dv">4</span>))</span></code></pre></div>
<p><img src="Designing-Simulations-in-R_files/figure-html/unnamed-chunk-190-1.png" width="75%" style="display: block; margin: auto;" /></p>
<p>Looks good! A nice straight line.</p>
</div>
<div id="the-estimation-function" class="section level2 hasAnchor" number="10.4">
<h2 class="hasAnchor"><span class="header-section-number">10.4</span> The estimation function<a href="#the-estimation-function" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>The next section of the template looks like this:</p>
<div class="sourceCode" id="cb340"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb340-1"><a href="#cb340-1" tabindex="-1"></a><span class="co">#------------------------------------------------------</span></span>
<span id="cb340-2"><a href="#cb340-2" tabindex="-1"></a><span class="co"># Model-fitting/estimation/testing functions</span></span>
<span id="cb340-3"><a href="#cb340-3" tabindex="-1"></a><span class="co">#------------------------------------------------------</span></span>
<span id="cb340-4"><a href="#cb340-4" tabindex="-1"></a></span>
<span id="cb340-5"><a href="#cb340-5" tabindex="-1"></a>estimate <span class="ot">&lt;-</span> <span class="cf">function</span>(dat, design_params) {</span>
<span id="cb340-6"><a href="#cb340-6" tabindex="-1"></a></span>
<span id="cb340-7"><a href="#cb340-7" tabindex="-1"></a>  <span class="fu">return</span>(result)</span>
<span id="cb340-8"><a href="#cb340-8" tabindex="-1"></a>}</span>
<span id="cb340-9"><a href="#cb340-9" tabindex="-1"></a></span>
<span id="cb340-10"><a href="#cb340-10" tabindex="-1"></a><span class="co"># Test the estimation function</span></span></code></pre></div>
<p>van Zyl, Neudecker, and Nel (2000) demonstrate that, if the items have a compound-symmetric covariance matrix, then the asymptotic variance of <span class="math inline">\(A\)</span> is
<span class="math display">\[
\text{Var}(A) \approx \frac{2p(1 - \alpha)^2}{(p - 1) n}.
\]</span>
Substituting <span class="math inline">\(A\)</span> in place of <span class="math inline">\(\alpha\)</span> on the right hand side gives an estimate of the variance of <span class="math inline">\(A\)</span>. The following function calculates <span class="math inline">\(A\)</span> and its variance estimator from a sample of data:</p>
<div class="sourceCode" id="cb341"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb341-1"><a href="#cb341-1" tabindex="-1"></a>estimate_alpha <span class="ot">&lt;-</span> <span class="cf">function</span>(dat) {</span>
<span id="cb341-2"><a href="#cb341-2" tabindex="-1"></a>  V <span class="ot">&lt;-</span> <span class="fu">cov</span>(dat)</span>
<span id="cb341-3"><a href="#cb341-3" tabindex="-1"></a>  p <span class="ot">&lt;-</span> <span class="fu">ncol</span>(dat)</span>
<span id="cb341-4"><a href="#cb341-4" tabindex="-1"></a>  n <span class="ot">&lt;-</span> <span class="fu">nrow</span>(dat)</span>
<span id="cb341-5"><a href="#cb341-5" tabindex="-1"></a>  </span>
<span id="cb341-6"><a href="#cb341-6" tabindex="-1"></a>  <span class="co"># Calculate A with our formula</span></span>
<span id="cb341-7"><a href="#cb341-7" tabindex="-1"></a>  A <span class="ot">&lt;-</span> p <span class="sc">/</span> (p <span class="sc">-</span> <span class="dv">1</span>) <span class="sc">*</span> (<span class="dv">1</span> <span class="sc">-</span> <span class="fu">sum</span>(<span class="fu">diag</span>(V)) <span class="sc">/</span> <span class="fu">sum</span>(V))</span>
<span id="cb341-8"><a href="#cb341-8" tabindex="-1"></a>  </span>
<span id="cb341-9"><a href="#cb341-9" tabindex="-1"></a>  <span class="co"># Calculate our estimate of the variance (SE^2) of A</span></span>
<span id="cb341-10"><a href="#cb341-10" tabindex="-1"></a>  Var_A <span class="ot">&lt;-</span> <span class="dv">2</span> <span class="sc">*</span> p <span class="sc">*</span> (<span class="dv">1</span> <span class="sc">-</span> A)<span class="sc">^</span><span class="dv">2</span> <span class="sc">/</span> ((p <span class="sc">-</span> <span class="dv">1</span>) <span class="sc">*</span> n)</span>
<span id="cb341-11"><a href="#cb341-11" tabindex="-1"></a>  </span>
<span id="cb341-12"><a href="#cb341-12" tabindex="-1"></a>  <span class="co"># Pack up our results</span></span>
<span id="cb341-13"><a href="#cb341-13" tabindex="-1"></a>  <span class="fu">data.frame</span>(<span class="at">A =</span> A, <span class="at">Var =</span> Var_A)</span>
<span id="cb341-14"><a href="#cb341-14" tabindex="-1"></a>}</span>
<span id="cb341-15"><a href="#cb341-15" tabindex="-1"></a></span>
<span id="cb341-16"><a href="#cb341-16" tabindex="-1"></a><span class="fu">estimate_alpha</span>(small_sample)</span></code></pre></div>
<pre><code>##           A       Var
## 1 0.6503423 0.0458477</code></pre>
<p>The <code>psych</code> package provides a function for calculating <span class="math inline">\(\alpha\)</span>, which can be used to verify that the calculation of <span class="math inline">\(A\)</span> in <code>estimate_alpha</code> is correct:</p>
<div class="sourceCode" id="cb343"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb343-1"><a href="#cb343-1" tabindex="-1"></a><span class="fu">library</span>(psych)</span>
<span id="cb343-2"><a href="#cb343-2" tabindex="-1"></a><span class="fu">summary</span>(<span class="fu">alpha</span>(<span class="at">x =</span> small_sample))<span class="sc">$</span>raw_alpha</span></code></pre></div>
<pre><code>## Number of categories should be increased  in order to count frequencies.</code></pre>
<pre><code>## 
## Reliability analysis   
##  raw_alpha std.alpha G6(smc) average_r S/N ase
##       0.65      0.69    0.79      0.42 2.2 0.2
##  mean   sd median_r
##  0.48 0.74     0.26</code></pre>
<pre><code>## NULL</code></pre>
<p>The next step is to evaluate these individual estimates and see how well our estimator <span class="math inline">\(A\)</span> performs.</p>
<div id="exercises-naive-confidence-intervals" class="section level3 hasAnchor" number="10.4.1">
<h3 class="hasAnchor"><span class="header-section-number">10.4.1</span> Exercises (Naive confidence intervals)<a href="#exercises-naive-confidence-intervals" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<ol style="list-style-type: decimal">
<li>One way to obtain an approximate confidence interval for <span class="math inline">\(\alpha\)</span> would be to take <span class="math inline">\(A \pm z \sqrt{\text{Var}(A)}\)</span>, where <span class="math inline">\(\text{Var}(A)\)</span> is estimated as described above and <span class="math inline">\(z\)</span> is a standard normal critical value at the appropriate level (i.e., <span class="math inline">\(z = 1.96\)</span> for a 95% CI).
Extend your simulation to calculate a confidence interval for each simulation round (put this code inside <code>estimate_alpha()</code>) and then calculate confidence interval coverage.</li>
</ol>
<p>Your <code>estimate_alpha</code> would then give a result like this:</p>
<div class="sourceCode" id="cb347"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb347-1"><a href="#cb347-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">40200</span>)</span>
<span id="cb347-2"><a href="#cb347-2" tabindex="-1"></a>dat <span class="ot">=</span> <span class="fu">r_mvt_items</span>(<span class="at">n =</span> <span class="dv">50</span>, <span class="at">p =</span> <span class="dv">5</span>, <span class="at">alpha =</span> <span class="fl">0.9</span>, <span class="at">df =</span> <span class="dv">3</span> )</span>
<span id="cb347-3"><a href="#cb347-3" tabindex="-1"></a><span class="fu">estimate_alpha</span>(dat)</span></code></pre></div>
<pre><code>##           A          Var   CI_low   CI_high
## 1 0.9425904 0.0001647933 0.916916 0.9682647</code></pre>
<ol start="2" style="list-style-type: decimal">
<li>You can calculate confidence intervals with coverage other than 95% by calculating an appropriate number of standard errors, <span class="math inline">\(z\)</span> (usually just taken as 2, as above, for a nominal 95%), with</li>
</ol>
<div class="sourceCode" id="cb349"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb349-1"><a href="#cb349-1" tabindex="-1"></a>coverage <span class="ot">=</span> <span class="fl">0.95</span></span>
<span id="cb349-2"><a href="#cb349-2" tabindex="-1"></a>z <span class="ot">=</span> <span class="fu">qnorm</span>( (<span class="dv">1</span><span class="sc">-</span>coverage) <span class="sc">/</span> <span class="dv">2</span>, <span class="at">lower.tail =</span> <span class="cn">FALSE</span> )</span>
<span id="cb349-3"><a href="#cb349-3" tabindex="-1"></a>z</span></code></pre></div>
<pre><code>## [1] 1.959964</code></pre>
<p>Extend <code>estimate_alpha()</code> to allow for a specified coverage by adding a parameter, <code>coverage</code>, along with a default of 0.95. Revise the body of <code>estimate_alpha</code> to calculate a confidence interval with the specified coverage rate.</p>
</div>
</div>
<div id="estimator-performance" class="section level2 hasAnchor" number="10.5">
<h2 class="hasAnchor"><span class="header-section-number">10.5</span> Estimator performance<a href="#estimator-performance" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>The next section of the template deals with performance calculations.</p>
<div class="sourceCode" id="cb351"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb351-1"><a href="#cb351-1" tabindex="-1"></a><span class="co">#------------------------------------------------------</span></span>
<span id="cb351-2"><a href="#cb351-2" tabindex="-1"></a><span class="co"># Calculate performance measures</span></span>
<span id="cb351-3"><a href="#cb351-3" tabindex="-1"></a><span class="co"># (For some simulations, it may make more sense</span></span>
<span id="cb351-4"><a href="#cb351-4" tabindex="-1"></a><span class="co"># to do this as part of the simulation driver.)</span></span>
<span id="cb351-5"><a href="#cb351-5" tabindex="-1"></a><span class="co">#------------------------------------------------------</span></span>
<span id="cb351-6"><a href="#cb351-6" tabindex="-1"></a></span>
<span id="cb351-7"><a href="#cb351-7" tabindex="-1"></a>performance <span class="ot">&lt;-</span> <span class="cf">function</span>(results, model_params) {</span>
<span id="cb351-8"><a href="#cb351-8" tabindex="-1"></a></span>
<span id="cb351-9"><a href="#cb351-9" tabindex="-1"></a>  <span class="fu">return</span>(performance_measures)</span>
<span id="cb351-10"><a href="#cb351-10" tabindex="-1"></a>}</span>
<span id="cb351-11"><a href="#cb351-11" tabindex="-1"></a></span>
<span id="cb351-12"><a href="#cb351-12" tabindex="-1"></a><span class="co"># Check performance calculations</span></span></code></pre></div>
<p>The <code>performance()</code> function takes as input a bunch of simulated data (which we might call <code>results</code>) and the true values of the model parameters (<code>model_params</code>) and returns as output a set of summary performance measures. As noted in the comments above, for simple simulations it might not be necessary to write a separate function to do these calculations. For more complex simulations, though, it can be helpful to break these calculations out in a function.</p>
<p>To start to get the code working that we would put into this function, it is useful to start with some simulation replicates to practice on.
We can generate 1000 replicates using samples of size <span class="math inline">\(n = 40\)</span>, <span class="math inline">\(p = 6\)</span> items, a true <span class="math inline">\(\alpha = 0.8\)</span>, and <span class="math inline">\(v = 5\)</span> degrees of freedom.
We use the <code>simhelpers</code> <code>repeat_and_stack()</code> method to do our replication:</p>
<div class="sourceCode" id="cb352"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb352-1"><a href="#cb352-1" tabindex="-1"></a>one_run <span class="ot">&lt;-</span> <span class="cf">function</span>( n, p, alpha, df ) {</span>
<span id="cb352-2"><a href="#cb352-2" tabindex="-1"></a>  dat <span class="ot">&lt;-</span> <span class="fu">r_mvt_items</span>(<span class="at">n =</span> n, <span class="at">p =</span> p, <span class="at">alpha =</span> alpha, <span class="at">df =</span> df)</span>
<span id="cb352-3"><a href="#cb352-3" tabindex="-1"></a>  <span class="fu">estimate_alpha</span>(dat)</span>
<span id="cb352-4"><a href="#cb352-4" tabindex="-1"></a>}</span>
<span id="cb352-5"><a href="#cb352-5" tabindex="-1"></a>true_alpha <span class="ot">=</span> <span class="fl">0.7</span></span>
<span id="cb352-6"><a href="#cb352-6" tabindex="-1"></a>results <span class="ot">=</span> <span class="fu">repeat_and_stack</span>( <span class="dv">1000</span>, </span>
<span id="cb352-7"><a href="#cb352-7" tabindex="-1"></a>                            <span class="fu">one_run</span>(<span class="dv">40</span>, <span class="dv">6</span>, <span class="at">alpha=</span>true_alpha, <span class="at">df=</span><span class="dv">5</span>) ) <span class="sc">%&gt;%</span></span>
<span id="cb352-8"><a href="#cb352-8" tabindex="-1"></a>  <span class="fu">bind_rows</span>()</span></code></pre></div>
<div id="exercises-calculating-performance" class="section level3 hasAnchor" number="10.5.1">
<h3 class="hasAnchor"><span class="header-section-number">10.5.1</span> Exercises (Calculating Performance)<a href="#exercises-calculating-performance" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>For the Cronbach alpha simulation, we might want to calculate the following performance measures:</p>
<ol style="list-style-type: decimal">
<li><p>With the parameters specified above, calculate the bias of <span class="math inline">\(A\)</span>. Also calculate the Monte Carlo standard error (MCSE) of the bias estimate.</p></li>
<li><p>Estimate the true Standard Error of <span class="math inline">\(A\)</span>.</p></li>
<li><p>Calculate the mean squared error of <span class="math inline">\(A\)</span>.</p></li>
<li><p>Calculate the relative bias of the asymptotic variance estimator.</p></li>
<li><p>Using the work from above, wrap your code in an <code>alpha_performance()</code> function that takes the simulation results returned by <code>run_alpha_sim</code> and returns a one-row data frame with columns corresponding to the bias, mean squared error, and relative bias of the asymptotic variance estimator.</p></li>
</ol>
<p>E.g., a function that behaves like so:</p>
<div class="sourceCode" id="cb353"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb353-1"><a href="#cb353-1" tabindex="-1"></a><span class="fu">alpha_performance</span>(results, true_alpha)</span></code></pre></div>
<pre><code>##          bias     bias_SE        SE       MSE
## 1 -0.02329445 0.003741931 0.1183302 0.1205433
##    bias_Var
## 1 0.5078144</code></pre>
<ol start="6" style="list-style-type: decimal">
<li><p>Extend your function to add in the MCSEs for the SE and MSE. Code up the skewness and kurtosis values by hand, using the formula in the MCSE section of the performance measure chapter.</p></li>
<li><p><strong>(Challenge problem)</strong> Code up a jackknife MCSE function to calculate the MCSE for the relative bias of the asymptotic variance estimator.
Use the following template that takes a vector of point estimates and associated standard errors.</p></li>
</ol>
<div class="sourceCode" id="cb355"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb355-1"><a href="#cb355-1" tabindex="-1"></a>jackknife_MCSE <span class="ot">&lt;-</span> <span class="cf">function</span>( estimates, SEs ) {</span>
<span id="cb355-2"><a href="#cb355-2" tabindex="-1"></a>  <span class="co"># code</span></span>
<span id="cb355-3"><a href="#cb355-3" tabindex="-1"></a>}</span></code></pre></div>
<p>You would use this function as:</p>
<div class="sourceCode" id="cb356"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb356-1"><a href="#cb356-1" tabindex="-1"></a><span class="fu">jackknife_MCSE</span>( alpha_reps<span class="sc">$</span>A, <span class="fu">sqrt</span>( alpha_reps<span class="sc">$</span>Var ) )</span></code></pre></div>
</div>
</div>
<div id="replication-and-the-simulation" class="section level2 hasAnchor" number="10.6">
<h2 class="hasAnchor"><span class="header-section-number">10.6</span> Replication (and the simulation)<a href="#replication-and-the-simulation" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>We now have all the components we need to get simulation results, given a set of parameter values.
In the next section of the template, we put all these pieces together in a function—which we might call the <em>simulation driver</em>—that takes as input 1) parameter values, 2) the desired number of replications, and 3) optionally, a seed value (this allows for reproducability, see Chapter @ref(sec-reproducability). The function produces as output a single set of performance estimates. Generically, the function looks like this:</p>
<div class="sourceCode" id="cb357"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb357-1"><a href="#cb357-1" tabindex="-1"></a><span class="co">#-----------------------------------------------------------</span></span>
<span id="cb357-2"><a href="#cb357-2" tabindex="-1"></a><span class="co"># Simulation Driver - should return a data.frame or tibble</span></span>
<span id="cb357-3"><a href="#cb357-3" tabindex="-1"></a><span class="co">#-----------------------------------------------------------</span></span>
<span id="cb357-4"><a href="#cb357-4" tabindex="-1"></a></span>
<span id="cb357-5"><a href="#cb357-5" tabindex="-1"></a>runSim <span class="ot">&lt;-</span> <span class="cf">function</span>(iterations, model_params, design_params, <span class="at">seed =</span> <span class="cn">NULL</span>) {</span>
<span id="cb357-6"><a href="#cb357-6" tabindex="-1"></a>  <span class="cf">if</span> (<span class="sc">!</span><span class="fu">is.null</span>(seed)) <span class="fu">set.seed</span>(seed)</span>
<span id="cb357-7"><a href="#cb357-7" tabindex="-1"></a></span>
<span id="cb357-8"><a href="#cb357-8" tabindex="-1"></a>  results <span class="ot">&lt;-</span> <span class="fu">rerun</span>(iterations, {</span>
<span id="cb357-9"><a href="#cb357-9" tabindex="-1"></a>                dat <span class="ot">&lt;-</span> <span class="fu">dgm</span>(model_params)</span>
<span id="cb357-10"><a href="#cb357-10" tabindex="-1"></a>                <span class="fu">estimate</span>(dat, design_params)</span>
<span id="cb357-11"><a href="#cb357-11" tabindex="-1"></a>              }) <span class="sc">%&gt;%</span></span>
<span id="cb357-12"><a href="#cb357-12" tabindex="-1"></a>    <span class="fu">bind_rows</span>()</span>
<span id="cb357-13"><a href="#cb357-13" tabindex="-1"></a>  </span>
<span id="cb357-14"><a href="#cb357-14" tabindex="-1"></a></span>
<span id="cb357-15"><a href="#cb357-15" tabindex="-1"></a>  <span class="fu">performance</span>(results, model_params)</span>
<span id="cb357-16"><a href="#cb357-16" tabindex="-1"></a>}</span>
<span id="cb357-17"><a href="#cb357-17" tabindex="-1"></a></span>
<span id="cb357-18"><a href="#cb357-18" tabindex="-1"></a><span class="co"># demonstrate the simulation driver</span></span></code></pre></div>
<p>The <code>runSim</code> function should require very little modification for a new simulation. Essentially, all we need to change is the names of the functions that are called, so that they line up with the functions we have designed for our simulation. Here’s what this looks like for the Cronbach alpha simulation (we pull out the code to replicate into its own method, <code>one_run()</code>, which helps with debugging):</p>
<div class="sourceCode" id="cb358"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb358-1"><a href="#cb358-1" tabindex="-1"></a><span class="co">#-----------------------------------------------------------</span></span>
<span id="cb358-2"><a href="#cb358-2" tabindex="-1"></a><span class="co"># Simulation Driver - should return a data.frame or tibble</span></span>
<span id="cb358-3"><a href="#cb358-3" tabindex="-1"></a><span class="co">#-----------------------------------------------------------</span></span>
<span id="cb358-4"><a href="#cb358-4" tabindex="-1"></a></span>
<span id="cb358-5"><a href="#cb358-5" tabindex="-1"></a></span>
<span id="cb358-6"><a href="#cb358-6" tabindex="-1"></a>one_run <span class="ot">&lt;-</span> <span class="cf">function</span>( n, p, alpha, df ) {</span>
<span id="cb358-7"><a href="#cb358-7" tabindex="-1"></a>    dat <span class="ot">&lt;-</span> <span class="fu">r_mvt_items</span>(<span class="at">n =</span> n, <span class="at">p =</span> p, <span class="at">alpha =</span> alpha, <span class="at">df =</span> df)</span>
<span id="cb358-8"><a href="#cb358-8" tabindex="-1"></a>    <span class="fu">estimate_alpha</span>(dat)</span>
<span id="cb358-9"><a href="#cb358-9" tabindex="-1"></a>}</span>
<span id="cb358-10"><a href="#cb358-10" tabindex="-1"></a></span>
<span id="cb358-11"><a href="#cb358-11" tabindex="-1"></a></span>
<span id="cb358-12"><a href="#cb358-12" tabindex="-1"></a>run_alpha_sim <span class="ot">&lt;-</span> <span class="cf">function</span>(iterations, n, p, alpha, df, <span class="at">seed =</span> <span class="cn">NULL</span>) {</span>
<span id="cb358-13"><a href="#cb358-13" tabindex="-1"></a>  </span>
<span id="cb358-14"><a href="#cb358-14" tabindex="-1"></a>  <span class="cf">if</span> (<span class="sc">!</span><span class="fu">is.null</span>(seed)) <span class="fu">set.seed</span>(seed)</span>
<span id="cb358-15"><a href="#cb358-15" tabindex="-1"></a></span>
<span id="cb358-16"><a href="#cb358-16" tabindex="-1"></a>  results <span class="ot">&lt;-</span> </span>
<span id="cb358-17"><a href="#cb358-17" tabindex="-1"></a>    <span class="fu">rerun</span>(iterations, <span class="fu">one_run</span>(n, p, alpha, df) ) <span class="sc">%&gt;%</span></span>
<span id="cb358-18"><a href="#cb358-18" tabindex="-1"></a>    <span class="fu">bind_rows</span>()</span>
<span id="cb358-19"><a href="#cb358-19" tabindex="-1"></a>  </span>
<span id="cb358-20"><a href="#cb358-20" tabindex="-1"></a>  <span class="fu">alpha_performance</span>(results, <span class="at">alpha =</span> alpha)</span>
<span id="cb358-21"><a href="#cb358-21" tabindex="-1"></a>}</span></code></pre></div>
</div>
<div id="extension-confidence-interval-coverage" class="section level2 hasAnchor" number="10.7">
<h2 class="hasAnchor"><span class="header-section-number">10.7</span> Extension: Confidence interval coverage<a href="#extension-confidence-interval-coverage" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>However, van Zyl, Neudecker, and Nel (2000) suggest that a better approximation involves first applying a transformation to <span class="math inline">\(A\)</span> (to make it more normal in shape), then calculating a confidence interval, then back-transforming to the original scale (this is very similar to the procedure for calculating confidence intervals for correlation coefficients, using Fisher’s <span class="math inline">\(z\)</span> transformation). Let our transformed parameter and estimator be</p>
<p><span class="math display">\[
\begin{aligned}
\beta &amp;= \frac{1}{2} \ln\left(1 - \alpha\right) \\
B &amp;= \frac{1}{2} \ln\left(1 - A\right)
\end{aligned}
\]</span></p>
<p>and our transformed variance estimator be</p>
<p><span class="math display">\[
V^B = \frac{p}{2 n (p - 1)}.
\]</span>
(This expression comes from a Delta method expansion on <span class="math inline">\(A\)</span>.)</p>
<p>An approximate confidence interval for <span class="math inline">\(\beta\)</span> is given by <span class="math inline">\([B_L, B_U]\)</span>, where</p>
<p><span class="math display">\[
B_L = B - z \sqrt{V^B}, \qquad B_U = B + z \sqrt{V^B}.
\]</span></p>
<p>Applying the inverse of the transformation gives a confidence interval for <span class="math inline">\(\alpha\)</span>:</p>
<p><span class="math display">\[
\left[1 - \exp(2B_U), \ 1 - \exp(2 B_L)\right].
\]</span></p>
</div>
<div id="a-taste-of-multiple-scenarios" class="section level2 hasAnchor" number="10.8">
<h2 class="hasAnchor"><span class="header-section-number">10.8</span> A taste of multiple scenarios<a href="#a-taste-of-multiple-scenarios" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>In the previous sections, we’ve created code that will generate a set of performance estimates, given a set of parameter values. We can created a dataset that represents every combination of parameter values that we want to examine. How do we put the pieces together?</p>
<p>If we only had a couple of parameter combinations, it would be easy enough to just call our <code>run_alpha_sim</code> function a couple of times:</p>
<div class="sourceCode" id="cb359"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb359-1"><a href="#cb359-1" tabindex="-1"></a><span class="fu">run_alpha_sim</span>(<span class="at">iterations =</span> <span class="dv">100</span>, <span class="at">n =</span> <span class="dv">50</span>, <span class="at">p =</span> <span class="dv">4</span>, <span class="at">alpha =</span> <span class="fl">0.7</span>, <span class="at">df =</span> <span class="dv">5</span>)</span></code></pre></div>
<pre><code>## Warning: `rerun()` was deprecated in purrr 1.0.0.
## ℹ Please use `map()` instead.
##   # Previously
##   rerun(100, one_run(n, p, alpha, df))
## 
##   # Now
##   map(1:100, ~ one_run(n, p, alpha, df))
## This warning is displayed once every 8 hours.
## Call `lifecycle::last_lifecycle_warnings()` to
## see where this warning was generated.</code></pre>
<pre><code>##          bias    bias_SE        SE       MSE
## 1 -0.01211522 0.01088426 0.1088426 0.1089725
##    bias_Var
## 1 0.4913622</code></pre>
<div class="sourceCode" id="cb362"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb362-1"><a href="#cb362-1" tabindex="-1"></a><span class="fu">run_alpha_sim</span>(<span class="at">iterations =</span> <span class="dv">100</span>, <span class="at">n =</span> <span class="dv">100</span>, <span class="at">p =</span> <span class="dv">4</span>, <span class="at">alpha =</span> <span class="fl">0.7</span>, <span class="at">df =</span> <span class="dv">5</span>)</span></code></pre></div>
<pre><code>##         bias    bias_SE        SE        MSE
## 1 -0.0117337 0.00761985 0.0761985 0.07671916
##    bias_Var
## 1 0.4727169</code></pre>
<div class="sourceCode" id="cb364"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb364-1"><a href="#cb364-1" tabindex="-1"></a><span class="fu">run_alpha_sim</span>(<span class="at">iterations =</span> <span class="dv">100</span>, <span class="at">n =</span> <span class="dv">50</span>, <span class="at">p =</span> <span class="dv">8</span>, <span class="at">alpha =</span> <span class="fl">0.7</span>, <span class="at">df =</span> <span class="dv">5</span>)</span></code></pre></div>
<pre><code>##          bias    bias_SE        SE       MSE
## 1 -0.02601087 0.01120983 0.1120983 0.1145292
##    bias_Var
## 1 0.4319068</code></pre>
<div class="sourceCode" id="cb366"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb366-1"><a href="#cb366-1" tabindex="-1"></a><span class="fu">run_alpha_sim</span>(<span class="at">iterations =</span> <span class="dv">100</span>, <span class="at">n =</span> <span class="dv">100</span>, <span class="at">p =</span> <span class="dv">8</span>, <span class="at">alpha =</span> <span class="fl">0.7</span>, <span class="at">df =</span> <span class="dv">5</span>)</span></code></pre></div>
<pre><code>##          bias     bias_SE         SE        MSE
## 1 0.007758062 0.006203414 0.06203414 0.06220884
##    bias_Var
## 1 0.5299059</code></pre>
<p>But in an actual simulation we will probably have too many different combinations to do this “by hand.”
The final sections of the simulation template demonstrate two different approaches to doing the calculations for <em>every</em> combination of parameter values, given a set of parameter values one wants to explore.</p>
<p>This is discussed further in Chapter @ref(exp_design), but let’s get a small taste of doing this now.
In particular, the following code will evaluate the performance of <span class="math inline">\(A\)</span> for true values of <span class="math inline">\(\alpha\)</span> ranging from 0.5 to 0.9 (i.e., <code>alpha_true_seq &lt;- seq(0.5, 0.9, 0.1)</code>) via <code>map_df()</code>:</p>
<div class="sourceCode" id="cb368"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb368-1"><a href="#cb368-1" tabindex="-1"></a>alpha_true_seq <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="fl">0.5</span>, <span class="fl">0.9</span>, <span class="fl">0.1</span>)</span>
<span id="cb368-2"><a href="#cb368-2" tabindex="-1"></a>results <span class="ot">&lt;-</span> <span class="fu">map_df</span>( alpha_true_seq, </span>
<span id="cb368-3"><a href="#cb368-3" tabindex="-1"></a>                   run_simulation,</span>
<span id="cb368-4"><a href="#cb368-4" tabindex="-1"></a>                   <span class="at">R =</span> <span class="dv">100</span>,</span>
<span id="cb368-5"><a href="#cb368-5" tabindex="-1"></a>                   <span class="at">n =</span> <span class="dv">50</span>, <span class="at">p =</span> <span class="dv">5</span>, <span class="at">df =</span> <span class="dv">5</span> )</span></code></pre></div>
<p>How does coverage change for different values of <span class="math inline">\(A\)</span>?</p>
<div id="exercises-7" class="section level3 hasAnchor" number="10.8.1">
<h3 class="hasAnchor"><span class="header-section-number">10.8.1</span> Exercises<a href="#exercises-7" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<ol style="list-style-type: decimal">
<li><p>Show the inverse transform of <span class="math inline">\(B = g(A)\)</span> gives the above expression.</p></li>
<li><p>Make a new function, <code>estimate_alpha_xform()</code> that, given a dataset, calculates a confidence interval for <span class="math inline">\(\alpha\)</span> following the method described above.</p></li>
<li><p>Using the modified <code>estimate_alpha_xform()</code>, generate 1000 replicated confidence intervals for <span class="math inline">\(n = 40\)</span>, <span class="math inline">\(p = 6\)</span> items, a true <span class="math inline">\(\alpha = 0.8\)</span>, and <span class="math inline">\(v = 5\)</span> degrees of freedom. Using these replicates, calculate the true coverage rate of the confidence interval. Also calculate the Monte Carlo standard error (MCSE) of this coverage rate.</p></li>
<li><p>Calculate the average length of the confidence interval for <span class="math inline">\(\alpha\)</span>, along with its MCSE.</p></li>
<li><p>Compare the results of this approach to the more naive approach. Are there gains in performance?</p></li>
<li><p><em>Challenge</em> Derive the variance expression for the transformed estimator using the Delta method on the variance expression for <span class="math inline">\(A\)</span> coupled with the transform. The Delta method says that:</p></li>
</ol>
<p><span class="math display">\[ var( f(A) ) \approx \frac{1}{f&#39;(\alpha)} (A - \alpha)^2 . \]</span></p>
<!--chapter:end:060-case-study-cronbach-alpha.Rmd-->
</div>
</div>
</div>
<div id="part-multifactor-simulations" class="section level1 unnumbered hasAnchor">
<h1 class="unnumbered hasAnchor">(PART) Multifactor Simulations<a href="#part-multifactor-simulations" class="anchor-section" aria-label="Anchor link to header"></a></h1>
</div>
<div id="exp-design" class="section level1 hasAnchor" number="11">
<h1 class="hasAnchor"><span class="header-section-number">11</span> Designing the multifactor simulation experiment<a href="#exp-design" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p>So far, we have created code that will run a simulation for a single combination of parameter values.
In practice, simulation studies typically examine a range of different values, including varying the level of the true parameter values and perhaps also varying sample sizes, to explore a range of different scenarios.
We either want reassurance that our findings are general, or we want to understand what aspects of the context lead to our found results.
A single simulation gives us no hint as to either of these questions.
It is only by looking across a range of settings that we can fully understand trade-offs, general rules, and limits.
Let’s now look at the remaining piece of the simulation puzzle: the study’s experimental design.</p>
<p>Simulation studies often take the form of <strong>full factorial</strong> designed experiments. In full factorials, each factor (a particular knob a researcher might turn to change the simulation conditions) is varied across multiple levels, and the design includes <em>every</em> possible combination of the levels of every factor. One way to represent such a design is as a list of factors and levels.</p>
<p>For example, for the Cronbach alpha simulation, we might want to vary:</p>
<ul>
<li>the sample size, with values of 50 or 100; and</li>
<li>the number of items, with values of 4 or 8.</li>
<li>the true value of alpha, with values ranging from 0.1 to 0.9;</li>
<li>the degrees of freedom of the multivariate <span class="math inline">\(t\)</span> distribution, with values of 5, 10, 20, or 100;</li>
</ul>
<p>We first express the simulation parameters as a list of factors, each factor having a list of values to explore.
We will then run a simulation for every possible combination of these values.
We call this a <span class="math inline">\(2 \times 2 \times 9 \times 4\)</span> factorial design, where each element is the number of options for that factor.
Here is code that generates all the scenarios we will run given the above design, storing these combinations in a data frame, <code>params</code>, that represents the full experimental design:</p>
<div class="sourceCode" id="cb369"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb369-1"><a href="#cb369-1" tabindex="-1"></a>design_factors <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb369-2"><a href="#cb369-2" tabindex="-1"></a>  <span class="at">n =</span> <span class="fu">c</span>(<span class="dv">50</span>, <span class="dv">100</span>),</span>
<span id="cb369-3"><a href="#cb369-3" tabindex="-1"></a>  <span class="at">p =</span> <span class="fu">c</span>(<span class="dv">4</span>, <span class="dv">8</span>),</span>
<span id="cb369-4"><a href="#cb369-4" tabindex="-1"></a>  <span class="at">alpha =</span> <span class="fu">seq</span>(<span class="fl">0.1</span>, <span class="fl">0.9</span>, <span class="fl">0.1</span>),</span>
<span id="cb369-5"><a href="#cb369-5" tabindex="-1"></a>  <span class="at">df =</span> <span class="fu">c</span>(<span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">100</span>)</span>
<span id="cb369-6"><a href="#cb369-6" tabindex="-1"></a>)</span>
<span id="cb369-7"><a href="#cb369-7" tabindex="-1"></a></span>
<span id="cb369-8"><a href="#cb369-8" tabindex="-1"></a>params <span class="ot">&lt;-</span> <span class="fu">cross_df</span>(design_factors)</span>
<span id="cb369-9"><a href="#cb369-9" tabindex="-1"></a>params</span></code></pre></div>
<pre><code>## # A tibble: 144 × 4
##        n     p alpha    df
##    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1    50     4   0.1     5
##  2   100     4   0.1     5
##  3    50     8   0.1     5
##  4   100     8   0.1     5
##  5    50     4   0.2     5
##  6   100     4   0.2     5
##  7    50     8   0.2     5
##  8   100     8   0.2     5
##  9    50     4   0.3     5
## 10   100     4   0.3     5
## # ℹ 134 more rows</code></pre>
<p>See what we get?
The parameters we would pass to <code>run.experiment()</code> correspond to the
columns of our dataset.
We have a total of <span class="math inline">\(2 \times 2 \times 9 \times 4 = 144\)</span> rows, each row corresponding to a simulation scenario to explore.
With multifactor experiments, it is easy to end up running a lot of experiments!</p>
<div id="choosing-parameter-combinations" class="section level2 hasAnchor" number="11.1">
<h2 class="hasAnchor"><span class="header-section-number">11.1</span> Choosing parameter combinations<a href="#choosing-parameter-combinations" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>How do we go about choosing parameter values to examine?
Choosing which parameters to use is a central part of good simulation design because the primary limitation of simulation studies is always their <em>generalizability</em>.
On the one hand, it’s difficult to extrapolate findings from a simulation study beyond the set of simulation conditions that were examined. On the other hand, it’s often difficult or impossible to examine the full space of all possible parameter values, except for very simple problems. Even in the Cronbach alpha simulation, we’ve got four factors, and the last three could each take an infinite number of different levels, in theory. How can we come up with a defensible set of levels to examine?</p>
<p>The choice of simulation conditions needs to be made in the context of the problem or model that you’re studying, so it’s a bit difficult to offer valid, decontextualized advice.
We can provide a few observations all the same:</p>
<ol style="list-style-type: decimal">
<li><p>For research simulations, it often is important to be able to relate your findings to previous research. This suggests that you should select parameter levels to make this possible, such as by looking at sample sizes similar to those examined in previous studies. That said, previous simulation studies are not always perfect (actually, there’s a lot of really crummy ones out there!), and so prior work should not geneally be your sole guide or justification.</p></li>
<li><p>Generally, it is better to err on the side of being more comprehensive. You learn more by looking at a broader range of conditions, and you can always boil down your results to a more limited set of conditions for purposes of presentation.</p></li>
<li><p>It is also important to explore breakdown points (e.g., what sample size is too small for a method to work?) rather than focusing only on conditions where a method might be expected to work well. Pushing the boundaries and identifying conditions where estimation methods break will help you to provide better guidance for how the methods should be used in practice.</p></li>
</ol>
<p>An important point regarding (2) is that you can be more comprehensive and then have fewer replications per scenario.
For example, say you were planning on doing 1000 simulations per scenario, but then you realize there is some new factor that you don’t think matters, but that you believe other researchers will worry about.
You could add in that factor, say with four levels, and then do 250 simulations per scenario.
The total work remains the same.</p>
<p>When analyzing the final simulation you can then first verify you do not see trends along this new factor, and then marganalize out the factor in your summaries of results.
Marginalizing out a factor (i.e., averaging your performance metrics across the additional factor) is a powerful technique of making a claim about how your methods work <em>on average</em> across a <em>range</em> of scenarios, rather than for a specific scenario.</p>
<p>Overall, you generally want to vary parameters that you believe matter, or that you think other people will believe matter.
The first is so you can learn.
The second is to build your case.</p>
<p>Once you have identified your parameters you then have to decide on the levels of the parameter you will include in the simulation.
There are three strategies you might take:</p>
<ol style="list-style-type: decimal">
<li>Vary a parameter over its entire range (or nearly so).</li>
<li>Choose parameter levels to represent realistic practical range.
<ul>
<li>Empirical justification based on systematic reviews of applications</li>
<li>Or at least informal impressions of what’s realistic in practice</li>
</ul></li>
<li>Choose parameters to emulate one important application.</li>
</ol>
<p>In the above (1) is the most general—but also the most computationally intensive.
(2) will focus attention, ideally, on what is of practical relevance to a practitioner.
(3) is usually coupled with a subsequent applied data analysis, and in this case the simulation is often used to enrich that analysis.
For example, if the simulation shows the methods work for data with the given form of the target application, people may be more willing to believe the application’s findings.</p>
<p>Regardless of how you select your primary parameters, you should also vary nuisance parameters (at least a little) to test sensitivity of results.
While simulations will (generally) never be fully generalizable, you can certainly make them so they avoid the obvious things a critic might identify as an easy dismissal of your findings.</p>
<p>To recap, as you think about your parameter selection, always keep the following design principles and acknowledgements:</p>
<ul>
<li>The primary limitation of simulation studies is <strong>generalizability</strong>.</li>
<li>Choose conditions that allow you to relate findings to previous work.</li>
<li>Err towards being comprehensive.
<ul>
<li>The goal should be to build an understanding of the major moving parts.</li>
<li>Presentation of results can always be tailored to illustrate trends.</li>
</ul></li>
<li>Explore breakdown points (e.g., what sample size is too small for applying a given method?).</li>
</ul>
<p>And fully expect to add and subtract from your set of parameters as you get your initial simulation results! No one ever runs just a single simulation.</p>
<div id="choosing-parameters-for-the-clustered-rct" class="section level3 hasAnchor" number="11.1.1">
<h3 class="hasAnchor"><span class="header-section-number">11.1.1</span> Choosing parameters for the Clustered RCT<a href="#choosing-parameters-for-the-clustered-rct" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Extending our case study presented in Section @ref(case-cluster) to a multifactor simulation, we next design our full experiment.</p>
<p>So far, we have only investigated a single scenario at a time, although our modular approach does make exploring a range of scenarios by re-calling our simulation function relatively straightforward.
But how do our findings generalize? When are the different methods differently appropriate?
To answer this, we need to extend to a multifactor simulation to <em>systematically</em> explore trends across contexts for our three estimators.
We begin by identifying some questions we might have, given our preliminary results.</p>
<p>Regarding bias, in our initial simulation, we noticed that Linear Regression is estimating a person-weighted quantity, and so would be considered biased for the site-average ATE.
We might next ask, how much does bias change if we change the site-size by impact relationship?</p>
<p>For precision, we saw that Linear Regression has a higher standard error.
But is this a general finding? If not, are there contexts where linear regression will have a lower standard error than the others?
Originally we thought aggregation would lose information because the little sites will have the same weight as big sites, but be more imprecisely estimated.
Were we wrong? Or perhaps if site size was even more variable, Agg might do worse and worse.</p>
<p>Finally, the estimated SEs all appeared to be good, although they were rather variable, relative to the true SE.
We might then ask, is this always the case? Will the estimated SEs fall apart (e.g., be way too large or way too small, in general) in different contexts?</p>
<p>To answer these questions we need to more systematically explore the space of models. But we have a lot of knobs to turn.
In our simulation, we can generate fake cluster randomized data with the following features:</p>
<ul>
<li><p>The treatment impact of the site can vary, and vary with the site size</p></li>
<li><p>We can have sites of different sizes if we want</p></li>
<li><p>We can also vary:</p>
<ul>
<li>the site intercept variance</li>
<li>the residual variance,</li>
<li>the treatment impact</li>
<li>the site size</li>
<li>the number of sites, …</li>
</ul></li>
</ul>
<p>We cannot easily vary all of these.
We instead reflect on our research questions, speculate as to what is likely to matter, and then consider varying the following:</p>
<ul>
<li>Average site size: Does the number of students/site matter?</li>
<li>Number of sites: Do cluster-robust SEs work with fewer sites?</li>
<li>Variation in site size: Varying site sizes cause bias or break things?</li>
<li>Correlation of site size and site impact: Will correlation cause bias?</li>
<li>Cross site variation: Does the amount of site variation matter?</li>
</ul>
<p>When designing the final factors, it is important to ensure those factors are isolated, in that changing one of them is not changing a host of other things that might impact performance.
For example, in our case, if we simply added more cross site variation by directly increasing the random effects for the clusters, our total variation will increase.
If we see that methods deteriorate, we then have a confound: is it the cross site variation causing the problem, or is it the total variation?
We therefore want to vary site variation while controlling total variation; this is why we use the ICC knob discussed in the section on the data generation process.</p>
<p>We might thus end up with the following for our factors:</p>
<div class="sourceCode" id="cb371"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb371-1"><a href="#cb371-1" tabindex="-1"></a>crt_design_factors <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb371-2"><a href="#cb371-2" tabindex="-1"></a>  <span class="at">n_bar =</span> <span class="fu">c</span>( <span class="dv">20</span>, <span class="dv">80</span>, <span class="dv">320</span> ),</span>
<span id="cb371-3"><a href="#cb371-3" tabindex="-1"></a>  <span class="at">J =</span> <span class="fu">c</span>( <span class="dv">5</span>, <span class="dv">20</span>, <span class="dv">80</span> ),</span>
<span id="cb371-4"><a href="#cb371-4" tabindex="-1"></a>  <span class="at">ATE =</span> <span class="fu">c</span>( <span class="fl">0.2</span> ),</span>
<span id="cb371-5"><a href="#cb371-5" tabindex="-1"></a>  <span class="at">size_coef =</span> <span class="fu">c</span>( <span class="dv">0</span>, <span class="fl">0.2</span> ),</span>
<span id="cb371-6"><a href="#cb371-6" tabindex="-1"></a>  <span class="at">ICC =</span> <span class="fu">c</span>( <span class="dv">0</span>, <span class="fl">0.2</span>, <span class="fl">0.4</span>, <span class="fl">0.6</span>, <span class="fl">0.8</span> ),</span>
<span id="cb371-7"><a href="#cb371-7" tabindex="-1"></a>  <span class="at">alpha =</span> <span class="fu">c</span>( <span class="dv">0</span>, <span class="fl">0.5</span>, <span class="fl">0.8</span> )</span>
<span id="cb371-8"><a href="#cb371-8" tabindex="-1"></a>)</span></code></pre></div>
</div>
</div>
<div id="using-pmap-to-run-multifactor-simulations" class="section level2 hasAnchor" number="11.2">
<h2 class="hasAnchor"><span class="header-section-number">11.2</span> Using pmap to run multifactor simulations<a href="#using-pmap-to-run-multifactor-simulations" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>To run simulations across all of our factor combinations, we are going to use a very useful method in the <code>purrr</code> package called <code>pmap()</code>.
<code>pmap()</code> marches down a set of lists, running a function on each <span class="math inline">\(p\)</span>-tuple of elements, taking the <span class="math inline">\(i^{th}\)</span> element from each list for iteration <span class="math inline">\(i\)</span>, and passing them as parameters to the specified function.
<code>pmap()</code> then returns the results of this sequence of function calls as a list of results.</p>
<p>Here is a small illustration:</p>
<div class="sourceCode" id="cb372"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb372-1"><a href="#cb372-1" tabindex="-1"></a>my_function <span class="ot">&lt;-</span> <span class="cf">function</span>( a, b, theta, scale ) {</span>
<span id="cb372-2"><a href="#cb372-2" tabindex="-1"></a>    scale <span class="sc">*</span> (a <span class="sc">+</span> theta<span class="sc">*</span>(b<span class="sc">-</span>a))</span>
<span id="cb372-3"><a href="#cb372-3" tabindex="-1"></a>}</span>
<span id="cb372-4"><a href="#cb372-4" tabindex="-1"></a></span>
<span id="cb372-5"><a href="#cb372-5" tabindex="-1"></a>args <span class="ot">=</span> <span class="fu">list</span>( <span class="at">a =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>, </span>
<span id="cb372-6"><a href="#cb372-6" tabindex="-1"></a>             <span class="at">b =</span> <span class="dv">5</span><span class="sc">:</span><span class="dv">7</span>, </span>
<span id="cb372-7"><a href="#cb372-7" tabindex="-1"></a>             <span class="at">theta =</span> <span class="fu">c</span>(<span class="fl">0.2</span>, <span class="fl">0.3</span>, <span class="fl">0.7</span>) )</span>
<span id="cb372-8"><a href="#cb372-8" tabindex="-1"></a>purrr<span class="sc">::</span><span class="fu">pmap_dbl</span>(  args, my_function, <span class="at">scale =</span> <span class="dv">10</span> )</span></code></pre></div>
<pre><code>## [1] 18 32 58</code></pre>
<p>One important note is the variable names for the lists being iterated over must correspond exactly to function arguments of the called function.
Extra parameters can be passed after the function name; these will be held constant, and passed to each function call.
See how <code>scale</code> is the same for all calls.</p>
<p>As we see above, <code>pmap()</code> has variants such as <code>_dbl</code> or <code>_df</code> just like the <code>map()</code> and <code>map2()</code> methods.
These variants will automatically stack or convert the list of things returned into a tidier collection (for <code>_dbl</code> it will convert to a vector of numbers, for <code>_df</code> it will stack the results to make a large dataframe, assuming each thing returned is a little dataframe).</p>
<p>So far, this is great, but it does not quite look like what we want: our factors are stored as a dataframe, not three lists.
This is where R gets interesting: in R, the columns of a dataframe are stored as a list of vectors or lists (with each of the vectors or lists having the exact same length).
This works beautifully with <code>pmap()</code>.
Witness:</p>
<div class="sourceCode" id="cb374"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb374-1"><a href="#cb374-1" tabindex="-1"></a>args[[<span class="dv">2</span>]]</span></code></pre></div>
<pre><code>## [1] 5 6 7</code></pre>
<div class="sourceCode" id="cb376"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb376-1"><a href="#cb376-1" tabindex="-1"></a>a_df <span class="ot">=</span> <span class="fu">as.data.frame</span>(args)</span>
<span id="cb376-2"><a href="#cb376-2" tabindex="-1"></a>a_df</span></code></pre></div>
<pre><code>##   a b theta
## 1 1 5   0.2
## 2 2 6   0.3
## 3 3 7   0.7</code></pre>
<div class="sourceCode" id="cb378"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb378-1"><a href="#cb378-1" tabindex="-1"></a>a_df[[<span class="dv">2</span>]]</span></code></pre></div>
<pre><code>## [1] 5 6 7</code></pre>
<div class="sourceCode" id="cb380"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb380-1"><a href="#cb380-1" tabindex="-1"></a>purrr<span class="sc">::</span><span class="fu">pmap_dbl</span>( a_df, my_function, <span class="at">scale =</span> <span class="dv">10</span>)</span></code></pre></div>
<pre><code>## [1] 18 32 58</code></pre>
<p>We can pass <code>a_df</code> to <code>pmap</code>, and <code>pmap</code> takes it as a list of lists, and therefore does exactly what it did before.</p>
<p>All of this means <code>pmap()</code> can run a specified function on each row of a dataset.
Continuing the Cronbach Alpha simulation from above, we would have the following:</p>
<div class="sourceCode" id="cb382"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb382-1"><a href="#cb382-1" tabindex="-1"></a>params<span class="sc">$</span>iterations <span class="ot">&lt;-</span> <span class="dv">500</span></span>
<span id="cb382-2"><a href="#cb382-2" tabindex="-1"></a>sim_results <span class="ot">&lt;-</span>  params <span class="sc">%&gt;%</span></span>
<span id="cb382-3"><a href="#cb382-3" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">res =</span> <span class="fu">pmap</span>(., run_alpha_sim ) )</span></code></pre></div>
<p>We add a column to <code>params</code> to record the desired 500 replications per condition.
The above code calls our <code>run_alpha_sim()</code> method for each row of our list of scenarios we want to explore.
Even better, we are storing the results <strong>as a new variable in the same dataset</strong>.</p>
<div class="sourceCode" id="cb383"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb383-1"><a href="#cb383-1" tabindex="-1"></a>sim_results</span></code></pre></div>
<pre><code>## # A tibble: 144 × 6
##        n     p alpha    df iterations res  
##    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt; &lt;lgl&gt;
##  1    50     4   0.1     5        500 NA   
##  2   100     4   0.1     5        500 NA   
##  3    50     8   0.1     5        500 NA   
##  4   100     8   0.1     5        500 NA   
##  5    50     4   0.2     5        500 NA   
##  6   100     4   0.2     5        500 NA   
##  7    50     8   0.2     5        500 NA   
##  8   100     8   0.2     5        500 NA   
##  9    50     4   0.3     5        500 NA   
## 10   100     4   0.3     5        500 NA   
## # ℹ 134 more rows</code></pre>
<p>We are creating a <strong>list-column</strong>, where each element in our list column is the little summary of our simulation results for that scenario.
Here is the third scenario, for example:</p>
<div class="sourceCode" id="cb385"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb385-1"><a href="#cb385-1" tabindex="-1"></a>sim_results<span class="sc">$</span>res[[<span class="dv">3</span>]]</span></code></pre></div>
<pre><code>## [1] NA</code></pre>
<p>We finally use <code>unnest()</code> to expand the <code>res</code> variable, replicating the values of the main variables once for each row in the nested dataset:</p>
<div class="sourceCode" id="cb387"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb387-1"><a href="#cb387-1" tabindex="-1"></a><span class="fu">library</span>(tidyr)</span>
<span id="cb387-2"><a href="#cb387-2" tabindex="-1"></a>sim_results <span class="ot">&lt;-</span> <span class="fu">unnest</span>(sim_results, <span class="at">cols =</span> res) <span class="sc">%&gt;%</span></span>
<span id="cb387-3"><a href="#cb387-3" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">select</span>( <span class="sc">-</span>iterations )</span>
<span id="cb387-4"><a href="#cb387-4" tabindex="-1"></a>sim_results</span></code></pre></div>
<pre><code>## # A tibble: 144 × 5
##        n     p alpha    df res  
##    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;
##  1    50     4   0.1     5 NA   
##  2   100     4   0.1     5 NA   
##  3    50     8   0.1     5 NA   
##  4   100     8   0.1     5 NA   
##  5    50     4   0.2     5 NA   
##  6   100     4   0.2     5 NA   
##  7    50     8   0.2     5 NA   
##  8   100     8   0.2     5 NA   
##  9    50     4   0.3     5 NA   
## 10   100     4   0.3     5 NA   
## # ℹ 134 more rows</code></pre>
<p>We can put all of this together in a a tidy workflow as follows:</p>
<div class="sourceCode" id="cb389"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb389-1"><a href="#cb389-1" tabindex="-1"></a>sim_results <span class="ot">&lt;-</span> </span>
<span id="cb389-2"><a href="#cb389-2" tabindex="-1"></a>  params <span class="sc">%&gt;%</span></span>
<span id="cb389-3"><a href="#cb389-3" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">res =</span> <span class="fu">pmap</span>(., <span class="at">.f =</span> run_alpha_sim)) <span class="sc">%&gt;%</span></span>
<span id="cb389-4"><a href="#cb389-4" tabindex="-1"></a>  <span class="fu">unnest</span>(<span class="at">cols =</span> res)</span></code></pre></div>
<p>If we wanted to use parallel processing (more on this later), we can also simply use the <code>simhelpers</code> package to run a simulation for each row of our parameter dataframe in parallel:</p>
<div class="sourceCode" id="cb390"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb390-1"><a href="#cb390-1" tabindex="-1"></a><span class="fu">plan</span>(multisession) <span class="co"># choose an appropriate plan from the future package</span></span>
<span id="cb390-2"><a href="#cb390-2" tabindex="-1"></a>sim_results <span class="ot">&lt;-</span> <span class="fu">evaluate_by_row</span>(params, run_alpha_sim)</span></code></pre></div>
<p>The above code is auto-generated by the <code>create_skeleton()</code> method as well.</p>
<p>We finally save our results using tidyverse’s <code>write_csv()</code>; see “R for Data Science” textbook, 11.5.
We can ensure we have a directory by making one via <code>dir.create()</code> (see Section @ref(saving-files) for more on files):</p>
<div class="sourceCode" id="cb391"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb391-1"><a href="#cb391-1" tabindex="-1"></a><span class="fu">dir.create</span>(<span class="st">&quot;results&quot;</span>, <span class="at">showWarnings =</span> <span class="cn">FALSE</span> )</span>
<span id="cb391-2"><a href="#cb391-2" tabindex="-1"></a><span class="fu">write_csv</span>( sim_results, <span class="at">file =</span> <span class="st">&quot;results/cronbach_results.csv&quot;</span> )</span></code></pre></div>
</div>
<div id="when-to-aggregate-results-across-multiple-simulations" class="section level2 hasAnchor" number="11.3">
<h2 class="hasAnchor"><span class="header-section-number">11.3</span> When to aggregate results across multiple simulations<a href="#when-to-aggregate-results-across-multiple-simulations" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>For a single scenario simulation, we have three core elements:
- Generate data
- Analyze data
- Assess performance</p>
<p>For a multifactor simulation, we have a choice in how to arrange these elements: do we compute performance measures for each simulation scenario as we go (inside) vs. computing after we get all of our individual results (outside)?</p>
<div id="aggregate-as-you-simulate-inside" class="section level3 hasAnchor" number="11.3.1">
<h3 class="hasAnchor"><span class="header-section-number">11.3.1</span> Aggregate as you simulate (inside)<a href="#aggregate-as-you-simulate-inside" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>In the “inside” approach, illustrated above, we, for each scenario defined by a specific combination of factors, run our simulation for that scenario, assess the performance, and then return a nice summary table of how well our methods did.
This is the most straightforward, given what we have done so far: we have a method to run a simulation for a scenario, and we simply run that method for a bunch of scenarios and collate.</p>
<p>After the <code>pmap()</code> call, we end up with a dataframe with all our simulations, one simulation context per row (or maybe bundles of rows for each simulation context, with one row for each method), with our measured performance outcomes.
This is ideally all we need to analyze.</p>
<p>We have less data to store, and it is easier to compartmentalize.
On the cons side, we have no ability to add new performance measures on the fly.</p>
<p>Overall, aggregating as we go seems pretty good.
That being said, sometimes we might want to use a lot of disk space and keep much more so we can explore our simulated data more flexibly.
In particular, each row of the above corresponds to the summary of a whole collection of individual runs.
We might instead store all of these runs, which brings us to the other approach.</p>
</div>
<div id="keep-all-simulation-runs-outside" class="section level3 hasAnchor" number="11.3.2">
<h3 class="hasAnchor"><span class="header-section-number">11.3.2</span> Keep all simulation runs (outside)<a href="#keep-all-simulation-runs-outside" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>In the “outside” approach we do not aggregate, but instead, for each scenario, return the entire set of individual estimates.
The benefit of this is, given the raw estimates, you can dynamically add or change how you calculate performance measures without re-running the entire simulation.
You do, however, end up with massive amounts of data to store and manipulate.</p>
<p>To move from inside to outside, just take the summarizing step out of <code>run_alpha_sim()</code>.
E.g.,:</p>
<div class="sourceCode" id="cb392"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb392-1"><a href="#cb392-1" tabindex="-1"></a>run_alpha_sim_raw <span class="ot">&lt;-</span> <span class="cf">function</span>(iterations, n, p, alpha, df, <span class="at">coverage =</span> <span class="fl">0.95</span>, <span class="at">seed =</span> <span class="cn">NULL</span>) {</span>
<span id="cb392-2"><a href="#cb392-2" tabindex="-1"></a>  </span>
<span id="cb392-3"><a href="#cb392-3" tabindex="-1"></a>  <span class="cf">if</span> (<span class="sc">!</span><span class="fu">is.null</span>(seed)) <span class="fu">set.seed</span>(seed)</span>
<span id="cb392-4"><a href="#cb392-4" tabindex="-1"></a>  </span>
<span id="cb392-5"><a href="#cb392-5" tabindex="-1"></a>  results <span class="ot">&lt;-</span> </span>
<span id="cb392-6"><a href="#cb392-6" tabindex="-1"></a>    <span class="fu">replicate</span>(<span class="at">n =</span> iterations, {</span>
<span id="cb392-7"><a href="#cb392-7" tabindex="-1"></a>      dat <span class="ot">&lt;-</span> <span class="fu">r_mvt_items</span>(<span class="at">n =</span> n, <span class="at">p =</span> p, <span class="at">alpha =</span> alpha, <span class="at">df =</span> df)</span>
<span id="cb392-8"><a href="#cb392-8" tabindex="-1"></a>      <span class="fu">estimate_alpha</span>(dat, <span class="at">coverage =</span> coverage)</span>
<span id="cb392-9"><a href="#cb392-9" tabindex="-1"></a>    }, <span class="at">simplify =</span> <span class="cn">FALSE</span>) <span class="sc">%&gt;%</span></span>
<span id="cb392-10"><a href="#cb392-10" tabindex="-1"></a>    <span class="fu">bind_rows</span>()</span>
<span id="cb392-11"><a href="#cb392-11" tabindex="-1"></a>  </span>
<span id="cb392-12"><a href="#cb392-12" tabindex="-1"></a>  results</span>
<span id="cb392-13"><a href="#cb392-13" tabindex="-1"></a>}</span></code></pre></div>
<p>Each call to <code>run_alpha_sim_raw()</code> now gives one row per simulation trial.
We replicate our simulation parameters for each row.</p>
<div class="sourceCode" id="cb393"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb393-1"><a href="#cb393-1" tabindex="-1"></a><span class="fu">run_alpha_sim_raw</span>( <span class="dv">4</span>, <span class="dv">50</span>, <span class="dv">6</span>, <span class="fl">0.5</span>, <span class="dv">3</span> )</span></code></pre></div>
<pre><code>##           A      Var_A       CI_L      CI_U
## 1 0.5402995 0.01014358 0.29374115 0.7007831
## 2 0.3867717 0.01805035 0.05786946 0.6008526
## 3 0.4617342 0.01390704 0.17303773 0.6496454
## 4 0.4810237 0.01292815 0.20267301 0.6622008</code></pre>
<p>The primary advantage of the outside approach is we can then generate new performance measures, as they
occur to us, later on.
The disadvantage is this result file will be <span class="math inline">\(R\)</span> times as many rows as the older file, which can get quite, quite large.</p>
<p>But disk space is cheap!
Here we run the same experiment with our more complete storage.
Note how the <code>pmap_df</code> stacks the multiple rows from each run, giving us everything nicely bundled up:</p>
<div class="sourceCode" id="cb395"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb395-1"><a href="#cb395-1" tabindex="-1"></a>params<span class="sc">$</span>res <span class="ot">&lt;-</span> params <span class="sc">%&gt;%</span> </span>
<span id="cb395-2"><a href="#cb395-2" tabindex="-1"></a>    <span class="fu">pmap</span>( run_alpha_sim_raw, <span class="at">iterations =</span> <span class="dv">500</span> )</span>
<span id="cb395-3"><a href="#cb395-3" tabindex="-1"></a>sim_results_full <span class="ot">&lt;-</span> <span class="fu">unnest</span>( params,</span>
<span id="cb395-4"><a href="#cb395-4" tabindex="-1"></a>                            <span class="at">cols =</span> res ) </span>
<span id="cb395-5"><a href="#cb395-5" tabindex="-1"></a><span class="fu">write_csv</span>( sim_results_full, <span class="st">&quot;results/cronbach_results_full.csv&quot;</span> )</span></code></pre></div>
<p>We end up with a lot more rows:</p>
<div class="sourceCode" id="cb396"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb396-1"><a href="#cb396-1" tabindex="-1"></a><span class="fu">nrow</span>( sim_results_full )</span></code></pre></div>
<pre><code>## [1] 72000</code></pre>
<div class="sourceCode" id="cb398"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb398-1"><a href="#cb398-1" tabindex="-1"></a><span class="fu">nrow</span>( sim_results )</span></code></pre></div>
<pre><code>## [1] 144</code></pre>
<p>Compare the file sizes: one is several k, the other is around 20 megabytes.</p>
<div class="sourceCode" id="cb400"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb400-1"><a href="#cb400-1" tabindex="-1"></a><span class="fu">file.size</span>(<span class="st">&quot;results/cronbach_results.csv&quot;</span>) <span class="sc">/</span> <span class="dv">1024</span></span></code></pre></div>
<pre><code>## [1] 4.103516</code></pre>
<div class="sourceCode" id="cb402"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb402-1"><a href="#cb402-1" tabindex="-1"></a><span class="fu">file.size</span>(<span class="st">&quot;results/cronbach_results_full.csv&quot;</span>) <span class="sc">/</span> <span class="dv">1024</span></span></code></pre></div>
<pre><code>## [1] 7516.222</code></pre>
</div>
<div id="getting-raw-results-ready-for-analysis" class="section level3 hasAnchor" number="11.3.3">
<h3 class="hasAnchor"><span class="header-section-number">11.3.3</span> Getting raw results ready for analysis<a href="#getting-raw-results-ready-for-analysis" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>If we generated raw results then we need to collapse them by experimental run
before calculating performance measures so we can explore the trends across the
experiments.</p>
<p>One way to do this is to use <code>group_by()</code> and <code>summarize()</code> to collapse the raw results.</p>
<div class="sourceCode" id="cb404"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb404-1"><a href="#cb404-1" tabindex="-1"></a>sim_results_full <span class="sc">%&gt;%</span></span>
<span id="cb404-2"><a href="#cb404-2" tabindex="-1"></a>    <span class="fu">group_by</span>( n, p, alpha, df ) <span class="sc">%&gt;%</span></span>
<span id="cb404-3"><a href="#cb404-3" tabindex="-1"></a>  <span class="fu">summarise</span>( </span>
<span id="cb404-4"><a href="#cb404-4" tabindex="-1"></a>    <span class="at">bias =</span> <span class="fu">mean</span>(A <span class="sc">-</span> alpha),</span>
<span id="cb404-5"><a href="#cb404-5" tabindex="-1"></a>    <span class="at">RMSE =</span> <span class="fu">sqrt</span>(<span class="fu">mean</span>((A <span class="sc">-</span> alpha)<span class="sc">^</span><span class="dv">2</span>))</span>
<span id="cb404-6"><a href="#cb404-6" tabindex="-1"></a>  )</span></code></pre></div>
<pre><code>## # A tibble: 144 × 6
## # Groups:   n, p, alpha [36]
##        n     p alpha    df    bias  RMSE
##    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;
##  1    50     4   0.1     5 -0.103  0.388
##  2    50     4   0.1    10 -0.0527 0.263
##  3    50     4   0.1    20 -0.0190 0.221
##  4    50     4   0.1   100 -0.0313 0.219
##  5    50     4   0.2     5 -0.0966 0.399
##  6    50     4   0.2    10 -0.0406 0.225
##  7    50     4   0.2    20 -0.0301 0.223
##  8    50     4   0.2   100 -0.0348 0.206
##  9    50     4   0.3     5 -0.0683 0.281
## 10    50     4   0.3    10 -0.0331 0.199
## # ℹ 134 more rows</code></pre>
<p>If we want to use our full performance measure function <code>alpha_performance()</code> so we get additional metrics such as MCSEs, we would <em>nest</em> our data into a series of mini-datasets (one for each simulation), and then process each element.
As we saw above, nesting collapses a larger dataframe into a dataframe of dataframes:</p>
<div class="sourceCode" id="cb406"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb406-1"><a href="#cb406-1" tabindex="-1"></a>results <span class="ot">&lt;-</span> sim_results_full <span class="sc">|&gt;</span></span>
<span id="cb406-2"><a href="#cb406-2" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">select</span>( <span class="sc">-</span>iterations, <span class="sc">-</span>seed ) <span class="sc">|&gt;</span></span>
<span id="cb406-3"><a href="#cb406-3" tabindex="-1"></a>  <span class="fu">group_by</span>( n, p, alpha, df ) <span class="sc">|&gt;</span></span>
<span id="cb406-4"><a href="#cb406-4" tabindex="-1"></a>  <span class="fu">nest</span>( <span class="at">.key =</span> <span class="st">&quot;alpha_sims&quot;</span> )</span>
<span id="cb406-5"><a href="#cb406-5" tabindex="-1"></a>results</span></code></pre></div>
<pre><code>## # A tibble: 144 × 5
## # Groups:   n, p, alpha, df [144]
##        n     p alpha    df alpha_sims        
##    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;list&gt;            
##  1    50     4   0.1     5 &lt;tibble [500 × 4]&gt;
##  2   100     4   0.1     5 &lt;tibble [500 × 4]&gt;
##  3    50     8   0.1     5 &lt;tibble [500 × 4]&gt;
##  4   100     8   0.1     5 &lt;tibble [500 × 4]&gt;
##  5    50     4   0.2     5 &lt;tibble [500 × 4]&gt;
##  6   100     4   0.2     5 &lt;tibble [500 × 4]&gt;
##  7    50     8   0.2     5 &lt;tibble [500 × 4]&gt;
##  8   100     8   0.2     5 &lt;tibble [500 × 4]&gt;
##  9    50     4   0.3     5 &lt;tibble [500 × 4]&gt;
## 10   100     4   0.3     5 &lt;tibble [500 × 4]&gt;
## # ℹ 134 more rows</code></pre>
<p>Note how each row has a little dataframe of the individual simulation results, with 500 rows each.
Once nested, we can then use <code>map()</code> to apply a function to each element of the nested dataframe.</p>
<div class="sourceCode" id="cb408"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb408-1"><a href="#cb408-1" tabindex="-1"></a>results <span class="ot">&lt;-</span> results <span class="sc">%&gt;%</span></span>
<span id="cb408-2"><a href="#cb408-2" tabindex="-1"></a>  <span class="fu">mutate</span>( <span class="at">performance =</span> <span class="fu">map2</span>( alpha_sims, alpha, </span>
<span id="cb408-3"><a href="#cb408-3" tabindex="-1"></a>                              alpha_performance ) )</span>
<span id="cb408-4"><a href="#cb408-4" tabindex="-1"></a>results <span class="ot">&lt;-</span> results <span class="sc">%&gt;%</span></span>
<span id="cb408-5"><a href="#cb408-5" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">select</span>( <span class="sc">-</span>alpha_sims ) <span class="sc">%&gt;%</span></span>
<span id="cb408-6"><a href="#cb408-6" tabindex="-1"></a>  <span class="fu">unnest</span>( <span class="at">cols=</span><span class="st">&quot;performance&quot;</span> ) </span>
<span id="cb408-7"><a href="#cb408-7" tabindex="-1"></a>results</span></code></pre></div>
<pre><code>## # A tibble: 576 × 7
## # Groups:   n, p, alpha, df [144]
##        n     p alpha    df criterion           est
##    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;             &lt;dbl&gt;
##  1    50     4   0.1     5 alpha bias      -0.103 
##  2    50     4   0.1     5 alpha RMSE       0.388 
##  3    50     4   0.1     5 V relative bias  0.436 
##  4    50     4   0.1     5 coverage         0.826 
##  5   100     4   0.1     5 alpha bias      -0.0347
##  6   100     4   0.1     5 alpha RMSE       0.224 
##  7   100     4   0.1     5 V relative bias  0.500 
##  8   100     4   0.1     5 coverage         0.85  
##  9    50     8   0.1     5 alpha bias      -0.0728
## 10    50     8   0.1     5 alpha RMSE       0.333 
## # ℹ 566 more rows
## # ℹ 1 more variable: MCSE &lt;dbl&gt;</code></pre>
<p>Now, if we want to add a performance metric, we can simply change <code>alpha_performance</code> and recalculate, without running the time-intensive simulations.
Being able to re-analyze your results is generally a far easier fix than running all the simulations again
after changing the <code>run_alpha_sim()</code> method.
Summarizing during the simulation vs. after, as we just did, leads to the same set of results.
This is about using disk space to have later flexibility.</p>
</div>
</div>
<div id="running-the-cluster-rct-multifactor-experiment" class="section level2 hasAnchor" number="11.4">
<h2 class="hasAnchor"><span class="header-section-number">11.4</span> Running the Cluster RCT multifactor experiment<a href="#running-the-cluster-rct-multifactor-experiment" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Running our cluster RCT simulation is the exact same code as we have used before.
Simulations take awhile to run so we save them so we can analyze at our leisure.
Because we are not exactly sure what performance metrics we want, we will save our individual results, and calculate performance metrics on the full data.
I.e., we are storing the individual runs, not the analyzed results!</p>
<p>The code is as follows:</p>
<div class="sourceCode" id="cb410"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb410-1"><a href="#cb410-1" tabindex="-1"></a>params <span class="ot">&lt;-</span> </span>
<span id="cb410-2"><a href="#cb410-2" tabindex="-1"></a>  <span class="fu">cross_df</span>(crt_design_factors) <span class="sc">%&gt;%</span></span>
<span id="cb410-3"><a href="#cb410-3" tabindex="-1"></a>  <span class="fu">mutate</span>(</span>
<span id="cb410-4"><a href="#cb410-4" tabindex="-1"></a>    <span class="at">reps =</span> <span class="dv">100</span>,</span>
<span id="cb410-5"><a href="#cb410-5" tabindex="-1"></a>    <span class="at">seed =</span> <span class="dv">20200320</span> <span class="sc">+</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">n</span>()</span>
<span id="cb410-6"><a href="#cb410-6" tabindex="-1"></a>  )</span>
<span id="cb410-7"><a href="#cb410-7" tabindex="-1"></a>params<span class="sc">$</span>res <span class="ot">=</span> <span class="fu">pmap</span>(params, <span class="at">.f =</span> run_CRT_sim )</span>
<span id="cb410-8"><a href="#cb410-8" tabindex="-1"></a>res <span class="ot">=</span> params <span class="sc">%&gt;%</span> <span class="fu">unnest</span>( <span class="at">cols=</span><span class="fu">c</span>(data) )</span>
<span id="cb410-9"><a href="#cb410-9" tabindex="-1"></a><span class="fu">saveRDS</span>( res, <span class="at">file =</span> <span class="st">&quot;results/simulation_CRT.rds&quot;</span> )</span></code></pre></div>
<p>The seed is for reproducibility; we discuss this more later on.</p>
<p>We then group by our simulation factors and calculate all our performance metrics at once directly.
For example, here is the code for calculating performance measures across our simulation for the cluster randomized experiments example:</p>
<div class="sourceCode" id="cb411"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb411-1"><a href="#cb411-1" tabindex="-1"></a>res <span class="ot">&lt;-</span> <span class="fu">readRDS</span>( <span class="at">file =</span> <span class="st">&quot;results/simulation_CRT.rds&quot;</span> )</span>
<span id="cb411-2"><a href="#cb411-2" tabindex="-1"></a></span>
<span id="cb411-3"><a href="#cb411-3" tabindex="-1"></a>sres <span class="ot">&lt;-</span> </span>
<span id="cb411-4"><a href="#cb411-4" tabindex="-1"></a>  res <span class="sc">%&gt;%</span> </span>
<span id="cb411-5"><a href="#cb411-5" tabindex="-1"></a>  <span class="fu">group_by</span>( n_bar, J, ATE, size_coef, ICC, alpha, method ) <span class="sc">%&gt;%</span></span>
<span id="cb411-6"><a href="#cb411-6" tabindex="-1"></a>  <span class="fu">summarise</span>( </span>
<span id="cb411-7"><a href="#cb411-7" tabindex="-1"></a>    <span class="at">bias =</span> <span class="fu">mean</span>(ATE_hat <span class="sc">-</span> ATE),</span>
<span id="cb411-8"><a href="#cb411-8" tabindex="-1"></a>    <span class="at">SE =</span> <span class="fu">sd</span>( ATE_hat ),</span>
<span id="cb411-9"><a href="#cb411-9" tabindex="-1"></a>    <span class="at">RMSE =</span> <span class="fu">sqrt</span>( <span class="fu">mean</span>( (ATE_hat <span class="sc">-</span> ATE )<span class="sc">^</span><span class="dv">2</span> ) ),</span>
<span id="cb411-10"><a href="#cb411-10" tabindex="-1"></a>    <span class="at">ESE_hat =</span> <span class="fu">sqrt</span>( <span class="fu">mean</span>( SE_hat<span class="sc">^</span><span class="dv">2</span> ) ),</span>
<span id="cb411-11"><a href="#cb411-11" tabindex="-1"></a>    <span class="at">SD_SE_hat =</span> <span class="fu">sqrt</span>( <span class="fu">sd</span>( SE_hat<span class="sc">^</span><span class="dv">2</span> ) ),</span>
<span id="cb411-12"><a href="#cb411-12" tabindex="-1"></a>    <span class="at">power =</span> <span class="fu">mean</span>( p_value <span class="sc">&lt;=</span> <span class="fl">0.05</span> ),</span>
<span id="cb411-13"><a href="#cb411-13" tabindex="-1"></a>    <span class="at">R =</span> <span class="fu">n</span>(),</span>
<span id="cb411-14"><a href="#cb411-14" tabindex="-1"></a>    <span class="at">.groups =</span> <span class="st">&quot;drop&quot;</span></span>
<span id="cb411-15"><a href="#cb411-15" tabindex="-1"></a>  )</span>
<span id="cb411-16"><a href="#cb411-16" tabindex="-1"></a>sres</span></code></pre></div>
<pre><code>## # A tibble: 810 × 14
##    n_bar     J   ATE size_coef   ICC alpha method
##    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; 
##  1    20     5   0.2         0   0     0   Agg   
##  2    20     5   0.2         0   0     0   LR    
##  3    20     5   0.2         0   0     0   MLM   
##  4    20     5   0.2         0   0     0.5 Agg   
##  5    20     5   0.2         0   0     0.5 LR    
##  6    20     5   0.2         0   0     0.5 MLM   
##  7    20     5   0.2         0   0     0.8 Agg   
##  8    20     5   0.2         0   0     0.8 LR    
##  9    20     5   0.2         0   0     0.8 MLM   
## 10    20     5   0.2         0   0.2   0   Agg   
## # ℹ 800 more rows
## # ℹ 7 more variables: bias &lt;dbl&gt;, SE &lt;dbl&gt;,
## #   RMSE &lt;dbl&gt;, ESE_hat &lt;dbl&gt;, SD_SE_hat &lt;dbl&gt;,
## #   power &lt;dbl&gt;, R &lt;int&gt;</code></pre>
<div id="making-analyze_data-quiet" class="section level3 hasAnchor" number="11.4.1">
<h3 class="hasAnchor"><span class="header-section-number">11.4.1</span> Making analyze_data() quiet<a href="#making-analyze_data-quiet" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>If we run our simulation when there is little cluster variation, we start getting a lot of messages and warnings from our MLM estimator.
For example, from a single call we get:</p>
<div class="sourceCode" id="cb413"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb413-1"><a href="#cb413-1" tabindex="-1"></a>res <span class="ot">&lt;-</span> <span class="fu">analyze_data</span>(dat)</span></code></pre></div>
<p>When we scale up to our full simulations, these warnings can become a nuisance.
Furthermore, we have found that the <code>lmer</code> command can sometimes just fail (we believe there is some bug in the optimizer that fails if things are just perfectly wrong).
If this was on simulation run 944 out of 1000, we would lose everything!
To protect ourselves, we trap messages and warnings as so (see Chapter @(#safe_code) for more on this):</p>
<pre><code>quiet_lmer = quietly( lmer )
analyze_data &lt;- function( dat ) {
    
    # MLM
    M1 &lt;- quiet_lmer( Yobs ~ 1 + Z + (1|sid), data=dat )
    message1 = ifelse( length( M1$message ) &gt; 0, 1, 0 )
    warning1 = ifelse( length( M1$warning ) &gt; 0, 1, 0 )

   ...

    # Compile our results
    tibble( 
      method = c( &quot;MLM&quot;, &quot;LR&quot;, &quot;Agg&quot; ),
      ATE_hat = c( est1, est2, est3 ),
      SE_hat = c( se1, se2, se3 ),
      p_value = c( pv1, pv2, pv3 ),
      message = c( message1, 0, 0 ),
      warning = c( warning1, 0, 0 )
    )
}</code></pre>
<p>We now get a note about the message regarding convergence saved in our results:</p>
<div class="sourceCode" id="cb415"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb415-1"><a href="#cb415-1" tabindex="-1"></a>res <span class="ot">&lt;-</span> <span class="fu">analyze_data</span>(dat)</span>
<span id="cb415-2"><a href="#cb415-2" tabindex="-1"></a>res</span></code></pre></div>
<pre><code>## # A tibble: 3 × 6
##   method ATE_hat SE_hat p_value message warning
##   &lt;chr&gt;    &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;
## 1 MLM    -0.376   1.44    0.842       0       0
## 2 LR     -0.0973  0.784   0.921       0       0
## 3 Agg    -0.440   0.856   0.698       0       0</code></pre>
<p>See? No more warnings, but we see the message as a variable in our results.</p>
<!--chapter:end:070-experimental-design.Rmd-->
</div>
</div>
</div>
<div id="analyzing-the-multifactor-experiment" class="section level1 hasAnchor" number="12">
<h1 class="hasAnchor"><span class="header-section-number">12</span> Analyzing the multifactor experiment<a href="#analyzing-the-multifactor-experiment" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<div id="ways-of-analyzing-simulation-results" class="section level2 hasAnchor" number="12.1">
<h2 class="hasAnchor"><span class="header-section-number">12.1</span> Ways of analyzing simulation results<a href="#ways-of-analyzing-simulation-results" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Once we have performance measures for all our simulation scenarios, how do we explore them?
For our Cluster RCT simulation, we have 270 different simulation runs across our factors (with three rows per simulation run, one for each method).
How can we visualize and understand trends across this complex domain?</p>
<p>There are several techniques for summarizing across the data that one might use.</p>
<div id="plot-everything-with-many-small-multiples" class="section level3 hasAnchor" number="12.1.1">
<h3 class="hasAnchor"><span class="header-section-number">12.1.1</span> Plot everything with many small multiples<a href="#plot-everything-with-many-small-multiples" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>If you do not have too many different kinds of factor, you can simply plot all of your results at once.
For example, say we only ran simulations for our Cluster RCT simulation with <code>n_bar = 320</code> and <code>J = 20</code>.
Then we could plot everything like so:</p>
<div class="sourceCode" id="cb417"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb417-1"><a href="#cb417-1" tabindex="-1"></a>sres_sub <span class="ot">&lt;-</span> sres <span class="sc">%&gt;%</span></span>
<span id="cb417-2"><a href="#cb417-2" tabindex="-1"></a>  <span class="fu">filter</span>( n_bar <span class="sc">==</span> <span class="dv">320</span>, J <span class="sc">==</span> <span class="dv">20</span> )</span>
<span id="cb417-3"><a href="#cb417-3" tabindex="-1"></a><span class="fu">ggplot</span>( sres_sub, <span class="fu">aes</span>( alpha, bias, <span class="at">col=</span>method, <span class="at">pch=</span>method, <span class="at">group=</span>method ) ) <span class="sc">+</span></span>
<span id="cb417-4"><a href="#cb417-4" tabindex="-1"></a>  <span class="fu">facet_grid</span>( size_coef <span class="sc">~</span> ICC, <span class="at">labeller =</span> label_both ) <span class="sc">+</span></span>
<span id="cb417-5"><a href="#cb417-5" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span> <span class="fu">geom_line</span>() <span class="sc">+</span></span>
<span id="cb417-6"><a href="#cb417-6" tabindex="-1"></a>  <span class="fu">geom_hline</span>( <span class="at">yintercept =</span> <span class="dv">0</span> ) <span class="sc">+</span></span>
<span id="cb417-7"><a href="#cb417-7" tabindex="-1"></a>  <span class="fu">theme_minimal</span>() <span class="sc">+</span></span>
<span id="cb417-8"><a href="#cb417-8" tabindex="-1"></a>  <span class="fu">scale_x_continuous</span>( <span class="at">breaks =</span> <span class="fu">unique</span>( sres<span class="sc">$</span>alpha) )</span></code></pre></div>
<p><img src="Designing-Simulations-in-R_files/figure-html/unnamed-chunk-224-1.png" width="75%" style="display: block; margin: auto;" /></p>
<p>Each point is one of our methods in one of our simulation scenarios.
We are looking at the raw results.
We connect the points with lines to help us see trends within each of the mini-plots.
It also helps us visually track which group of points goes with which.</p>
<p>As a side note, this style of plotting, with a bunch of small plots, is called
“many small multiples” and is beloved by Tufte.
He likes it, in part, because in a single plot we can display 5 variables: our facets are organized by two (ICC and the size coefficient), and within each facet we have three (alpha, our outcome of bias, and the methods themselves).
Unfortunately, we quickly reach our limits of this approach if we have more factors than 5, which, in this case, we do.
We next present bundling, a way of using this core idea of showing raw results, but in a semi-aggregated way.</p>
</div>
<div id="bundling" class="section level3 hasAnchor" number="12.1.2">
<h3 class="hasAnchor"><span class="header-section-number">12.1.2</span> Bundling<a href="#bundling" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>As a first step, we can bundle the simulations into groups defined by a selected primary factor of interest, and then plot each bundle with a boxplot of a selected performance criteria.
Each boxplot then shows the central measure of how well an estimator worked across those simulations, along with a sense of how much that performance varied across those simulations.
If the boxes are narrow, then we know that the variation across simulations within the box did not impact performance much.
If the boxes are wide, then we know that the factors that vary within the box matter a lot for performance.</p>
<p>With bundling, we would need a good number of simulation runs per scenario, so that the MCSE in the performance measures does not make our boxplots look substantially more variable (wider) than the truth.
(Consider a case where the simulations within a box all would have the same performance, but the MCSE is large; in this case we would see a wide boxplot when we should not.)</p>
<p>To illustrate, we next investigate bias in our running example on cluster RCTs.
We are going to group our results by method, ICC, the size coefficent (how strong the cluster size to treatment impact relationship is), and alpha (how much the site sizes vary).
For a specific ICC, size, and alpha, we will put the boxes for the three methods side-by-side to directly compare the methods in terms of bias.</p>
<div class="sourceCode" id="cb418"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb418-1"><a href="#cb418-1" tabindex="-1"></a><span class="fu">ggplot</span>( sres, <span class="fu">aes</span>( ICC, bias, <span class="at">col=</span>method, <span class="at">group=</span><span class="fu">paste0</span>(ICC,method) ) ) <span class="sc">+</span></span>
<span id="cb418-2"><a href="#cb418-2" tabindex="-1"></a>  <span class="fu">facet_grid</span>( alpha <span class="sc">~</span> size_coef, <span class="at">labeller =</span> label_both ) <span class="sc">+</span></span>
<span id="cb418-3"><a href="#cb418-3" tabindex="-1"></a>  <span class="fu">geom_boxplot</span>(<span class="at">coef =</span> <span class="cn">Inf</span>) <span class="sc">+</span></span>
<span id="cb418-4"><a href="#cb418-4" tabindex="-1"></a>  <span class="fu">geom_hline</span>( <span class="at">yintercept =</span> <span class="dv">0</span> ) <span class="sc">+</span></span>
<span id="cb418-5"><a href="#cb418-5" tabindex="-1"></a>  <span class="fu">theme_minimal</span>() <span class="sc">+</span></span>
<span id="cb418-6"><a href="#cb418-6" tabindex="-1"></a>  <span class="fu">scale_x_continuous</span>( <span class="at">breaks =</span> <span class="fu">unique</span>( sres<span class="sc">$</span>ICC) )</span></code></pre></div>
<p><img src="Designing-Simulations-in-R_files/figure-html/clusterRCT_plot_bias_v1-1.png" width="75%" style="display: block; margin: auto;" /></p>
<p>From our plot we see, for example, that there is virtually no bias for any method when the size coefficient is 0 and the ICC is 0.
It is a bit more unclear, but it seems there is also virtually no bias when the size coefficient is 0 regardless of ICC, but the boxes are wider making us wonder if something else is potentially going on.
When alpha is 0 and the size coefficient is 0.2, all methods have a negative bias for most scenarios considered, as all boxes and almost all of the whiskers are below the 0 line (when ICC is 0.6 or 0.8 we may have some instances of 0 or positive bias, if that is not MCSE giving long tails).</p>
<p>Each box is a collection of simulation trials. E.g., for <code>ICC = 0.6</code>, <code>size_coef = 0.2</code>, and <code>alpha = 0.8</code> each box contains 9 scenarios representing the varying level 1 and level 2 sample sizes.
Here are the 9 for the Aggregation method:</p>
<div class="sourceCode" id="cb419"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb419-1"><a href="#cb419-1" tabindex="-1"></a><span class="fu">filter</span>( sres, ICC <span class="sc">==</span> <span class="fl">0.6</span>, size_coef <span class="sc">==</span> <span class="fl">0.2</span>,</span>
<span id="cb419-2"><a href="#cb419-2" tabindex="-1"></a>        alpha <span class="sc">==</span> <span class="fl">0.8</span>, method<span class="sc">==</span><span class="st">&quot;Agg&quot;</span> ) <span class="sc">%&gt;%</span></span>
<span id="cb419-3"><a href="#cb419-3" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">select</span>( n_bar<span class="sc">:</span>alpha, bias )</span></code></pre></div>
<pre><code>## # A tibble: 9 × 7
##   n_bar     J   ATE size_coef   ICC alpha     bias
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;
## 1    20     5   0.2       0.2   0.6   0.8 -6.60e-2
## 2    20    20   0.2       0.2   0.6   0.8  1.68e-2
## 3    20    80   0.2       0.2   0.6   0.8  1.02e-2
## 4    80     5   0.2       0.2   0.6   0.8  2.09e-3
## 5    80    20   0.2       0.2   0.6   0.8  2.98e-2
## 6    80    80   0.2       0.2   0.6   0.8 -9.26e-3
## 7   320     5   0.2       0.2   0.6   0.8  2.42e-2
## 8   320    20   0.2       0.2   0.6   0.8  9.93e-4
## 9   320    80   0.2       0.2   0.6   0.8  1.97e-3</code></pre>
<p>The apparent outliers (long tails) for some of the boxplots suggest that the other factors (cluster size and number of clusters) also relate to degree of bias. We could try bundling along different aspects to see:</p>
<div class="sourceCode" id="cb421"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb421-1"><a href="#cb421-1" tabindex="-1"></a><span class="fu">ggplot</span>( sres, <span class="fu">aes</span>( <span class="fu">as.factor</span>(n_bar), bias, <span class="at">col=</span>method, <span class="at">group=</span><span class="fu">paste0</span>(n_bar,method) ) ) <span class="sc">+</span></span>
<span id="cb421-2"><a href="#cb421-2" tabindex="-1"></a>  <span class="fu">facet_grid</span>( alpha <span class="sc">~</span>  size_coef, <span class="at">labeller =</span> label_both ) <span class="sc">+</span></span>
<span id="cb421-3"><a href="#cb421-3" tabindex="-1"></a>  <span class="fu">geom_boxplot</span>(<span class="at">coef =</span> <span class="cn">Inf</span>) <span class="sc">+</span></span>
<span id="cb421-4"><a href="#cb421-4" tabindex="-1"></a>  <span class="fu">geom_hline</span>( <span class="at">yintercept =</span> <span class="dv">0</span> ) <span class="sc">+</span></span>
<span id="cb421-5"><a href="#cb421-5" tabindex="-1"></a>  <span class="fu">theme_minimal</span>()</span></code></pre></div>
<p><img src="Designing-Simulations-in-R_files/figure-html/clusterRCT_plot_bias_v2-1.png" width="75%" style="display: block; margin: auto;" /></p>
<p>No progress there. Perhaps it is instability or MCSE.
In an actual analysis, we might then make a note to investigate these anomalies a bit further, later on.</p>
</div>
<div id="aggregation" class="section level3 hasAnchor" number="12.1.3">
<h3 class="hasAnchor"><span class="header-section-number">12.1.3</span> Aggregation<a href="#aggregation" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>The boxplots make seeing trends more difficult.
Instead of bundling, we can therefore aggregate, where we average all the scenarios within a box to get a single number of average performance, to look at overall trends rather than individual simulation variation.
Aggregation is especially important if the number of replicates within each scenario is small, because then each indiviua scenario’s performance is measured with a lot of error.</p>
<p>With aggregation, we average over some of the factors, collapsing our simulation results down to fewer moving parts.
Aggregation across factors is better than having not had those factors in the first place!
A performance measure averaged over a factor is a more general answer of how things work in pratice than having not varied the factor at all.</p>
<p>For example, if we average across ICC and site variation, and see how the methods change performance as a function of <span class="math inline">\(J\)</span>, we would know that this is a general trend across a range of scenarios defined by different ICC and site variation levels.
Our conclusions would then be more general than if we picked a single ICC and amount of site variation: in this latter case we would not know if we would see our trend more broadly.</p>
<p>Also, with aggregation, we can have a smaller number of replications per factor combination.
The averaging will, in effect, give a lot more replications per aggregated performance measure.</p>
<p>A caution with aggregation is that aggregated results can be misleading if you have scaling issues or extreme outliers.
With bias, our scale is fairly well set, so we are good.
But if we were aggregating standard errors over different sample sizes, then the larger standard errors of the smaller sample size simulations (and the greater variability in estimating those standard errors) would swamp the standard errors of the larger sample sizes.
Usually, with aggregation, we want to average over something we believe will not change massively over the marginalized-out factors.
Alternatively, we can average over a relative measure (such as standard error divided by the standard error of some baseline method), which tend to be more invariant and comparable across scenarios.</p>
<p>For our cluster RCT, we might aggregate our bias across some of our simulation factors as follows:</p>
<div class="sourceCode" id="cb422"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb422-1"><a href="#cb422-1" tabindex="-1"></a>ssres <span class="ot">&lt;-</span> </span>
<span id="cb422-2"><a href="#cb422-2" tabindex="-1"></a>  sres <span class="sc">%&gt;%</span> </span>
<span id="cb422-3"><a href="#cb422-3" tabindex="-1"></a>  <span class="fu">group_by</span>( ICC, method, alpha, size_coef ) <span class="sc">%&gt;%</span></span>
<span id="cb422-4"><a href="#cb422-4" tabindex="-1"></a>  <span class="fu">summarise</span>( <span class="at">bias =</span> <span class="fu">mean</span>( bias ) )</span>
<span id="cb422-5"><a href="#cb422-5" tabindex="-1"></a></span>
<span id="cb422-6"><a href="#cb422-6" tabindex="-1"></a><span class="fu">ggplot</span>( ssres, <span class="fu">aes</span>( ICC, bias, <span class="at">col=</span>method ) ) <span class="sc">+</span></span>
<span id="cb422-7"><a href="#cb422-7" tabindex="-1"></a>  <span class="fu">facet_grid</span>( alpha <span class="sc">~</span>  size_coef, <span class="at">labeller =</span> label_both ) <span class="sc">+</span></span>
<span id="cb422-8"><a href="#cb422-8" tabindex="-1"></a>  <span class="fu">geom_point</span>( <span class="at">alpha=</span><span class="fl">0.75</span> ) <span class="sc">+</span> </span>
<span id="cb422-9"><a href="#cb422-9" tabindex="-1"></a>  <span class="fu">geom_line</span>( <span class="at">alpha=</span><span class="fl">0.75</span> ) <span class="sc">+</span></span>
<span id="cb422-10"><a href="#cb422-10" tabindex="-1"></a>  <span class="fu">geom_hline</span>( <span class="at">yintercept =</span> <span class="dv">0</span> ) <span class="sc">+</span></span>
<span id="cb422-11"><a href="#cb422-11" tabindex="-1"></a>  <span class="fu">theme_minimal</span>()</span></code></pre></div>
<p><img src="Designing-Simulations-in-R_files/figure-html/unnamed-chunk-226-1.png" width="75%" style="display: block; margin: auto;" /></p>
<p>We see more clearly that site variation leads to greater bias, but only if the coefficient for size is nonzero (which makes sense given our theoretical understanding of the problem–if size is not related to treatment effect, it is hard to imagine how it would bias it).
We also see that all the estimators have near zero bias when thee is no variation in cluster size, with the overplotted lines on the top row of the figure.</p>
<p>We can also let ggplot aggregate directly by taking advantage of the smoothing options:</p>
<div class="sourceCode" id="cb423"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb423-1"><a href="#cb423-1" tabindex="-1"></a><span class="fu">ggplot</span>( sres, <span class="fu">aes</span>( ICC, bias, <span class="at">col=</span>method ) ) <span class="sc">+</span></span>
<span id="cb423-2"><a href="#cb423-2" tabindex="-1"></a>  <span class="fu">facet_grid</span>( alpha <span class="sc">~</span>  size_coef, <span class="at">labeller =</span> label_both ) <span class="sc">+</span></span>
<span id="cb423-3"><a href="#cb423-3" tabindex="-1"></a>    <span class="fu">geom_point</span>( <span class="at">alpha=</span><span class="fl">0.25</span>,</span>
<span id="cb423-4"><a href="#cb423-4" tabindex="-1"></a>              <span class="at">position =</span> <span class="fu">position_dodge</span>(<span class="at">width =</span> <span class="fl">0.04</span>) ) <span class="sc">+</span></span>
<span id="cb423-5"><a href="#cb423-5" tabindex="-1"></a>  <span class="fu">geom_smooth</span>( <span class="at">se=</span><span class="cn">FALSE</span> ) <span class="sc">+</span> </span>
<span id="cb423-6"><a href="#cb423-6" tabindex="-1"></a>  <span class="fu">geom_hline</span>( <span class="at">yintercept =</span> <span class="dv">0</span> ) <span class="sc">+</span></span>
<span id="cb423-7"><a href="#cb423-7" tabindex="-1"></a>  <span class="fu">theme_minimal</span>()</span></code></pre></div>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and
## formula = &#39;y ~ x&#39;</code></pre>
<p><img src="Designing-Simulations-in-R_files/figure-html/unnamed-chunk-227-1.png" width="75%" style="display: block; margin: auto;" /></p>
<p>In the above, we let the original points show as well, to give a sense of the variation across simulation trials.</p>
</div>
<div id="regression-summarization" class="section level3 hasAnchor" number="12.1.4">
<h3 class="hasAnchor"><span class="header-section-number">12.1.4</span> Regression Summarization<a href="#regression-summarization" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>One can treat the simulation results as a dataset in its own right.
In this case we can regress a performance measure against the methods and various factor levels to get “main effects” of how the different levels impact performance, holding the other levels constant.
This type of regression is called a “meta regression” (<span class="citation">Kleijnen (<a href="#ref-kleijnen1981regression">1981</a>)</span>,<span class="citation">Friedman and Pressman (<a href="#ref-friedman1988metamodel">1988</a>)</span>,<span class="citation">Gilbert and Miratrix (<a href="#ref-gilbert2024multilevel">2024</a>)</span>), as we are regressing on already processed results.
It also has ties to meta analysis (see, e.g., <span class="citation">Borenstein et al. (<a href="#ref-borenstein2021introduction">2021</a>)</span>), where we look for trends across sets of experiments.</p>
<p>In a meta regression, the main effect estimated for each method will tell us if a method is, on average, higher or lower than the baseline method, averaging across all the simulation scenarios.
The main effect of the factors will tell us if that factor impacts the performance measure.</p>
<p>These regressions can also include interactions between method and factor, to see if some factors impact different methods differently.
They can also include interactions between factors, which allows us to explore how the impact of a factor can matter more or less, depending on other aspects of the context.</p>
<p>For our cluster RCT, we might have, for example:</p>
<div class="sourceCode" id="cb425"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb425-1"><a href="#cb425-1" tabindex="-1"></a><span class="co"># Make our simulation factors factors rather tha numeric values</span></span>
<span id="cb425-2"><a href="#cb425-2" tabindex="-1"></a>sres_f <span class="ot">=</span> sres <span class="sc">%&gt;%</span></span>
<span id="cb425-3"><a href="#cb425-3" tabindex="-1"></a>  <span class="fu">mutate</span>( <span class="fu">across</span>( <span class="fu">c</span>( n_bar, J, size_coef, ICC, alpha ), factor ) )</span>
<span id="cb425-4"><a href="#cb425-4" tabindex="-1"></a></span>
<span id="cb425-5"><a href="#cb425-5" tabindex="-1"></a><span class="co"># Run the regression</span></span>
<span id="cb425-6"><a href="#cb425-6" tabindex="-1"></a>M <span class="ot">&lt;-</span> <span class="fu">lm</span>( bias <span class="sc">~</span> (n_bar <span class="sc">+</span> J <span class="sc">+</span> size_coef <span class="sc">+</span> ICC <span class="sc">+</span> alpha) <span class="sc">*</span> method, </span>
<span id="cb425-7"><a href="#cb425-7" tabindex="-1"></a>         <span class="at">data =</span> sres_f )</span>
<span id="cb425-8"><a href="#cb425-8" tabindex="-1"></a></span>
<span id="cb425-9"><a href="#cb425-9" tabindex="-1"></a><span class="co"># View the results</span></span>
<span id="cb425-10"><a href="#cb425-10" tabindex="-1"></a>stargazer<span class="sc">::</span><span class="fu">stargazer</span>(M, <span class="at">type =</span> <span class="st">&quot;text&quot;</span>,</span>
<span id="cb425-11"><a href="#cb425-11" tabindex="-1"></a>                     <span class="at">single.row =</span> <span class="cn">TRUE</span> )</span></code></pre></div>
<pre><code>## 
## ==================================================
##                            Dependent variable:    
##                        ---------------------------
##                                   bias            
## --------------------------------------------------
## n_bar80                      -0.001 (0.006)       
## n_bar320                      0.003 (0.006)       
## J20                          -0.005 (0.006)       
## J80                          -0.006 (0.006)       
## size_coef0.2                  0.005 (0.005)       
## ICC0.2                        0.008 (0.008)       
## ICC0.4                        0.003 (0.008)       
## ICC0.6                        0.004 (0.008)       
## ICC0.8                        0.005 (0.008)       
## alpha0.5                     -0.003 (0.006)       
## alpha0.8                      0.006 (0.006)       
## methodLR                     -0.014 (0.012)       
## methodMLM                     0.002 (0.012)       
## n_bar80:methodLR              0.003 (0.009)       
## n_bar320:methodLR             0.001 (0.009)       
## n_bar80:methodMLM            -0.0003 (0.009)      
## n_bar320:methodMLM           -0.001 (0.009)       
## J20:methodLR                  0.005 (0.009)       
## J80:methodLR                  0.006 (0.009)       
## J20:methodMLM                 0.001 (0.009)       
## J80:methodMLM                 0.001 (0.009)       
## size_coef0.2:methodLR        0.018** (0.007)      
## size_coef0.2:methodMLM        0.003 (0.007)       
## ICC0.2:methodLR               0.002 (0.011)       
## ICC0.4:methodLR               0.001 (0.011)       
## ICC0.6:methodLR              -0.0004 (0.011)      
## ICC0.8:methodLR              -0.0001 (0.011)      
## ICC0.2:methodMLM             -0.005 (0.011)       
## ICC0.4:methodMLM             -0.005 (0.011)       
## ICC0.6:methodMLM             -0.006 (0.011)       
## ICC0.8:methodMLM             -0.006 (0.011)       
## alpha0.5:methodLR             0.006 (0.009)       
## alpha0.8:methodLR            0.019** (0.009)      
## alpha0.5:methodMLM            0.001 (0.009)       
## alpha0.8:methodMLM            0.003 (0.009)       
## Constant                     -0.002 (0.009)       
## --------------------------------------------------
## Observations                       810            
## R2                                0.075           
## Adjusted R2                       0.033           
## Residual Std. Error         0.041 (df = 774)      
## F Statistic              1.781*** (df = 35; 774)  
## ==================================================
## Note:                  *p&lt;0.1; **p&lt;0.05; ***p&lt;0.01</code></pre>
<p>We can quickly get a lot of features, making a meta-regression somewhat hard to interpret.
But picking out the significant coefficents is a quick way to obtain a lot of clues as to what is driving performance.
E.g., many features interact with the LR method for bias.
The other two methods seem less impacted.</p>
</div>
<div id="focus-on-a-subset-kick-rest-to-supplement" class="section level3 hasAnchor" number="12.1.5">
<h3 class="hasAnchor"><span class="header-section-number">12.1.5</span> Focus on a subset, kick rest to supplement<a href="#focus-on-a-subset-kick-rest-to-supplement" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Frequently researchers might simply filter the simulation results to a single factor level for some nuisance parameter.
For example, we might examine ICC of 0.20 only, as this is a “reasonable” value that, given our substance matter knowledge, we know is frequently found in empirical data.
We would then consider the other levels as a “sensitivity” analysis vaguely alluded to in our main report and placed elsewhere, such as an online supplemental appendix.</p>
<p>It would be our job, in this case, to verify that our reported findings on the main results indeed were echoed in our other, set-aside, simulation runs.</p>
</div>
</div>
<div id="analyzing-results-when-some-trials-have-failed" class="section level2 hasAnchor" number="12.2">
<h2 class="hasAnchor"><span class="header-section-number">12.2</span> Analyzing results when some trials have failed<a href="#analyzing-results-when-some-trials-have-failed" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>If methods fail, then this is something to investigate in its own right.
Ideally, failure is not too common, so we can drop those trials, or keep them, without really impacting our overall results.
But one should at least know what one is ignoring.</p>
<p>For example, in our cluster RCT, we know we have, at least sometimes, convergence issues.
We also know that ICC is an important feature, so we can explore how often we get a convergence message by ICC level:</p>
<div class="sourceCode" id="cb427"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb427-1"><a href="#cb427-1" tabindex="-1"></a>res <span class="sc">%&gt;%</span> </span>
<span id="cb427-2"><a href="#cb427-2" tabindex="-1"></a>  <span class="fu">group_by</span>( method, ICC ) <span class="sc">%&gt;%</span></span>
<span id="cb427-3"><a href="#cb427-3" tabindex="-1"></a>  <span class="fu">summarise</span>( <span class="at">message =</span> <span class="fu">mean</span>( message ) ) <span class="sc">%&gt;%</span></span>
<span id="cb427-4"><a href="#cb427-4" tabindex="-1"></a>  <span class="fu">pivot_wider</span>( <span class="at">names_from =</span> <span class="st">&quot;method&quot;</span>, <span class="at">values_from=</span><span class="st">&quot;message&quot;</span> )</span></code></pre></div>
<pre><code>## Warning: There were 15 warnings in `summarise()`.
## The first warning was:
## ℹ In argument: `message = mean(message)`.
## ℹ In group 1: `method = &quot;Agg&quot;` `ICC = 0`.
## Caused by warning in `mean.default()`:
## ! argument is not numeric or logical: returning NA
## ℹ Run `dplyr::last_dplyr_warnings()` to see the
##   14 remaining warnings.</code></pre>
<pre><code>## # A tibble: 5 × 4
##     ICC   Agg    LR   MLM
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1   0      NA    NA    NA
## 2   0.2    NA    NA    NA
## 3   0.4    NA    NA    NA
## 4   0.6    NA    NA    NA
## 5   0.8    NA    NA    NA</code></pre>
<p>We see that when the ICC is 0 we get a lot of convergence issues, but as soon as we pull away from 0 it drops off considerably.
At this point we might decide to drop those runs with a message or keep them.
In this case, we decide to keep.
It shouldn’t matter much in any case except the ICC = 0 case, and we know the convergence issues are driven by trying to estimate a 0 variance, and thus is in some sense expected.
Furthermore, we know people using these methods would likely ignore these messages, and thus we are faithfully capturing how these methods would be used in practice.
We might eventually, however, want to do a separate analysis of the ICC = 0 context to see if the MLM approach is actually falling apart, or if it is just throwing warnings.</p>
</div>
<div id="case-study-power-for-a-randomized-trial" class="section level2 hasAnchor" number="12.3">
<h2 class="hasAnchor"><span class="header-section-number">12.3</span> Case study: power for a randomized trial<a href="#case-study-power-for-a-randomized-trial" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>We next walk through a case study where we compare different visualizations of the same performance metric (in this case, power).
The goal is to see how to examine a metric from several perspectives, and to see how to explore simulation results across scenarios.</p>
<p>For this example, we are going to look at a randomized experiment.
We will generate control potential outcomes with a normal distribution, and then add a treatment effect to the treated units.</p>
<p>For our analytic approach, we will estimate the
treatment effect by taking the difference in means.
We will calculate the associated standard error and generate <span class="math inline">\(p\)</span>-values using the normal
approximation.
(As we will see, this is not a good idea for small sample sizes since we should be using a <span class="math inline">\(t\)</span>-test style approach.)</p>
<p>Violating our usual modular approach, we are going to have a single function that does an entire step: our function will generate the data and then analyze it all in one go.
Our function also calculates and returns the true effect size of the DGP as the true treatment
effect divided by the control standard deviation (this true effect size will be useful for understanding power, as we show later on).</p>
<div class="sourceCode" id="cb430"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb430-1"><a href="#cb430-1" tabindex="-1"></a>run.one <span class="ot">=</span> <span class="cf">function</span>( nC, nT, sdC, tau, <span class="at">mu =</span> <span class="dv">5</span>, <span class="at">sdTau =</span> <span class="dv">0</span> ) {</span>
<span id="cb430-2"><a href="#cb430-2" tabindex="-1"></a>  Y0 <span class="ot">=</span> mu <span class="sc">+</span> <span class="fu">rnorm</span>( nC, <span class="at">sd=</span>sdC )</span>
<span id="cb430-3"><a href="#cb430-3" tabindex="-1"></a>  Y1 <span class="ot">=</span> mu <span class="sc">+</span> <span class="fu">rnorm</span>( nT, <span class="at">sd=</span>sdC ) <span class="sc">+</span> tau <span class="sc">+</span> <span class="fu">rnorm</span>( nT, <span class="at">sd=</span>sdTau )</span>
<span id="cb430-4"><a href="#cb430-4" tabindex="-1"></a></span>
<span id="cb430-5"><a href="#cb430-5" tabindex="-1"></a>  tau.hat <span class="ot">=</span> <span class="fu">mean</span>( Y1 ) <span class="sc">-</span> <span class="fu">mean</span>( Y0 )</span>
<span id="cb430-6"><a href="#cb430-6" tabindex="-1"></a>  SE.hat <span class="ot">=</span> <span class="fu">sqrt</span>( <span class="fu">var</span>( Y0 ) <span class="sc">/</span> ( nC ) <span class="sc">+</span> <span class="fu">var</span>( Y1 ) <span class="sc">/</span> ( nT ) )</span>
<span id="cb430-7"><a href="#cb430-7" tabindex="-1"></a></span>
<span id="cb430-8"><a href="#cb430-8" tabindex="-1"></a>  z <span class="ot">=</span> tau.hat <span class="sc">/</span> SE.hat</span>
<span id="cb430-9"><a href="#cb430-9" tabindex="-1"></a>  pv <span class="ot">=</span> <span class="dv">2</span> <span class="sc">*</span> (<span class="dv">1</span> <span class="sc">-</span> <span class="fu">pnorm</span>( <span class="fu">abs</span>( z ) ))</span>
<span id="cb430-10"><a href="#cb430-10" tabindex="-1"></a></span>
<span id="cb430-11"><a href="#cb430-11" tabindex="-1"></a>  <span class="fu">data.frame</span>( <span class="at">tau.hat =</span> tau.hat, <span class="at">SE.hat =</span> SE.hat, </span>
<span id="cb430-12"><a href="#cb430-12" tabindex="-1"></a>              <span class="at">z =</span> z, <span class="at">p.value =</span> pv )</span>
<span id="cb430-13"><a href="#cb430-13" tabindex="-1"></a>}</span></code></pre></div>
<p>Our function generates a data set, analyzes it, and give us back a variety
of results as a one-row dataframe, as per usual:</p>
<div class="sourceCode" id="cb431"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb431-1"><a href="#cb431-1" tabindex="-1"></a><span class="fu">run.one</span>( <span class="at">nT=</span><span class="dv">5</span>, <span class="at">nC=</span><span class="dv">10</span>, <span class="at">sdC=</span><span class="dv">1</span>, <span class="at">tau=</span><span class="fl">0.5</span> )</span></code></pre></div>
<pre><code>##     tau.hat    SE.hat          z   p.value
## 1 -0.246767 0.6607213 -0.3734812 0.7087903</code></pre>
<p>In this case, our results are a mix of the parameters and estimated quantities.</p>
<p>We then write a function that runs our single trial multiple times and
summarizes the results:</p>
<div class="sourceCode" id="cb433"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb433-1"><a href="#cb433-1" tabindex="-1"></a>run.experiment <span class="ot">=</span> <span class="cf">function</span>( nC, nT, sdC, tau, <span class="at">mu =</span> <span class="dv">5</span>, <span class="at">sdTau =</span> <span class="dv">0</span>, <span class="at">R =</span> <span class="dv">500</span> ) {</span>
<span id="cb433-2"><a href="#cb433-2" tabindex="-1"></a>  </span>
<span id="cb433-3"><a href="#cb433-3" tabindex="-1"></a>  eres <span class="ot">=</span> <span class="fu">replicate</span>( R, </span>
<span id="cb433-4"><a href="#cb433-4" tabindex="-1"></a>                    <span class="fu">run.one</span>( nC, nT, sdC, tau, <span class="at">sdTau=</span>sdTau, <span class="at">mu=</span>mu ), </span>
<span id="cb433-5"><a href="#cb433-5" tabindex="-1"></a>                    <span class="at">simplify=</span><span class="cn">FALSE</span> ) <span class="sc">%&gt;%</span></span>
<span id="cb433-6"><a href="#cb433-6" tabindex="-1"></a>    <span class="fu">bind_rows</span>()</span>
<span id="cb433-7"><a href="#cb433-7" tabindex="-1"></a>  </span>
<span id="cb433-8"><a href="#cb433-8" tabindex="-1"></a>  eres <span class="sc">%&gt;%</span> </span>
<span id="cb433-9"><a href="#cb433-9" tabindex="-1"></a>    <span class="fu">summarise</span>( <span class="at">E.tau.hat =</span> <span class="fu">mean</span>( tau.hat ),</span>
<span id="cb433-10"><a href="#cb433-10" tabindex="-1"></a>               <span class="at">E.SE.hat =</span> <span class="fu">mean</span>( SE.hat ),</span>
<span id="cb433-11"><a href="#cb433-11" tabindex="-1"></a>               <span class="at">power =</span> <span class="fu">mean</span>( p.value <span class="sc">&lt;=</span> <span class="fl">0.05</span> ) ) <span class="sc">%&gt;%</span></span>
<span id="cb433-12"><a href="#cb433-12" tabindex="-1"></a>    <span class="fu">mutate</span>( <span class="at">nC=</span>nC, <span class="at">nT=</span>nT, <span class="at">sdC=</span>sdC, <span class="at">tau=</span>tau, <span class="at">mu=</span>mu, <span class="at">sdTau=</span>sdTau, <span class="at">R=</span>R )</span>
<span id="cb433-13"><a href="#cb433-13" tabindex="-1"></a>}</span></code></pre></div>
<p>For performance, we have the average average treatment effect estimate <code>E.tau.hat</code>,
the average Standard Error estimate <code>E.SE.hat</code>,
and the power <code>power</code> (defined as the percent of time we reject at
alpha=0.05, i.e., the percent of times our <span class="math inline">\(p\)</span>-value was less than our 0.05
threshold):</p>
<p>Our function also adds in the details of the simulation (the parameters we passed
to the <code>run.one()</code> call). This is an easy way to keep track of things.</p>
<p>We test our function to see what we get:</p>
<div class="sourceCode" id="cb434"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb434-1"><a href="#cb434-1" tabindex="-1"></a><span class="fu">run.experiment</span>( <span class="dv">10</span>, <span class="dv">3</span>, <span class="dv">1</span>, <span class="fl">0.5</span>, <span class="dv">5</span>, <span class="fl">0.2</span> )</span></code></pre></div>
<pre><code>##   E.tau.hat  E.SE.hat power nC nT sdC tau mu
## 1  0.497077 0.6284977 0.218 10  3   1 0.5  5
##   sdTau   R
## 1   0.2 500</code></pre>
<p>We next use the above to run our multi-factor simulation experiment.
We are going to vary four factors: control group size, treatment group size,
standard deviation of the units, and the treatment effect.</p>
<div class="sourceCode" id="cb436"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb436-1"><a href="#cb436-1" tabindex="-1"></a>nC <span class="ot">=</span> <span class="fu">c</span>( <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">7</span>, <span class="dv">10</span>, <span class="dv">50</span>, <span class="dv">500</span> )</span>
<span id="cb436-2"><a href="#cb436-2" tabindex="-1"></a>nT <span class="ot">=</span> <span class="fu">c</span>( <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">7</span>, <span class="dv">10</span>, <span class="dv">50</span>, <span class="dv">500</span> )</span>
<span id="cb436-3"><a href="#cb436-3" tabindex="-1"></a>sdC <span class="ot">=</span> <span class="fu">c</span>( <span class="dv">1</span> )</span>
<span id="cb436-4"><a href="#cb436-4" tabindex="-1"></a>tau <span class="ot">=</span> <span class="fu">c</span>( <span class="dv">0</span>, <span class="fl">0.5</span>, <span class="dv">1</span> )</span>
<span id="cb436-5"><a href="#cb436-5" tabindex="-1"></a>sdTau <span class="ot">=</span> <span class="fu">c</span>( <span class="dv">0</span>, <span class="fl">0.5</span> )</span>
<span id="cb436-6"><a href="#cb436-6" tabindex="-1"></a></span>
<span id="cb436-7"><a href="#cb436-7" tabindex="-1"></a>experiments <span class="ot">=</span> <span class="fu">expand_grid</span>( <span class="at">nC=</span>nC, <span class="at">nT=</span>nT, <span class="at">sdC=</span>sdC, <span class="at">tau=</span>tau, <span class="at">sdTau =</span> sdTau )</span>
<span id="cb436-8"><a href="#cb436-8" tabindex="-1"></a>experiments</span></code></pre></div>
<pre><code>## # A tibble: 216 × 5
##       nC    nT   sdC   tau sdTau
##    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1     2     2     1   0     0  
##  2     2     2     1   0     0.5
##  3     2     2     1   0.5   0  
##  4     2     2     1   0.5   0.5
##  5     2     2     1   1     0  
##  6     2     2     1   1     0.5
##  7     2     4     1   0     0  
##  8     2     4     1   0     0.5
##  9     2     4     1   0.5   0  
## 10     2     4     1   0.5   0.5
## # ℹ 206 more rows</code></pre>
<p>We next run an experiment for each row of our dataframe of experiment factor
combinations, and save the results.</p>
<div class="sourceCode" id="cb438"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb438-1"><a href="#cb438-1" tabindex="-1"></a>exp.res <span class="ot">&lt;-</span> experiments <span class="sc">%&gt;%</span> </span>
<span id="cb438-2"><a href="#cb438-2" tabindex="-1"></a>  <span class="fu">pmap_df</span>( run.experiment, <span class="at">R=</span><span class="dv">2000</span> )</span>
<span id="cb438-3"><a href="#cb438-3" tabindex="-1"></a><span class="fu">dir.create</span>(<span class="st">&quot;results&quot;</span>, <span class="at">showWarnings =</span> <span class="cn">FALSE</span> )</span>
<span id="cb438-4"><a href="#cb438-4" tabindex="-1"></a><span class="fu">saveRDS</span>( exp.res, <span class="at">file=</span><span class="st">&quot;results/Neyman_RCT_results.rds&quot;</span> )</span></code></pre></div>
<p>The <code>R=2000</code> after <code>run.experiment</code> passes the <em>same</em> parameter of <span class="math inline">\(R=2000\)</span> to each
run (we run the same number of trials for each experiment).
We can put it there rather than have it be a column in our list of factors to run.</p>
<p>Here is a peek at our results:</p>
<div class="sourceCode" id="cb439"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb439-1"><a href="#cb439-1" tabindex="-1"></a><span class="fu">head</span>( exp.res )</span></code></pre></div>
<pre><code>##      E.tau.hat  E.SE.hat  power nC nT sdC tau mu
## 1 -0.001525155 0.8818917 0.1975  2  2   1 0.0  5
## 2 -0.026286662 0.9307269 0.1915  2  2   1 0.0  5
## 3  0.485430674 0.8861287 0.2185  2  2   1 0.5  5
## 4  0.452375661 0.9363909 0.2095  2  2   1 0.5  5
## 5  1.029038283 0.8915091 0.3120  2  2   1 1.0  5
## 6  0.957434064 0.9347139 0.3025  2  2   1 1.0  5
##   sdTau    R
## 1   0.0 2000
## 2   0.5 2000
## 3   0.0 2000
## 4   0.5 2000
## 5   0.0 2000
## 6   0.5 2000</code></pre>
<div id="the-initial-analysis" class="section level3 hasAnchor" number="12.3.1">
<h3 class="hasAnchor"><span class="header-section-number">12.3.1</span> The initial analysis<a href="#the-initial-analysis" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>We are ready to analyze, and we start with plotting.
Plotting is always a good way to visualize simulation results.
We first make our tau into a factor, so <code>ggplot</code> behaves, and then plot all our
experiments as two rows based on one factor (<code>sdTau</code>) with the columns being
another (<code>nT</code>).
Unlike our Cluster RCT, we only have one method, so we can use our color for a different simulation factor.
Within each plot we have the x-axis for one factor (<code>nC</code>) and multiple lines for the final factor (<code>tau</code>).
The <span class="math inline">\(y\)</span>-axis is our outcome of interest, power. We add a 0.05 line to show
when we are rejecting at rates above our nominal <span class="math inline">\(\alpha\)</span>. This plot shows
the relationship of five variables.</p>
<div class="sourceCode" id="cb441"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb441-1"><a href="#cb441-1" tabindex="-1"></a>exp.res <span class="ot">=</span> exp.res <span class="sc">%&gt;%</span> </span>
<span id="cb441-2"><a href="#cb441-2" tabindex="-1"></a>  <span class="fu">mutate</span>( <span class="at">tau =</span> <span class="fu">as.factor</span>( tau ) )</span>
<span id="cb441-3"><a href="#cb441-3" tabindex="-1"></a><span class="fu">ggplot</span>( exp.res, <span class="fu">aes</span>( <span class="at">x=</span>nC, <span class="at">y=</span>power, <span class="at">group=</span>tau, <span class="at">col=</span>tau ) ) <span class="sc">+</span></span>
<span id="cb441-4"><a href="#cb441-4" tabindex="-1"></a>  <span class="fu">facet_grid</span>( sdTau <span class="sc">~</span> nT, <span class="at">labeller=</span>label_both ) <span class="sc">+</span></span>
<span id="cb441-5"><a href="#cb441-5" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span> <span class="fu">geom_line</span>() <span class="sc">+</span></span>
<span id="cb441-6"><a href="#cb441-6" tabindex="-1"></a>  <span class="fu">scale_x_log10</span>() <span class="sc">+</span></span>
<span id="cb441-7"><a href="#cb441-7" tabindex="-1"></a>  <span class="fu">geom_hline</span>( <span class="at">yintercept=</span><span class="fl">0.05</span>, <span class="at">col=</span><span class="st">&quot;black&quot;</span>, <span class="at">lty=</span><span class="dv">2</span>)</span></code></pre></div>
<p><img src="Designing-Simulations-in-R_files/figure-html/unnamed-chunk-235-1.png" width="75%" style="display: block; margin: auto;" /></p>
<p>We are looking at power for different control and treatment group sizes. The tau is our treatment effect, and so for <span class="math inline">\(\tau = 0\)</span> we are looking at validity (false rejection of the null) and for the other <span class="math inline">\(\tau\)</span> power (noticing an effect when it is there).
Notice that we are seeing elevated rejection rates (the tau=0 line is well above 0.05) under the null for small and even moderate sample sizes!</p>
</div>
<div id="focusing-on-validity" class="section level3 hasAnchor" number="12.3.2">
<h3 class="hasAnchor"><span class="header-section-number">12.3.2</span> Focusing on validity<a href="#focusing-on-validity" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Especially when considering power, we might want to separate rejection rates under the null vs. rejection rates when there is a true thing to reject.
In particular, we can subset to specific simulation runs with no treatment impact to assess the validity.</p>
<p>First, we can filter our simulations to large samples to make sure we are seeing rejection rates (<code>power</code>) of around 0.05, which is what we want:</p>
<div class="sourceCode" id="cb442"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb442-1"><a href="#cb442-1" tabindex="-1"></a><span class="fu">filter</span>( exp.res, tau<span class="sc">==</span><span class="dv">0</span>, nT <span class="sc">&gt;=</span> <span class="dv">50</span>, nC <span class="sc">&gt;=</span> <span class="dv">50</span> ) <span class="sc">%&gt;%</span></span>
<span id="cb442-2"><a href="#cb442-2" tabindex="-1"></a>  knitr<span class="sc">::</span><span class="fu">kable</span>(<span class="at">digits=</span><span class="dv">2</span>)</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="right">E.tau.hat</th>
<th align="right">E.SE.hat</th>
<th align="right">power</th>
<th align="right">nC</th>
<th align="right">nT</th>
<th align="right">sdC</th>
<th align="left">tau</th>
<th align="right">mu</th>
<th align="right">sdTau</th>
<th align="right">R</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">0</td>
<td align="right">0.20</td>
<td align="right">0.06</td>
<td align="right">50</td>
<td align="right">50</td>
<td align="right">1</td>
<td align="left">0</td>
<td align="right">5</td>
<td align="right">0.0</td>
<td align="right">2000</td>
</tr>
<tr class="even">
<td align="right">0</td>
<td align="right">0.21</td>
<td align="right">0.05</td>
<td align="right">50</td>
<td align="right">50</td>
<td align="right">1</td>
<td align="left">0</td>
<td align="right">5</td>
<td align="right">0.5</td>
<td align="right">2000</td>
</tr>
<tr class="odd">
<td align="right">0</td>
<td align="right">0.15</td>
<td align="right">0.06</td>
<td align="right">50</td>
<td align="right">500</td>
<td align="right">1</td>
<td align="left">0</td>
<td align="right">5</td>
<td align="right">0.0</td>
<td align="right">2000</td>
</tr>
<tr class="even">
<td align="right">0</td>
<td align="right">0.15</td>
<td align="right">0.05</td>
<td align="right">50</td>
<td align="right">500</td>
<td align="right">1</td>
<td align="left">0</td>
<td align="right">5</td>
<td align="right">0.5</td>
<td align="right">2000</td>
</tr>
<tr class="odd">
<td align="right">0</td>
<td align="right">0.15</td>
<td align="right">0.05</td>
<td align="right">500</td>
<td align="right">50</td>
<td align="right">1</td>
<td align="left">0</td>
<td align="right">5</td>
<td align="right">0.0</td>
<td align="right">2000</td>
</tr>
<tr class="even">
<td align="right">0</td>
<td align="right">0.16</td>
<td align="right">0.06</td>
<td align="right">500</td>
<td align="right">50</td>
<td align="right">1</td>
<td align="left">0</td>
<td align="right">5</td>
<td align="right">0.5</td>
<td align="right">2000</td>
</tr>
<tr class="odd">
<td align="right">0</td>
<td align="right">0.06</td>
<td align="right">0.04</td>
<td align="right">500</td>
<td align="right">500</td>
<td align="right">1</td>
<td align="left">0</td>
<td align="right">5</td>
<td align="right">0.0</td>
<td align="right">2000</td>
</tr>
<tr class="even">
<td align="right">0</td>
<td align="right">0.07</td>
<td align="right">0.06</td>
<td align="right">500</td>
<td align="right">500</td>
<td align="right">1</td>
<td align="left">0</td>
<td align="right">5</td>
<td align="right">0.5</td>
<td align="right">2000</td>
</tr>
</tbody>
</table>
<p>This does check out, which is a nice sanity check that we have implemented everything correctly.
It is ok to use simulation of simple, known, cases to check that our methods are implemented correctly and working as expected.</p>
<p>We can then get fancy and look at false rejection rate (power under <code>tau = 0</code>) as a
function of both nC and nT using an interaction-style plot where we average over the other variables:</p>
<div class="sourceCode" id="cb443"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb443-1"><a href="#cb443-1" tabindex="-1"></a>exp.res.rej <span class="ot">&lt;-</span> exp.res <span class="sc">%&gt;%</span> </span>
<span id="cb443-2"><a href="#cb443-2" tabindex="-1"></a>  <span class="fu">filter</span>( tau <span class="sc">==</span> <span class="dv">0</span> ) <span class="sc">%&gt;%</span></span>
<span id="cb443-3"><a href="#cb443-3" tabindex="-1"></a>  <span class="fu">group_by</span>( nC, nT ) <span class="sc">%&gt;%</span></span>
<span id="cb443-4"><a href="#cb443-4" tabindex="-1"></a>  <span class="fu">summarize</span>( <span class="at">power =</span> <span class="fu">mean</span>( power ),</span>
<span id="cb443-5"><a href="#cb443-5" tabindex="-1"></a>             <span class="at">n =</span> <span class="fu">n</span>() )</span>
<span id="cb443-6"><a href="#cb443-6" tabindex="-1"></a></span>
<span id="cb443-7"><a href="#cb443-7" tabindex="-1"></a>exp.res.rej <span class="ot">=</span> <span class="fu">mutate</span>( exp.res.rej, <span class="at">power =</span> <span class="fu">round</span>( power <span class="sc">*</span> <span class="dv">100</span> ) )</span>
<span id="cb443-8"><a href="#cb443-8" tabindex="-1"></a></span>
<span id="cb443-9"><a href="#cb443-9" tabindex="-1"></a><span class="fu">ggplot</span>( exp.res.rej, <span class="fu">aes</span>( <span class="at">x=</span>nC, <span class="at">y=</span>power, <span class="at">group=</span>nT, <span class="at">col=</span><span class="fu">as.numeric</span>(<span class="fu">as.factor</span>(nT)) ) ) <span class="sc">+</span></span>
<span id="cb443-10"><a href="#cb443-10" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span> <span class="fu">geom_line</span>( <span class="at">size=</span><span class="fl">0.5</span> ) <span class="sc">+</span></span>
<span id="cb443-11"><a href="#cb443-11" tabindex="-1"></a>  <span class="fu">geom_hline</span>( <span class="at">yintercept =</span> <span class="dv">5</span> ) <span class="sc">+</span></span>
<span id="cb443-12"><a href="#cb443-12" tabindex="-1"></a>  <span class="fu">scale_y_continuous</span>( <span class="at">limits =</span> <span class="fu">c</span>( <span class="dv">0</span>, <span class="dv">40</span> ) ) <span class="sc">+</span></span>
<span id="cb443-13"><a href="#cb443-13" tabindex="-1"></a>  <span class="fu">scale_x_log10</span>( <span class="at">breaks =</span> <span class="fu">unique</span>( exp.res.rej<span class="sc">$</span>nC ) ) <span class="sc">+</span></span>
<span id="cb443-14"><a href="#cb443-14" tabindex="-1"></a>  <span class="fu">scale_color_gradient</span>( <span class="at">low =</span> <span class="st">&quot;black&quot;</span>, <span class="at">high=</span><span class="st">&quot;red&quot;</span>,</span>
<span id="cb443-15"><a href="#cb443-15" tabindex="-1"></a>                        <span class="at">labels =</span> <span class="fu">unique</span>( exp.res.rej<span class="sc">$</span>nT ) ) <span class="sc">+</span></span>
<span id="cb443-16"><a href="#cb443-16" tabindex="-1"></a>  <span class="fu">labs</span>( <span class="at">x =</span> <span class="st">&quot;# C&quot;</span>, <span class="at">y =</span> <span class="st">&quot;Power&quot;</span>, <span class="at">colour =</span> <span class="st">&quot;# T&quot;</span> )</span></code></pre></div>
<p><img src="Designing-Simulations-in-R_files/figure-html/plot_interaction_Results-1.png" width="75%" style="display: block; margin: auto;" /></p>
<p>This plot focuses on the validity of our test.
It shows that we can have massively elevated rates when either the number of treated or control units is small (below 7).
It also shows that as the size of one group increases, if the other is small our rejection rates climb! Note how for 4 control units, the <span class="math inline">\(n_T = 500\)</span> line is above the others (except for the <span class="math inline">\(n_T = 2\)</span> line).</p>
</div>
<div id="aggregate-to-look-at-main-effects" class="section level3 hasAnchor" number="12.3.3">
<h3 class="hasAnchor"><span class="header-section-number">12.3.3</span> Aggregate to look at main effects<a href="#aggregate-to-look-at-main-effects" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>We can ignore all the other factors while we look at one specific factor of interest.
This is looking at the <strong>main effect</strong> or <strong>marginal effect</strong> of the factor.</p>
<p>The easy way to do this is to aggregate, letting <code>ggplot</code> smooth our individual points on a
plot.
Be sure to also plot the individual points to see variation, however.</p>
<div class="sourceCode" id="cb444"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb444-1"><a href="#cb444-1" tabindex="-1"></a><span class="fu">ggplot</span>( exp.res, <span class="fu">aes</span>( <span class="at">x=</span>nC, <span class="at">y=</span>power, <span class="at">group=</span>tau, <span class="at">col=</span>tau ) ) <span class="sc">+</span></span>
<span id="cb444-2"><a href="#cb444-2" tabindex="-1"></a>  <span class="fu">geom_jitter</span>( <span class="at">width=</span><span class="fl">0.02</span>, <span class="at">height=</span><span class="dv">0</span>, <span class="at">alpha=</span><span class="fl">0.5</span> ) <span class="sc">+</span></span>
<span id="cb444-3"><a href="#cb444-3" tabindex="-1"></a>  <span class="fu">geom_smooth</span>( <span class="at">se =</span> <span class="cn">FALSE</span> ) <span class="sc">+</span></span>
<span id="cb444-4"><a href="#cb444-4" tabindex="-1"></a>  <span class="fu">scale_x_log10</span>( <span class="at">breaks=</span>nC) <span class="sc">+</span></span>
<span id="cb444-5"><a href="#cb444-5" tabindex="-1"></a>  <span class="fu">geom_hline</span>( <span class="at">yintercept=</span><span class="fl">0.05</span>, <span class="at">col=</span><span class="st">&quot;black&quot;</span>, <span class="at">lty=</span><span class="dv">2</span>)</span></code></pre></div>
<p><img src="Designing-Simulations-in-R_files/figure-html/plotPool-1.png" width="75%" style="display: block; margin: auto;" /></p>
<p>Note how we see our individual runs that we marginalize over as the dots.</p>
<p>To look at our main effects we can also summarize our results, averaging our
experimental runs across other factor levels. For example, in the code below
we average over the different treatment group sizes and standard deviations,
and plot the marginalized results.</p>
<p>To marginalize, we group by the things we want to keep and let <code>summarise()</code>
average over the things we want to get rid of.</p>
<div class="sourceCode" id="cb445"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb445-1"><a href="#cb445-1" tabindex="-1"></a>exp.res.sum <span class="ot">=</span> exp.res <span class="sc">%&gt;%</span> <span class="fu">group_by</span>( nC, tau ) <span class="sc">%&gt;%</span></span>
<span id="cb445-2"><a href="#cb445-2" tabindex="-1"></a>  <span class="fu">summarise</span>( <span class="at">power =</span> <span class="fu">mean</span>( power ) )</span>
<span id="cb445-3"><a href="#cb445-3" tabindex="-1"></a><span class="fu">head</span>( exp.res.sum )</span></code></pre></div>
<pre><code>## # A tibble: 6 × 3
## # Groups:   nC [2]
##      nC tau   power
##   &lt;dbl&gt; &lt;fct&gt; &lt;dbl&gt;
## 1     2 0     0.205
## 2     2 0.5   0.254
## 3     2 1     0.395
## 4     4 0     0.114
## 5     4 0.5   0.204
## 6     4 1     0.427</code></pre>
<div class="sourceCode" id="cb447"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb447-1"><a href="#cb447-1" tabindex="-1"></a><span class="fu">ggplot</span>( exp.res.sum, <span class="fu">aes</span>( <span class="at">x=</span>nC, <span class="at">y=</span>power, <span class="at">group=</span>tau, <span class="at">col=</span>tau ) ) <span class="sc">+</span></span>
<span id="cb447-2"><a href="#cb447-2" tabindex="-1"></a>  <span class="fu">geom_line</span>() <span class="sc">+</span> <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb447-3"><a href="#cb447-3" tabindex="-1"></a>  <span class="fu">scale_x_log10</span>( <span class="at">breaks=</span>nC) <span class="sc">+</span></span>
<span id="cb447-4"><a href="#cb447-4" tabindex="-1"></a>  <span class="fu">geom_hline</span>( <span class="at">yintercept=</span><span class="fl">0.05</span>, <span class="at">col=</span><span class="st">&quot;black&quot;</span>, <span class="at">lty=</span><span class="dv">2</span>)</span></code></pre></div>
<p><img src="Designing-Simulations-in-R_files/figure-html/plotCollapse-1.png" width="75%" style="display: block; margin: auto;" /></p>
<p>We can try to get clever and look at other aspects of our experimental runs.
The above suggests that the smaller of the two groups is dictating when things
going awry, in terms of elevated rejection rates under the null.</p>
<p>We can also look at our results in terms of some more easily interpretable parameters, such as effect size instead of raw treatment effect.</p>
<p>To try and simplify the story, we can try and look at total sample size and the smaller of
the two groups sample size and make two different plots that way.
<!--We also subset to just the `sd=1` cases as there is nothing really different about the two
options; we probably should average across but this could reduce clarity of
the presentation of results:--></p>
<div class="sourceCode" id="cb448"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb448-1"><a href="#cb448-1" tabindex="-1"></a>exp.res <span class="ot">&lt;-</span> exp.res <span class="sc">%&gt;%</span> </span>
<span id="cb448-2"><a href="#cb448-2" tabindex="-1"></a>  <span class="fu">mutate</span>( <span class="at">n =</span> nC <span class="sc">+</span> nT,</span>
<span id="cb448-3"><a href="#cb448-3" tabindex="-1"></a>          <span class="at">n.min =</span> <span class="fu">pmin</span>( nC, nT ) )</span></code></pre></div>
<div class="sourceCode" id="cb449"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb449-1"><a href="#cb449-1" tabindex="-1"></a><span class="fu">ggplot</span>( exp.res, <span class="fu">aes</span>( <span class="at">x=</span>n, <span class="at">y=</span>power, <span class="at">group=</span>tau, <span class="at">col=</span>tau ) ) <span class="sc">+</span></span>
<span id="cb449-2"><a href="#cb449-2" tabindex="-1"></a>  <span class="fu">geom_jitter</span>( <span class="at">width=</span><span class="fl">0.05</span>, <span class="at">height=</span><span class="dv">0</span>) <span class="sc">+</span></span>
<span id="cb449-3"><a href="#cb449-3" tabindex="-1"></a>  <span class="fu">geom_smooth</span>( <span class="at">se =</span> <span class="cn">FALSE</span>, <span class="at">span =</span> <span class="dv">1</span>) <span class="sc">+</span></span>
<span id="cb449-4"><a href="#cb449-4" tabindex="-1"></a>  <span class="fu">scale_x_log10</span>() <span class="sc">+</span></span>
<span id="cb449-5"><a href="#cb449-5" tabindex="-1"></a>  <span class="fu">geom_hline</span>( <span class="at">yintercept=</span><span class="fl">0.05</span>, <span class="at">col=</span><span class="st">&quot;black&quot;</span>, <span class="at">lty=</span><span class="dv">2</span>) <span class="sc">+</span></span>
<span id="cb449-6"><a href="#cb449-6" tabindex="-1"></a>  <span class="fu">labs</span>( <span class="at">title =</span> <span class="st">&quot;Total sample size&quot;</span> )</span>
<span id="cb449-7"><a href="#cb449-7" tabindex="-1"></a></span>
<span id="cb449-8"><a href="#cb449-8" tabindex="-1"></a><span class="fu">ggplot</span>( exp.res, <span class="fu">aes</span>( <span class="at">x=</span>n.min, <span class="at">y=</span>power, <span class="at">group=</span>tau, <span class="at">col=</span>tau ) ) <span class="sc">+</span></span>
<span id="cb449-9"><a href="#cb449-9" tabindex="-1"></a>  <span class="fu">geom_jitter</span>( <span class="at">width=</span><span class="fl">0.05</span>, <span class="at">height=</span><span class="dv">0</span>) <span class="sc">+</span></span>
<span id="cb449-10"><a href="#cb449-10" tabindex="-1"></a>  <span class="fu">geom_smooth</span>( <span class="at">se =</span> <span class="cn">FALSE</span>, <span class="at">span =</span> <span class="dv">1</span>) <span class="sc">+</span></span>
<span id="cb449-11"><a href="#cb449-11" tabindex="-1"></a>  <span class="fu">scale_x_log10</span>() <span class="sc">+</span></span>
<span id="cb449-12"><a href="#cb449-12" tabindex="-1"></a>  <span class="fu">geom_hline</span>( <span class="at">yintercept=</span><span class="fl">0.05</span>, <span class="at">col=</span><span class="st">&quot;black&quot;</span>, <span class="at">lty=</span><span class="dv">2</span>) <span class="sc">+</span></span>
<span id="cb449-13"><a href="#cb449-13" tabindex="-1"></a>  <span class="fu">labs</span>( <span class="at">title =</span> <span class="st">&quot;Minimum group size&quot;</span> )</span></code></pre></div>
<div class="figure" style="text-align: center">
<img src="Designing-Simulations-in-R_files/figure-html/plotA-1.png" alt="Power as a function of total sample size." width="45%" /><img src="Designing-Simulations-in-R_files/figure-html/plotA-2.png" alt="Power as a function of total sample size." width="45%" />
<p class="caption">
(#fig:plotA)Power as a function of total sample size.
</p>
</div>
<p>Note the few observations out in the high <code>n.min</code> region for the second
plot—this plot is a bit strange in that the different levels along the
x-axis are assymetric with respect to each other. It is not balanced.</p>
</div>
<div id="recap" class="section level3 hasAnchor" number="12.3.4">
<h3 class="hasAnchor"><span class="header-section-number">12.3.4</span> Recap<a href="#recap" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Overall, this exploration demonstrates the process of looking at a single performance metric (power) and refining a series of plots to get a sense of what the simulation is taking us.
There are many different plots we might choose, and this depends on the messages we are trying to convey.</p>
<p>The key is to explore, and see what you can learn!</p>
</div>
</div>
<div id="exercises-8" class="section level2 hasAnchor" number="12.4">
<h2 class="hasAnchor"><span class="header-section-number">12.4</span> Exercises<a href="#exercises-8" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<ol style="list-style-type: decimal">
<li>For our cluster RCT, use the simulation results to assess how much better (or worse) the different methods are to each other in terms of confidence interval coverage. What scenarios tend to result in the worst coverage?</li>
</ol>
<!--chapter:end:071-experimental-design-analysis.Rmd-->
</div>
</div>
<div id="case-study-comparing-different-estimators" class="section level1 hasAnchor" number="13">
<h1 class="hasAnchor"><span class="header-section-number">13</span> Case study: Comparing different estimators<a href="#case-study-comparing-different-estimators" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p><em>Features of this case study</em></p>
<ul>
<li>Calculating performance metrics by estimator using tidyverse.</li>
<li>Visualization of simulation results.</li>
<li>Construction of the classic Bias + SE + RMSE performance plot.</li>
</ul>
<p>In this case study we conduct a simulation where we wish to compare different forms of
estimator for estimating the same thing.
In particular, we are going to compare estimation of the
center of a symmetric distribution via mean, trimmed mean, and median (so the
mean and median are the same). These are the three estimation strategies
that we might be comparing in a paper (pretend we have “invented” the trimmed
mean and want to demonstrate its utility).</p>
<p>We are, as usual, going to break building this simulation evaluation down into lots of
functions to show the general framework. This framework can readily be
extended to more complicated simulation studies.
This case study illustrates how methodologists might compare different strategies for estimation, and is what we might see in the “simulation” section of a stats paper.</p>
<div id="the-data-generating-process" class="section level2 hasAnchor" number="13.1">
<h2 class="hasAnchor"><span class="header-section-number">13.1</span> The data generating process<a href="#the-data-generating-process" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>For our data-generation function we will use the scaled <span class="math inline">\(t\)</span>-distribution so
the standard deviation will always be 1 but we will have different fatness of
tails (high chance of outliers):</p>
<div class="sourceCode" id="cb450"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb450-1"><a href="#cb450-1" tabindex="-1"></a>gen.data <span class="ot">=</span> <span class="cf">function</span>( n, mu, df0 ) {</span>
<span id="cb450-2"><a href="#cb450-2" tabindex="-1"></a>    mu <span class="sc">+</span> <span class="fu">rt</span>( n, <span class="at">df=</span>df0 ) <span class="sc">/</span> <span class="fu">sqrt</span>( df0 <span class="sc">/</span> (df0<span class="dv">-2</span>) )</span>
<span id="cb450-3"><a href="#cb450-3" tabindex="-1"></a>}</span></code></pre></div>
<p>The variance of a <span class="math inline">\(t\)</span> distribution is <span class="math inline">\(df/(df-2)\)</span>, so when we divide our observations by the
square root of this, we standardize them so they have unit variance.
See, the standard deviation of our data is 1 (up to random error, and as long as df0 &gt;
2)!:</p>
<div class="sourceCode" id="cb451"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb451-1"><a href="#cb451-1" tabindex="-1"></a><span class="fu">sd</span>( <span class="fu">gen.data</span>( <span class="dv">100000</span>, <span class="at">mu =</span> <span class="dv">0</span>, <span class="at">df0 =</span> <span class="dv">3</span> ) )</span></code></pre></div>
<pre><code>## [1] 1.01542</code></pre>
<p>(Normally our data generation code would be a bit more fancy.)</p>
</div>
<div id="the-data-analysis-methods" class="section level2 hasAnchor" number="13.2">
<h2 class="hasAnchor"><span class="header-section-number">13.2</span> The data analysis methods<a href="#the-data-analysis-methods" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>We next write a function that takes our data and uses all our different
estimators on it. We return a data frame of the three estimates, with each
row being one of our estimators. This is useful if our estimators return an
estimate and a standard error, for example.</p>
<div class="sourceCode" id="cb453"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb453-1"><a href="#cb453-1" tabindex="-1"></a>analyze.data <span class="ot">=</span> <span class="cf">function</span>( data ) {</span>
<span id="cb453-2"><a href="#cb453-2" tabindex="-1"></a>    mn <span class="ot">=</span> <span class="fu">mean</span>( data )</span>
<span id="cb453-3"><a href="#cb453-3" tabindex="-1"></a>    md <span class="ot">=</span> <span class="fu">median</span>( data )</span>
<span id="cb453-4"><a href="#cb453-4" tabindex="-1"></a>    mn.tr <span class="ot">=</span> <span class="fu">mean</span>( data, <span class="at">trim=</span><span class="fl">0.1</span> )</span>
<span id="cb453-5"><a href="#cb453-5" tabindex="-1"></a>    <span class="fu">data.frame</span>( <span class="at">estimator =</span> <span class="fu">c</span>( <span class="st">&quot;mean&quot;</span>, <span class="st">&quot;trim.mean&quot;</span>, <span class="st">&quot;median&quot;</span> ),</span>
<span id="cb453-6"><a href="#cb453-6" tabindex="-1"></a>                <span class="at">estimate =</span> <span class="fu">c</span>( mn, mn.tr, md ) )</span>
<span id="cb453-7"><a href="#cb453-7" tabindex="-1"></a>}</span></code></pre></div>
<p>Let’s test:</p>
<div class="sourceCode" id="cb454"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb454-1"><a href="#cb454-1" tabindex="-1"></a>dt <span class="ot">=</span> <span class="fu">gen.data</span>( <span class="dv">100</span>, <span class="dv">0</span>, <span class="dv">3</span> )</span>
<span id="cb454-2"><a href="#cb454-2" tabindex="-1"></a><span class="fu">analyze.data</span>( dt )</span></code></pre></div>
<pre><code>##   estimator     estimate
## 1      mean -0.044891002
## 2 trim.mean  0.005257327
## 3    median  0.004890847</code></pre>
<p>Note that we have bundled our multiple methods into a single function.
With complex methods we generally advocate a separate function for each method, but sometimes having a host of methods wrapped in a single function can still be clean and tidy code.</p>
<p>Also note the three lines of output for our returned value.
This long-form output will make processing the simulation results easier.
That being said, returning in wide format is also completely legitimate.</p>
</div>
<div id="the-simulation-itself" class="section level2 hasAnchor" number="13.3">
<h2 class="hasAnchor"><span class="header-section-number">13.3</span> The simulation itself<a href="#the-simulation-itself" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>To evaluate, we do a bunch of times, and assess results. Let’s start by looking
at a specific case. We generate 1000 datasets of size 10, and estimate the
center using our three different estimators.</p>
<div class="sourceCode" id="cb456"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb456-1"><a href="#cb456-1" tabindex="-1"></a><span class="fu">library</span>( simhelpers )</span>
<span id="cb456-2"><a href="#cb456-2" tabindex="-1"></a>run_sim <span class="ot">&lt;-</span> <span class="fu">bundle_sim</span>( gen.data, analyze.data )</span>
<span id="cb456-3"><a href="#cb456-3" tabindex="-1"></a>raw.exps <span class="ot">&lt;-</span> <span class="fu">run_sim</span>( <span class="dv">1000</span>, <span class="at">n=</span><span class="dv">10</span>, <span class="at">mu =</span> <span class="dv">0</span>, <span class="at">df0=</span><span class="dv">5</span> )</span></code></pre></div>
<!--Note how our `.id` argument gives each simulation run an ID.  This can be
useful to see how the estimators covary.-->
<p>We now have 1000 estimates for each of our estimators:</p>
<div class="sourceCode" id="cb457"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb457-1"><a href="#cb457-1" tabindex="-1"></a><span class="fu">head</span>( raw.exps )</span></code></pre></div>
<pre><code>##   estimator    estimate
## 1      mean -0.09919345
## 2 trim.mean -0.20887036
## 3    median -0.12237738
## 4      mean -0.19312165
## 5 trim.mean -0.22091715
## 6    median -0.18534152</code></pre>
</div>
<div id="calculating-performance-measures-for-all-our-estimators" class="section level2 hasAnchor" number="13.4">
<h2 class="hasAnchor"><span class="header-section-number">13.4</span> Calculating performance measures for all our estimators<a href="#calculating-performance-measures-for-all-our-estimators" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>We then want to assess estimator performance for each estimator.
We first write a function to calculate what we want from 1000 estimates:</p>
<div class="sourceCode" id="cb459"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb459-1"><a href="#cb459-1" tabindex="-1"></a>estimator.quality <span class="ot">=</span> <span class="cf">function</span>( estimates, mu ) {</span>
<span id="cb459-2"><a href="#cb459-2" tabindex="-1"></a>    RMSE <span class="ot">=</span> <span class="fu">sqrt</span>( <span class="fu">mean</span>( (estimates <span class="sc">-</span> mu)<span class="sc">^</span><span class="dv">2</span> ) )</span>
<span id="cb459-3"><a href="#cb459-3" tabindex="-1"></a>    bias <span class="ot">=</span> <span class="fu">mean</span>( estimates <span class="sc">-</span> mu )</span>
<span id="cb459-4"><a href="#cb459-4" tabindex="-1"></a>    SE <span class="ot">=</span> <span class="fu">sd</span>( estimates )</span>
<span id="cb459-5"><a href="#cb459-5" tabindex="-1"></a>    <span class="fu">data.frame</span>( <span class="at">RMSE=</span>RMSE, <span class="at">bias=</span>bias, <span class="at">SE=</span>SE )</span>
<span id="cb459-6"><a href="#cb459-6" tabindex="-1"></a>}</span></code></pre></div>
<p>The key is our function is estimation-method agnostic: we will use it for each of our three estimators.
Here we evaluate our ‘mean’ estimator:</p>
<div class="sourceCode" id="cb460"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb460-1"><a href="#cb460-1" tabindex="-1"></a><span class="fu">filter</span>( raw.exps, estimator <span class="sc">==</span> <span class="st">&quot;mean&quot;</span> ) <span class="sc">%&gt;%</span></span>
<span id="cb460-2"><a href="#cb460-2" tabindex="-1"></a>    <span class="fu">pull</span>( estimate ) <span class="sc">%&gt;%</span></span>
<span id="cb460-3"><a href="#cb460-3" tabindex="-1"></a>    <span class="fu">estimator.quality</span>( <span class="at">mu =</span> <span class="dv">0</span> )</span></code></pre></div>
<pre><code>##        RMSE        bias        SE
## 1 0.3318663 -0.01079814 0.3318566</code></pre>
<p>Aside: Perhaps, code-wise, the above is piping gone too far? If you don’t like this style, you can do
this:</p>
<div class="sourceCode" id="cb462"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb462-1"><a href="#cb462-1" tabindex="-1"></a><span class="fu">estimator.quality</span>( raw.exps<span class="sc">$</span>estimate[ raw.exps<span class="sc">$</span>estimator<span class="sc">==</span><span class="st">&quot;mean&quot;</span> ], <span class="at">mu =</span> <span class="dv">0</span> )</span></code></pre></div>
<pre><code>##        RMSE        bias        SE
## 1 0.3318663 -0.01079814 0.3318566</code></pre>
<p>To do all our three estimators, we group by estimator and evaluate for each
estimator. In tidyverse 1.0 <code>summarise</code> can handle multiple responses, but they
will look a bit weird in our output, hence the ‘unpack()’ argument which
makes each column its own column (if we do not unpack, we have a “data frame
column” which is an odd thing).</p>
<div class="sourceCode" id="cb464"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb464-1"><a href="#cb464-1" tabindex="-1"></a>raw.exps <span class="sc">%&gt;%</span></span>
<span id="cb464-2"><a href="#cb464-2" tabindex="-1"></a>    <span class="fu">group_by</span>( estimator ) <span class="sc">%&gt;%</span></span>
<span id="cb464-3"><a href="#cb464-3" tabindex="-1"></a>    <span class="fu">summarise</span>( <span class="at">qual =</span> <span class="fu">estimator.quality</span>( estimate, <span class="at">mu =</span> <span class="dv">0</span> ) ) <span class="sc">%&gt;%</span></span>
<span id="cb464-4"><a href="#cb464-4" tabindex="-1"></a>    tidyr<span class="sc">::</span><span class="fu">unpack</span>( <span class="at">cols=</span><span class="fu">c</span>(qual) )</span></code></pre></div>
<pre><code>## # A tibble: 3 × 4
##   estimator  RMSE     bias    SE
##   &lt;chr&gt;     &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;
## 1 mean      0.332 -0.0108  0.332
## 2 median    0.331 -0.00855 0.331
## 3 trim.mean 0.311 -0.0105  0.311</code></pre>
<p>We then pack up the above into a function, as usual.
Our function takes our two parameters of sample size and degrees of freedom, and returns a data frame of results.</p>
<div class="sourceCode" id="cb466"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb466-1"><a href="#cb466-1" tabindex="-1"></a>run.simulation <span class="ot">=</span> <span class="cf">function</span>( n, df0 ) {</span>
<span id="cb466-2"><a href="#cb466-2" tabindex="-1"></a>    raw.exps <span class="ot">&lt;-</span> <span class="fu">replicate</span>( <span class="dv">1000</span>, {</span>
<span id="cb466-3"><a href="#cb466-3" tabindex="-1"></a>        dt <span class="ot">=</span> <span class="fu">gen.data</span>( <span class="at">n=</span>n, <span class="at">mu =</span> <span class="dv">0</span>, <span class="at">df0=</span>df0 )</span>
<span id="cb466-4"><a href="#cb466-4" tabindex="-1"></a>        <span class="fu">analyze.data</span>( dt )</span>
<span id="cb466-5"><a href="#cb466-5" tabindex="-1"></a>    }, <span class="at">simplify =</span> <span class="cn">FALSE</span> )</span>
<span id="cb466-6"><a href="#cb466-6" tabindex="-1"></a>    raw.exps <span class="ot">=</span> <span class="fu">bind_rows</span>( raw.exps, <span class="at">.id =</span> <span class="st">&quot;runID&quot;</span> )</span>
<span id="cb466-7"><a href="#cb466-7" tabindex="-1"></a></span>
<span id="cb466-8"><a href="#cb466-8" tabindex="-1"></a>    rs <span class="ot">&lt;-</span> raw.exps <span class="sc">%&gt;%</span></span>
<span id="cb466-9"><a href="#cb466-9" tabindex="-1"></a>        <span class="fu">group_by</span>( estimator ) <span class="sc">%&gt;%</span></span>
<span id="cb466-10"><a href="#cb466-10" tabindex="-1"></a>        <span class="fu">summarise</span>( <span class="at">qual =</span> <span class="fu">estimator.quality</span>( estimate, <span class="at">mu =</span> <span class="dv">0</span> ) ) <span class="sc">%&gt;%</span></span>
<span id="cb466-11"><a href="#cb466-11" tabindex="-1"></a>        tidyr<span class="sc">::</span><span class="fu">unpack</span>( <span class="at">cols=</span><span class="fu">c</span>( qual ) )</span>
<span id="cb466-12"><a href="#cb466-12" tabindex="-1"></a></span>
<span id="cb466-13"><a href="#cb466-13" tabindex="-1"></a>    rs</span>
<span id="cb466-14"><a href="#cb466-14" tabindex="-1"></a>}</span></code></pre></div>
<p>Our function will take our two parameters, run a simulation, and give us the
results. We see here that none of our estimators are particularly biased and
the trimmed mean has, possibly, the smallest RMSE, although it is a close
call.</p>
<div class="sourceCode" id="cb467"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb467-1"><a href="#cb467-1" tabindex="-1"></a><span class="fu">run.simulation</span>( <span class="dv">10</span>, <span class="dv">5</span> )</span></code></pre></div>
<pre><code>## # A tibble: 3 × 4
##   estimator  RMSE    bias    SE
##   &lt;chr&gt;     &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;
## 1 mean      0.318 0.0136  0.318
## 2 median    0.315 0.00888 0.315
## 3 trim.mean 0.294 0.0111  0.294</code></pre>
<p>Ok, now we want to see how sample size impacts our different estimators. If
we also vary degrees of freedom we have a <em>three</em>-factor experiment, where
one of the factors is our estimator itself. We are going to use a new clever
trick. As before, we use <code>pmap()</code>, but now we store the entire dataframe of
results we get back from our function in a new column of our original
dataframe. See R for DS, Chapter 25.3. This trick works best if we have
everything as a <code>tibble</code> which is basically a dataframe that prints a lot
nicer and doesn’t try to second-guess what you are up to all the time.</p>
<div class="sourceCode" id="cb469"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb469-1"><a href="#cb469-1" tabindex="-1"></a>ns <span class="ot">=</span> <span class="fu">c</span>( <span class="dv">10</span>, <span class="dv">50</span>, <span class="dv">250</span>, <span class="dv">1250</span> )</span>
<span id="cb469-2"><a href="#cb469-2" tabindex="-1"></a>dfs <span class="ot">=</span> <span class="fu">c</span>( <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">15</span>, <span class="dv">30</span> )</span>
<span id="cb469-3"><a href="#cb469-3" tabindex="-1"></a>lvls <span class="ot">=</span> <span class="fu">expand_grid</span>( <span class="at">n=</span>ns, <span class="at">df=</span>dfs )</span>
<span id="cb469-4"><a href="#cb469-4" tabindex="-1"></a></span>
<span id="cb469-5"><a href="#cb469-5" tabindex="-1"></a><span class="co"># So it stores our dataframe results in our lvls data properly.</span></span>
<span id="cb469-6"><a href="#cb469-6" tabindex="-1"></a>lvls <span class="ot">=</span> <span class="fu">as_tibble</span>(lvls)</span>
<span id="cb469-7"><a href="#cb469-7" tabindex="-1"></a></span>
<span id="cb469-8"><a href="#cb469-8" tabindex="-1"></a>results <span class="ot">&lt;-</span> lvls <span class="sc">%&gt;%</span> <span class="fu">mutate</span>( <span class="at">results =</span> <span class="fu">pmap</span>( lvls, run.simulation ) )</span></code></pre></div>
<p>We have stored our results (a bunch of dataframes) in our main matrix of
simulation runs.</p>
<div class="sourceCode" id="cb470"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb470-1"><a href="#cb470-1" tabindex="-1"></a><span class="fu">print</span>( results, <span class="at">n=</span><span class="dv">4</span> )</span></code></pre></div>
<pre><code>## # A tibble: 16 × 3
##       n    df results         
##   &lt;dbl&gt; &lt;dbl&gt; &lt;list&gt;          
## 1    10     3 &lt;tibble [3 × 4]&gt;
## 2    10     5 &lt;tibble [3 × 4]&gt;
## 3    10    15 &lt;tibble [3 × 4]&gt;
## 4    10    30 &lt;tibble [3 × 4]&gt;
## # ℹ 12 more rows</code></pre>
<p>The <code>unnest()</code> function will stack up our dataframes, replicating the other columns in the main dataframe so it makes a nice rectangular dataset, all nice like. See (hard to read) R for DS Chapter 25.4.</p>
<div class="sourceCode" id="cb472"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb472-1"><a href="#cb472-1" tabindex="-1"></a>results <span class="ot">&lt;-</span> <span class="fu">unnest</span>( results, <span class="at">cols=</span><span class="st">&quot;results&quot;</span> )</span>
<span id="cb472-2"><a href="#cb472-2" tabindex="-1"></a>results</span></code></pre></div>
<pre><code>## # A tibble: 48 × 6
##        n    df estimator  RMSE      bias    SE
##    &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;
##  1    10     3 mean      0.308 -0.00795  0.308
##  2    10     3 median    0.244 -0.00403  0.244
##  3    10     3 trim.mean 0.250 -0.00347  0.250
##  4    10     5 mean      0.321 -0.00142  0.322
##  5    10     5 median    0.315 -0.00763  0.315
##  6    10     5 trim.mean 0.294 -0.000161 0.294
##  7    10    15 mean      0.316 -0.00903  0.316
##  8    10    15 median    0.357  0.00890  0.357
##  9    10    15 trim.mean 0.316 -0.00138  0.316
## 10    10    30 mean      0.315 -0.00450  0.315
## # ℹ 38 more rows</code></pre>
<p>And plot:</p>
<div class="sourceCode" id="cb474"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb474-1"><a href="#cb474-1" tabindex="-1"></a><span class="fu">ggplot</span>( results, <span class="fu">aes</span>(<span class="at">x=</span>n, <span class="at">y=</span>RMSE, <span class="at">col=</span>estimator) ) <span class="sc">+</span></span>
<span id="cb474-2"><a href="#cb474-2" tabindex="-1"></a>            <span class="fu">facet_wrap</span>( <span class="sc">~</span> df, <span class="at">nrow=</span><span class="dv">1</span> ) <span class="sc">+</span></span>
<span id="cb474-3"><a href="#cb474-3" tabindex="-1"></a>            <span class="fu">geom_line</span>() <span class="sc">+</span> <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb474-4"><a href="#cb474-4" tabindex="-1"></a>            <span class="fu">scale_x_log10</span>( <span class="at">breaks=</span>ns )</span></code></pre></div>
<p><img src="Designing-Simulations-in-R_files/figure-html/unnamed-chunk-254-1.png" width="75%" style="display: block; margin: auto;" /></p>
</div>
<div id="improving-the-visualization-of-the-results" class="section level2 hasAnchor" number="13.5">
<h2 class="hasAnchor"><span class="header-section-number">13.5</span> Improving the visualization of the results<a href="#improving-the-visualization-of-the-results" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>The above doesn’t show differences clearly because all the RMSE goes to zero.
It helps to log our outcome, or otherwise rescale. The logging version shows
differences are relatively constant given changing sample size.</p>
<div class="sourceCode" id="cb475"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb475-1"><a href="#cb475-1" tabindex="-1"></a><span class="fu">ggplot</span>( results, <span class="fu">aes</span>(<span class="at">x=</span>n, <span class="at">y=</span>RMSE, <span class="at">col=</span>estimator) ) <span class="sc">+</span></span>
<span id="cb475-2"><a href="#cb475-2" tabindex="-1"></a>    <span class="fu">facet_wrap</span>( <span class="sc">~</span> df, <span class="at">nrow=</span><span class="dv">1</span> ) <span class="sc">+</span></span>
<span id="cb475-3"><a href="#cb475-3" tabindex="-1"></a>    <span class="fu">geom_line</span>() <span class="sc">+</span> <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb475-4"><a href="#cb475-4" tabindex="-1"></a>    <span class="fu">scale_x_log10</span>( <span class="at">breaks=</span>ns ) <span class="sc">+</span></span>
<span id="cb475-5"><a href="#cb475-5" tabindex="-1"></a>    <span class="fu">scale_y_log10</span>()</span></code></pre></div>
<p><img src="Designing-Simulations-in-R_files/figure-html/unnamed-chunk-255-1.png" width="75%" style="display: block; margin: auto;" /></p>
<p>Better is to rescale using our knowledge of standard errors. If we scale by
the square root of sample size, we should get horizontal lines. We now
clearly see the trends.</p>
<div class="sourceCode" id="cb476"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb476-1"><a href="#cb476-1" tabindex="-1"></a>results <span class="ot">&lt;-</span> <span class="fu">mutate</span>( results, <span class="at">scaleRMSE =</span> RMSE <span class="sc">*</span> <span class="fu">sqrt</span>(n) )</span></code></pre></div>
<div class="sourceCode" id="cb477"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb477-1"><a href="#cb477-1" tabindex="-1"></a><span class="fu">ggplot</span>( results, <span class="fu">aes</span>(<span class="at">x=</span>n, <span class="at">y=</span>scaleRMSE, <span class="at">col=</span>estimator) ) <span class="sc">+</span></span>
<span id="cb477-2"><a href="#cb477-2" tabindex="-1"></a>    <span class="fu">facet_wrap</span>( <span class="sc">~</span> df, <span class="at">nrow=</span><span class="dv">1</span>) <span class="sc">+</span></span>
<span id="cb477-3"><a href="#cb477-3" tabindex="-1"></a>    <span class="fu">geom_line</span>() <span class="sc">+</span> <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb477-4"><a href="#cb477-4" tabindex="-1"></a>    <span class="fu">scale_x_log10</span>( <span class="at">breaks=</span>ns )</span></code></pre></div>
<p><img src="Designing-Simulations-in-R_files/figure-html/unnamed-chunk-257-1.png" width="75%" style="display: block; margin: auto;" /></p>
<p>Overall, we see the scaled error of the mean it is stable across the
different distributions. The trimmed mean is a real advantage when the
degrees of freedom are small. We are cropping outliers that destabilize our
estimate which leads to great wins. As the distribution grows more normal,
this is no longer an advantage and we get closer to the mean in terms of
performance. Here we are penalized slightly bye having dropped 10% of our
data, so the standard errors will be slightly larger.</p>
<p>The median is not able to take advantage of the nuances of a data set because
it is entirely determined by the middle value. When outliers cause real
concern, this cost is minimal. When outliers are not a concern, the median is
just worse.</p>
<p>Overall, the trimmed mean seems an excellent choice: in the presence of
outliers it is far more stable than the mean, and when there are no outliers
the cost of using it is small.</p>
<p>In terms of thinking about designing simulation studies, we see clear
visual displays of simulation results can tell very clear stories. Eschew
complicated tables with lots of numbers.</p>
</div>
<div id="extension-the-bias-variance-tradeoff" class="section level2 hasAnchor" number="13.6">
<h2 class="hasAnchor"><span class="header-section-number">13.6</span> Extension: The Bias-variance tradeoff<a href="#extension-the-bias-variance-tradeoff" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>We can use the above simulation to examine these same estimators when we the
median is not the same as the mean. Say we want the mean of a distribution,
but have systematic outliers. If we just use the median, or trimmed mean, we
might have bias if the outliers tend to be on one side or another. For
example, consider the exponential distribution:</p>
<div class="sourceCode" id="cb478"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb478-1"><a href="#cb478-1" tabindex="-1"></a>nums <span class="ot">=</span> <span class="fu">rexp</span>( <span class="dv">100000</span> )</span>
<span id="cb478-2"><a href="#cb478-2" tabindex="-1"></a><span class="fu">mean</span>( nums )</span></code></pre></div>
<pre><code>## [1] 1.002233</code></pre>
<div class="sourceCode" id="cb480"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb480-1"><a href="#cb480-1" tabindex="-1"></a><span class="fu">mean</span>( nums, <span class="at">trim=</span><span class="fl">0.1</span> )</span></code></pre></div>
<pre><code>## [1] 0.8323088</code></pre>
<div class="sourceCode" id="cb482"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb482-1"><a href="#cb482-1" tabindex="-1"></a><span class="fu">median</span>( nums )</span></code></pre></div>
<pre><code>## [1] 0.6908992</code></pre>
<p>Our trimming, etc., is <em>biased</em> if we think of our goal as estimating the
mean. But if the trimmed estimators are much more stable, we might still
wish to use them. Let’s find out.</p>
<p>Let’s generate a mixture distribution, just for fun. It will have a nice
normal base with some extreme outliers. We will make sure the overall mean,
including the outliers, is always 1, however. (So our target, <span class="math inline">\(\mu\)</span> is now 1,
not 0.)</p>
<div class="sourceCode" id="cb484"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb484-1"><a href="#cb484-1" tabindex="-1"></a>gen.data.outliers <span class="ot">=</span> <span class="cf">function</span>( n, <span class="at">prob.outlier =</span> <span class="fl">0.05</span> ) {</span>
<span id="cb484-2"><a href="#cb484-2" tabindex="-1"></a>    nN <span class="ot">=</span> <span class="fu">rbinom</span>( <span class="dv">1</span>, n, prob.outlier )</span>
<span id="cb484-3"><a href="#cb484-3" tabindex="-1"></a>    nrm <span class="ot">=</span> <span class="fu">rnorm</span>( n <span class="sc">-</span> nN, <span class="at">mean=</span><span class="fl">0.5</span>, <span class="at">sd=</span><span class="dv">1</span> )</span>
<span id="cb484-4"><a href="#cb484-4" tabindex="-1"></a>    outmean <span class="ot">=</span> (<span class="dv">1</span> <span class="sc">-</span> (<span class="dv">1</span><span class="sc">-</span>prob.outlier)<span class="sc">/</span><span class="dv">2</span>) <span class="sc">/</span> prob.outlier</span>
<span id="cb484-5"><a href="#cb484-5" tabindex="-1"></a>    outs <span class="ot">=</span> <span class="fu">rnorm</span>( nN, <span class="at">mean=</span>outmean, <span class="at">sd=</span><span class="dv">10</span> )</span>
<span id="cb484-6"><a href="#cb484-6" tabindex="-1"></a>    <span class="fu">c</span>( nrm, outs )</span>
<span id="cb484-7"><a href="#cb484-7" tabindex="-1"></a>}</span></code></pre></div>
<p>Let’s look at our distribution</p>
<div class="sourceCode" id="cb485"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb485-1"><a href="#cb485-1" tabindex="-1"></a>Y <span class="ot">=</span> <span class="fu">gen.data.outliers</span>( <span class="dv">10000000</span>, <span class="at">prob.outlier =</span> <span class="fl">0.05</span> )</span>
<span id="cb485-2"><a href="#cb485-2" tabindex="-1"></a><span class="fu">mean</span>( Y )</span></code></pre></div>
<pre><code>## [1] 1.000522</code></pre>
<div class="sourceCode" id="cb487"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb487-1"><a href="#cb487-1" tabindex="-1"></a><span class="fu">sd</span>( Y )</span></code></pre></div>
<pre><code>## [1] 3.273068</code></pre>
<div class="sourceCode" id="cb489"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb489-1"><a href="#cb489-1" tabindex="-1"></a><span class="fu">hist</span>( Y, <span class="at">breaks=</span><span class="dv">30</span>, <span class="at">col=</span><span class="st">&quot;grey&quot;</span>, <span class="at">prob=</span><span class="cn">TRUE</span> )</span></code></pre></div>
<p><img src="Designing-Simulations-in-R_files/figure-html/unnamed-chunk-260-1.png" width="75%" style="display: block; margin: auto;" /></p>
<p>We steal the code from above, modifying it slightly for our new function and
changing our target parameter from 0 to 1:</p>
<div class="sourceCode" id="cb490"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb490-1"><a href="#cb490-1" tabindex="-1"></a>run.simulation.exp <span class="ot">=</span> <span class="cf">function</span>( n ) {</span>
<span id="cb490-2"><a href="#cb490-2" tabindex="-1"></a>    raw.exps <span class="ot">&lt;-</span> <span class="fu">replicate</span>( <span class="dv">1000</span>, {</span>
<span id="cb490-3"><a href="#cb490-3" tabindex="-1"></a>        dt <span class="ot">=</span> <span class="fu">gen.data.outliers</span>( <span class="at">n=</span>n )</span>
<span id="cb490-4"><a href="#cb490-4" tabindex="-1"></a>        <span class="fu">analyze.data</span>( dt )</span>
<span id="cb490-5"><a href="#cb490-5" tabindex="-1"></a>    }, <span class="at">simplify =</span> <span class="cn">FALSE</span> )</span>
<span id="cb490-6"><a href="#cb490-6" tabindex="-1"></a>    raw.exps <span class="ot">=</span> <span class="fu">bind_rows</span>( raw.exps, <span class="at">.id =</span> <span class="st">&quot;runID&quot;</span> )</span>
<span id="cb490-7"><a href="#cb490-7" tabindex="-1"></a></span>
<span id="cb490-8"><a href="#cb490-8" tabindex="-1"></a>    rs <span class="ot">&lt;-</span> raw.exps <span class="sc">%&gt;%</span></span>
<span id="cb490-9"><a href="#cb490-9" tabindex="-1"></a>        <span class="fu">group_by</span>( estimator ) <span class="sc">%&gt;%</span></span>
<span id="cb490-10"><a href="#cb490-10" tabindex="-1"></a>        <span class="fu">summarise</span>( <span class="at">qual =</span> <span class="fu">estimator.quality</span>( estimate, <span class="at">mu =</span> <span class="dv">1</span> ) ) <span class="sc">%&gt;%</span></span>
<span id="cb490-11"><a href="#cb490-11" tabindex="-1"></a>        tidyr<span class="sc">::</span><span class="fu">unpack</span>( <span class="at">cols =</span> <span class="fu">c</span>( qual ) )</span>
<span id="cb490-12"><a href="#cb490-12" tabindex="-1"></a></span>
<span id="cb490-13"><a href="#cb490-13" tabindex="-1"></a>    rs</span>
<span id="cb490-14"><a href="#cb490-14" tabindex="-1"></a>}</span>
<span id="cb490-15"><a href="#cb490-15" tabindex="-1"></a></span>
<span id="cb490-16"><a href="#cb490-16" tabindex="-1"></a>res <span class="ot">=</span> <span class="fu">run.simulation.exp</span>( <span class="dv">100</span> )</span>
<span id="cb490-17"><a href="#cb490-17" tabindex="-1"></a>res</span></code></pre></div>
<pre><code>## # A tibble: 3 × 4
##   estimator  RMSE     bias    SE
##   &lt;chr&gt;     &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;
## 1 mean      0.326 -0.00208 0.326
## 2 median    0.475 -0.457   0.130
## 3 trim.mean 0.455 -0.440   0.115</code></pre>
<p>And for our experiment we vary the sample size</p>
<div class="sourceCode" id="cb492"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb492-1"><a href="#cb492-1" tabindex="-1"></a>ns <span class="ot">=</span> <span class="fu">c</span>( <span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">40</span>, <span class="dv">80</span>, <span class="dv">160</span>, <span class="dv">320</span> )</span>
<span id="cb492-2"><a href="#cb492-2" tabindex="-1"></a>lvls <span class="ot">=</span> <span class="fu">tibble</span>( <span class="at">n=</span>ns )</span></code></pre></div>
<div class="sourceCode" id="cb493"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb493-1"><a href="#cb493-1" tabindex="-1"></a>results <span class="ot">&lt;-</span> lvls <span class="sc">%&gt;%</span> </span>
<span id="cb493-2"><a href="#cb493-2" tabindex="-1"></a>  <span class="fu">mutate</span>( <span class="at">results =</span> <span class="fu">pmap</span>( lvls, run.simulation.exp ) ) <span class="sc">%&gt;%</span> </span>
<span id="cb493-3"><a href="#cb493-3" tabindex="-1"></a>  <span class="fu">unnest</span>( <span class="at">cols =</span> <span class="fu">c</span>(results) )</span>
<span id="cb493-4"><a href="#cb493-4" tabindex="-1"></a><span class="fu">head</span>( results )</span></code></pre></div>
<pre><code>## # A tibble: 6 × 5
##       n estimator  RMSE      bias    SE
##   &lt;dbl&gt; &lt;chr&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;
## 1    10 mean      1.04  -0.0265   1.04 
## 2    10 median    0.593 -0.454    0.381
## 3    10 trim.mean 0.655 -0.381    0.533
## 4    20 mean      0.740 -0.000791 0.740
## 5    20 median    0.536 -0.454    0.285
## 6    20 trim.mean 0.518 -0.410    0.317</code></pre>
<p>Here we are going to plot multiple outcomes. Often with the simulation study
we are interested in different measures of performance. For us, we want to
know the standard error, bias, and overall error (RMSE). To plot this we
first gather our outcomes to make a long form dataframe of results:</p>
<div class="sourceCode" id="cb495"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb495-1"><a href="#cb495-1" tabindex="-1"></a>res2 <span class="ot">=</span> <span class="fu">gather</span>( results, RMSE, bias, SE, <span class="at">key=</span><span class="st">&quot;Measure&quot;</span>,<span class="at">value=</span><span class="st">&quot;value&quot;</span> )</span>
<span id="cb495-2"><a href="#cb495-2" tabindex="-1"></a>res2 <span class="ot">=</span> <span class="fu">mutate</span>( res2, <span class="at">Measure =</span> <span class="fu">factor</span>( Measure, <span class="at">levels=</span><span class="fu">c</span>(<span class="st">&quot;SE&quot;</span>,<span class="st">&quot;bias&quot;</span>,<span class="st">&quot;RMSE&quot;</span> )))</span></code></pre></div>
<p>And then we plot, making a facet for each outcome of interest:</p>
<div class="sourceCode" id="cb496"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb496-1"><a href="#cb496-1" tabindex="-1"></a><span class="fu">ggplot</span>( res2, <span class="fu">aes</span>(<span class="at">x=</span>n, <span class="at">y=</span>value, <span class="at">col=</span>estimator) ) <span class="sc">+</span></span>
<span id="cb496-2"><a href="#cb496-2" tabindex="-1"></a>    <span class="fu">facet_grid</span>( . <span class="sc">~</span> Measure ) <span class="sc">+</span></span>
<span id="cb496-3"><a href="#cb496-3" tabindex="-1"></a>    <span class="fu">geom_hline</span>( <span class="at">yintercept=</span><span class="dv">0</span>, <span class="at">col=</span><span class="st">&quot;darkgrey&quot;</span> ) <span class="sc">+</span></span>
<span id="cb496-4"><a href="#cb496-4" tabindex="-1"></a>    <span class="fu">geom_line</span>() <span class="sc">+</span> <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb496-5"><a href="#cb496-5" tabindex="-1"></a>    <span class="fu">scale_x_log10</span>( <span class="at">breaks=</span>ns ) <span class="sc">+</span></span>
<span id="cb496-6"><a href="#cb496-6" tabindex="-1"></a>    <span class="fu">labs</span>( <span class="at">y=</span><span class="st">&quot;&quot;</span> )</span></code></pre></div>
<p><img src="Designing-Simulations-in-R_files/figure-html/unnamed-chunk-264-1.png" width="75%" style="display: block; margin: auto;" /></p>
<p>We see how different estimators have different biases and different
uncertainties. The bias is negative for our trimmed estimators because we
are losing the big outliers above and so getting answers that are too low.</p>
<p>The RMSE captures the trade-off in terms of what estimator gives the lowest
overall <em>error</em>. For this distribution, the mean wins as the sample size
increases because the bias basically stays the same and the SE drops. But
for smaller samples the trimming is superior. The median (essentially
trimming 50% above and below) is overkill and has too much negative bias.</p>
<p>From a simulation study point of view, notice how we are looking at three
different qualities of our estimators. Some people really care about bias,
some care about RMSE. By presenting all results we are transparent about how
the different estimators operate.</p>
<p>Next steps would be to also examine the associated estimated standard errors
for the estimators, seeing if these estimates of estimator uncertainty are
good or poor. This leads to investigation of coverage rates and similar.</p>
<!--chapter:end:072-case-study-comparing-estimators.Rmd-->
</div>
</div>
<div id="presentation-of-simulation-results" class="section level1 hasAnchor" number="14">
<h1 class="hasAnchor"><span class="header-section-number">14</span> Presentation of simulation results<a href="#presentation-of-simulation-results" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p>Last chapter, we started to investigate how to present a multifactor experiment.
In this chapter, we talk about some principles behind the choices one might make in generating final reports of a simulation.
There are three primary approaches for presenting simulation results:</p>
<ol style="list-style-type: decimal">
<li>Tabulation</li>
<li>Visualization</li>
<li>Modeling</li>
</ol>
<p>There are generally two primary goals for your results:</p>
<ul>
<li>Develop evidence that addresses your research questions.</li>
<li>Understand the effects of the factors manipulated in the simulation.</li>
</ul>
<p>For your final write-up, you will not want to present everything.
A wall of numbers and observations only serves to pummel the reader, rather than inform them; readers rarely enjoy being pummeled, and so they will simply skim or skip such material while feeling hurt and betrayed.
Instead, present selected results that clearly illustrate the main findings from the study, along with anything unusual/anomalous.
Your presentation will typically be best served with a few well-chosen figures.
Then, in the text of your write-up, you might include a few specific numerical comparisons.
Do not include too many of these, and be sure to say why the numerical comparisons you include are important.
Finally, have supplementary materials that contain further detail such as additional figures and analysis, and the complete simulation results.</p>
<!--If you want to be a moral person worthy of the awards of Heaven-->
<p>To give a great legitimacy bump to your work, you should also provide reproducible code so others could, if so desired, rerun the simulation and conduct the analysis themselves.
Even if no one touches your code, the code’s existence and availability builds confidence.
People will naturally think, “if that researcher is so willing to let me see what they actually did, then they must be fairly confident it does not contain too many horrendous mistakes.”</p>
<p>We next walk through the three modes of engaging with one’s simulation results, with a few examples taken from the literature.</p>
<div id="tabulation" class="section level2 hasAnchor" number="14.1">
<h2 class="hasAnchor"><span class="header-section-number">14.1</span> Tabulation<a href="#tabulation" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Traditionally, simulation study results are presented in big tables.
We think this doesn’t really make the take-aways of a simulation readily apparent.
Perhaps tables are fine if…
- they involve only a few numbers, and a few targeted comparisons.
- it is important to report <em>exact</em> values for some quantities.</p>
<p>Unfortunately, simulations usually produce lots of numbers, and involve making lots of comparisons.
You are going to want to show, for example, the relative performance of alternative estimators, or the performance of your estimators under different conditions for the data-generating model.
This means a lot of rows, and a lot of dimensions.
Tables can do two dimensions; when you try to cram more than that into a table, no one is particularly well served.</p>
<p>Furthermore, in simulation, exact values for your bias/RMSE/type-I error, or whatever, are not usually of interest. And in fact, we rarely have them due to Monte Carlo simulation error.
The tables provide a false sense of security, unless you include uncertainty, which clutters your table even further.</p>
<p>Overall, tables and simulations do not particularly well mix.
In particular, if you are ever tempted into putting your table in landscape mode to get it to fit on the page, think again.
It is often more useful and insightful to present results in graphs <span class="citation">(<a href="#ref-gelman2002let">Gelman, Pasarica, and Dodhia 2002</a>)</span>.</p>
<p>So, onwards.</p>
</div>
<div id="visualization" class="section level2 hasAnchor" number="14.2">
<h2 class="hasAnchor"><span class="header-section-number">14.2</span> Visualization<a href="#visualization" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Visualization should nearly always be the first step in analyzing simulation results.</p>
<p>This often requires creating a <em>bunch</em> of graphs to look at different aspects of the data.
From that pile of graphs, you would then refine ones that communicate the overall results most cleanly, and include those in your main write-up.
We find we often generate a series of R Markdown reports that load the simulation results and generate these visualizations as an initial document to talk about internally with the research team.</p>
<p>Especially with multi-factor simulations, use boxplots to depict range and central tendency across many combinations of parameter values.
While these can be over-dispersed if you have substantial Monte Carlo Simulation Error, hopefully the variation induced by the different simulation factors will swamp that effect.</p>
<p>To get a sense of overall trends, you can aggregate across factors, averaging your performance metrics and then making line charts or scatterplots.</p>
<p>For all of these plots, if you have a lot of factors, you might also want to use small multiples (faceting) to break up the plots into manageable chunks.
Do this especially if entire sets of simulation results are on radically different scales of performance (e.g., you have a range of outcomes explored, each on a different scale).
You can further use color, shape, and line type to encode different factors.</p>
<p>To illustrate some illustration principles, we next present a series of visualizations taken from our published work, illustrating some different themes behind visualization that we believe are important.</p>
<div id="example-1-biserial-correlation-estimation" class="section level3 hasAnchor" number="14.2.1">
<h3 class="hasAnchor"><span class="header-section-number">14.2.1</span> Example 1: Biserial correlation estimation<a href="#example-1-biserial-correlation-estimation" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Our first example shows the bias of a biserial correlation estimate from an extreme groups design.
This simulation was a <span class="math inline">\(96 \times 2 \times 5 \times 5\)</span> factorial design (true correlation for a range of values, cut-off type, cut-off percentile, and sample size).
The correlation, with 96 levels, forms the <span class="math inline">\(x\)</span>-axis, giving us nice performance curves.
We use line type for the sample size, allowing us to easily see how bias collapses as sample size increases.
Finally, the facet grid gives our final factors of cut-off type and cut-off percentile.
All our factors, and nearly 5000 explored simulation scenarios, are visible in a single plot.</p>
<pre><code>## `geom_smooth()` using formula = &#39;y ~ x&#39;</code></pre>
<p><img src="Designing-Simulations-in-R_files/figure-html/unnamed-chunk-266-1.png" width="75%" style="display: block; margin: auto;" /></p>
<p>Source: Pustejovsky, J. E. (2014). Converting from d to r to z when the design uses extreme groups, dichotomization, or experimental control. Psychological Methods, 19(1), 92-112.</p>
<p>Note that in our figure, we have smoothed the lines with respect to <code>rho</code> using <code>geom_smooth()</code>.
This is a nice tool for taking some of the simulation jitter out of an analysis to show overall trends more directly.</p>
</div>
<div id="example-2-variance-estimation-and-meta-regression" class="section level3 hasAnchor" number="14.2.2">
<h3 class="hasAnchor"><span class="header-section-number">14.2.2</span> Example 2: Variance estimation and Meta-regression<a href="#example-2-variance-estimation-and-meta-regression" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>In this example, we explore Type-I error rates of small-sample corrected F-tests based on cluster-robust variance estimation in meta-regression.
The simulation aimed to compare 5 different small-sample corrections.</p>
<p>This was a complex experimental design, varying several factors:</p>
<pre><code>- sample size ($m$)
- dimension of hypothesis ($q$)
- covariates tested
- degree of model mis-specification</code></pre>
<p><img src="Designing-Simulations-in-R_files/figure-html/unnamed-chunk-267-1.png" width="75%" style="display: block; margin: auto;" /></p>
<p>Here the boxplot shows the Type-I error rates for the different small-sample corrections across the covariates tested and degree of model misspecification. We add a line at the target 0.05 rejection rate to ease comparison.
The reach of the boxes shows how some methods are more or less vulnerable to different types of misspecification. Other estimators are clearly hyper-conservitive, with very low rejection rates.</p>
<p>Source: Tipton, E., &amp; Pustejovsky, J. E. (2015). Small-sample adjustments for tests of moderators and model fit using robust variance estimation in meta-regression. <em>Journal of Educational and Behavioral Statistics, 40</em>(6), 604-634.</p>
</div>
<div id="example-heat-maps-of-coverage" class="section level3 hasAnchor" number="14.2.3">
<h3 class="hasAnchor"><span class="header-section-number">14.2.3</span> Example: Heat maps of coverage<a href="#example-heat-maps-of-coverage" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>The visualization below shows the coverage of parametric bootstrap confidence intervals for momentary time sampling data
In this simulation study the authors were comparing maximum likelihood estimators to posterior mode (penalized likelihood) estimators of prevalence.
We have a 2-dimensional parameter space of prevalence (19 levels) by incidence (10 levels).
We also have 15 levels of sample size.</p>
<p>One option here is to use a heat map, showing the combinations of prevelance and incidence as a grid for each sample size level.
We break coverage into ranges of interest, with green being “good” (near 95%) and yellow being “close” (92.5% or above).
For this to work, we need our MCSE to be small enough that our coverage is estimated precisely enough to show structure.</p>
<p><img src="Designing-Simulations-in-R_files/figure-html/swan_example_setup-1.png" width="75%" style="display: block; margin: auto;" /></p>
<p><img src="Designing-Simulations-in-R_files/figure-html/unnamed-chunk-268-1.png" width="75%" style="display: block; margin: auto;" /></p>
<p>To see this plot IRL, see Pustejovsky, J. E., &amp; Swan, D. M. (2015). Four methods for analyzing partial interval recording data, with application to single-case research. <em>Multivariate Behavioral Research, 50</em>(3), 365-380.</p>
</div>
</div>
<div id="modeling" class="section level2 hasAnchor" number="14.3">
<h2 class="hasAnchor"><span class="header-section-number">14.3</span> Modeling<a href="#modeling" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Simulations are designed experiments, often with a full factorial structure.
We can therefore leverage classic means for analyzing such full factorial experiments.
In particular, we can use regression to summarize how a performance measure varies as a function of the different experimental factors.</p>
<p>First, in the language of a full factor experiment, we might be interested in the “main effects” and the “interaction effects.”
A main effect is whether, averaging across the other factors in our experiment, a factor of interest systematically impacts performance.
When we look at a main effect, the other factors help ensure our main effect is generalizable: if we see a trend when we average over the other varying aspects, then we can state that our finding is relevant across the host of simulation contexts explored, rather than being an idioscynratic aspect of a specific scenario.</p>
<p>For example, consider the bias of the biserial correlation estimates from above.
Visually, we see that several factors appear to impact bias, but we might want to get a sense of how much.
In particular, does the population vs sample cutoff option matter, on average, for bias, across all the simulation factors considered?
We can fit a regression model to see:</p>
<div class="sourceCode" id="cb499"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb499-1"><a href="#cb499-1" tabindex="-1"></a><span class="fu">options</span>(<span class="at">scipen =</span> <span class="dv">5</span>)</span>
<span id="cb499-2"><a href="#cb499-2" tabindex="-1"></a>mod <span class="ot">=</span> <span class="fu">lm</span>( bias <span class="sc">~</span> fixed <span class="sc">+</span> rho <span class="sc">+</span> <span class="fu">I</span>(rho<span class="sc">^</span><span class="dv">2</span>) <span class="sc">+</span> p1 <span class="sc">+</span> n, <span class="at">data =</span> r_F)</span>
<span id="cb499-3"><a href="#cb499-3" tabindex="-1"></a><span class="fu">summary</span>(mod, <span class="at">digits=</span><span class="dv">2</span>)</span></code></pre></div>
<pre><code>## 
## Call:
## lm(formula = bias ~ fixed + rho + I(rho^2) + p1 + n, data = r_F)
## 
## Residuals:
##        Min         1Q     Median         3Q 
## -0.0215935 -0.0013608  0.0003823  0.0015677 
##        Max 
##  0.0081802 
## 
## Coefficients:
##                       Estimate  Std. Error
## (Intercept)         0.00218473  0.00015107
## fixedSample cutoff -0.00363520  0.00009733
## rho                -0.00942338  0.00069578
## I(rho^2)            0.00720857  0.00070868
## p1.L                0.00461700  0.00010882
## p1.Q               -0.00160546  0.00010882
## p1.C                0.00081464  0.00010882
## p1^4               -0.00011190  0.00010882
## n.L                 0.00362949  0.00010882
## n.Q                -0.00103981  0.00010882
## n.C                 0.00027941  0.00010882
## n^4                 0.00001976  0.00010882
##                    t value Pr(&gt;|t|)    
## (Intercept)         14.462  &lt; 2e-16 ***
## fixedSample cutoff -37.347  &lt; 2e-16 ***
## rho                -13.544  &lt; 2e-16 ***
## I(rho^2)            10.172  &lt; 2e-16 ***
## p1.L                42.426  &lt; 2e-16 ***
## p1.Q               -14.753  &lt; 2e-16 ***
## p1.C                 7.486 8.41e-14 ***
## p1^4                -1.028   0.3039    
## n.L                 33.352  &lt; 2e-16 ***
## n.Q                 -9.555  &lt; 2e-16 ***
## n.C                  2.568   0.0103 *  
## n^4                  0.182   0.8559    
## ---
## Signif. codes:  
## 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 0.003372 on 4788 degrees of freedom
## Multiple R-squared:  0.5107, Adjusted R-squared:  0.5096 
## F-statistic: 454.4 on 11 and 4788 DF,  p-value: &lt; 2.2e-16</code></pre>
<p>The above printout gives main effects for each factor, averaged across other factors.
Because <code>p1</code> and <code>n</code> are ordered factors, the <code>lm()</code> command automatically generates linear, quadradic, cubic and fourth order contrasts for them.
We see that, averaged across the other contexts, the sample cutoff is around 0.004 lower than population.</p>
<p>We next extend this modeling approach with two additional tools:</p>
<blockquote>
<ul>
<li>ANOVA, which can be useful for understanding major sources of variation in simulation results (e.g., identifying which factors have negligible/minor influence on the bias of an estimator).</li>
<li>Smoothing (e.g., local linear regression) over continuous factors to simplify the interpretation of complex relationships.</li>
</ul>
</blockquote>
<p>For ANOVA, we use <code>aov()</code> to fit an analysis of variance model:</p>
<div class="sourceCode" id="cb501"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb501-1"><a href="#cb501-1" tabindex="-1"></a>anova_table <span class="ot">&lt;-</span> <span class="fu">aov</span>(bias <span class="sc">~</span> rho <span class="sc">*</span> p1 <span class="sc">*</span> fixed <span class="sc">*</span> n, <span class="at">data =</span> r_F)</span>
<span id="cb501-2"><a href="#cb501-2" tabindex="-1"></a><span class="fu">summary</span>(anova_table)</span></code></pre></div>
<pre><code>##                  Df   Sum Sq  Mean Sq  F value
## rho               1 0.002444 0.002444  1673.25
## p1                4 0.023588 0.005897  4036.41
## fixed             1 0.015858 0.015858 10854.52
## n                 4 0.013760 0.003440  2354.60
## rho:p1            4 0.001722 0.000431   294.71
## rho:fixed         1 0.003440 0.003440  2354.69
## p1:fixed          4 0.001683 0.000421   287.98
## rho:n             4 0.002000 0.000500   342.31
## p1:n             16 0.019810 0.001238   847.51
## fixed:n           4 0.013359 0.003340  2285.97
## rho:p1:fixed      4 0.000473 0.000118    80.87
## rho:p1:n         16 0.001470 0.000092    62.91
## rho:fixed:n       4 0.002929 0.000732   501.23
## p1:fixed:n       16 0.001429 0.000089    61.12
## rho:p1:fixed:n   16 0.000429 0.000027    18.36
## Residuals      4700 0.006866 0.000001         
##                Pr(&gt;F)    
## rho            &lt;2e-16 ***
## p1             &lt;2e-16 ***
## fixed          &lt;2e-16 ***
## n              &lt;2e-16 ***
## rho:p1         &lt;2e-16 ***
## rho:fixed      &lt;2e-16 ***
## p1:fixed       &lt;2e-16 ***
## rho:n          &lt;2e-16 ***
## p1:n           &lt;2e-16 ***
## fixed:n        &lt;2e-16 ***
## rho:p1:fixed   &lt;2e-16 ***
## rho:p1:n       &lt;2e-16 ***
## rho:fixed:n    &lt;2e-16 ***
## p1:fixed:n     &lt;2e-16 ***
## rho:p1:fixed:n &lt;2e-16 ***
## Residuals                
## ---
## Signif. codes:  
## 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<p>The advantage here is the multiple levels of some of the factors get bundled together in our table of results.
We can summarise our anova table to see the contribution of the various factors and interactions:</p>
<div class="sourceCode" id="cb503"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb503-1"><a href="#cb503-1" tabindex="-1"></a><span class="fu">library</span>(lsr)</span>
<span id="cb503-2"><a href="#cb503-2" tabindex="-1"></a><span class="fu">etaSquared</span>(anova_table)</span></code></pre></div>
<pre><code>##                     eta.sq eta.sq.part
## rho            0.021971037  0.26254289
## p1             0.212004203  0.77453319
## fixed          0.142527898  0.69783705
## n              0.123670355  0.66710072
## rho:p1         0.015479114  0.20052330
## rho:fixed      0.030918819  0.33377652
## p1:fixed       0.015125570  0.19684488
## rho:n          0.017979185  0.22560369
## p1:n           0.178055588  0.74260975
## fixed:n        0.120065971  0.66049991
## rho:p1:fixed   0.004247472  0.06439275
## rho:p1:n       0.013216569  0.17638308
## rho:fixed:n    0.026326074  0.29902214
## p1:fixed:n     0.012839790  0.17222072
## rho:p1:fixed:n 0.003857877  0.05883389</code></pre>
<p>Here we see which factors are explaining the most variation. E.g., <code>p1</code> is explaining 21% of the variation in bias across simulations.
The contribution of the three way interactions is fairly minimal, by comparison, and could be dropped to simplify our model.</p>
<!--chapter:end:075-presentation-of-results.Rmd-->
</div>
</div>
<div id="part-computational-considerations" class="section level1 unnumbered hasAnchor">
<h1 class="unnumbered hasAnchor">(PART) Computational Considerations<a href="#part-computational-considerations" class="anchor-section" aria-label="Anchor link to header"></a></h1>
</div>
<div id="optimize-code" class="section level1 hasAnchor" number="15">
<h1 class="hasAnchor"><span class="header-section-number">15</span> Optimizing code (and why you often shouldn’t)<a href="#optimize-code" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p>Optimizing code is when you spend a bit more human effort to write code that will run faster on your computer.
In some cases, this can be a critical boost to running a simulation, where you inherently will be doing things a lot of times.
Cutting runtime down will always be tempting, as it allows you to run more replicates and get more precisely estimated performance measures for your simulation.</p>
<p>That being said, beyond a few obvious coding tricks we will discuss, one should optimize code only after you discover you need to.
Optimizing as you go usually means you will spend a lot of time wrestling with code far more complicated than it needs to be.
For example, often it is the estimation method that will take a lot of computational time, so having very fast data generation code won’t help overall simulation runtimes much, as you are tweaking something that is only a small part of the overall pie, in terms of time.
Keep things simple; in general your time is more important than the computer’s time.</p>
<p>In the next sections we will look at a few optimization efforts applied to the ANOVA example in the prior chapters.</p>
<div id="hand-building-functions" class="section level2 hasAnchor" number="15.1">
<h2 class="hasAnchor"><span class="header-section-number">15.1</span> Hand-building functions<a href="#hand-building-functions" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>In the Welch example above, we used the system-implemented ANOVA.
An alternative approach would be to “hand roll” the ANOVA F statistic and test directly.
Doing so by hand can set you up to implement modified versions of these tests later on.
Also, although hand-building a method does take more work to program, it can result in a faster piece of code (this actually is the case here) which in turn can make the overall simulation faster.</p>
<p>Following the formulas on p. 129 of Brown and Forsythe (1974) we have (using data as generated in Chapter @ref(data-generating-processes):</p>
<div class="sourceCode" id="cb505"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb505-1"><a href="#cb505-1" tabindex="-1"></a>ANOVA_F <span class="ot">&lt;-</span> <span class="cf">function</span>(sim_data) {</span>
<span id="cb505-2"><a href="#cb505-2" tabindex="-1"></a></span>
<span id="cb505-3"><a href="#cb505-3" tabindex="-1"></a>  x_bar <span class="ot">&lt;-</span> <span class="fu">with</span>(sim_data, <span class="fu">tapply</span>(x, group, mean))</span>
<span id="cb505-4"><a href="#cb505-4" tabindex="-1"></a>  s_sq <span class="ot">&lt;-</span> <span class="fu">with</span>(sim_data, <span class="fu">tapply</span>(x, group, var))</span>
<span id="cb505-5"><a href="#cb505-5" tabindex="-1"></a>  n <span class="ot">&lt;-</span> <span class="fu">table</span>(sim_data<span class="sc">$</span>group)</span>
<span id="cb505-6"><a href="#cb505-6" tabindex="-1"></a>  g <span class="ot">&lt;-</span> <span class="fu">length</span>(x_bar)</span>
<span id="cb505-7"><a href="#cb505-7" tabindex="-1"></a></span>
<span id="cb505-8"><a href="#cb505-8" tabindex="-1"></a>  df1 <span class="ot">&lt;-</span> g <span class="sc">-</span> <span class="dv">1</span></span>
<span id="cb505-9"><a href="#cb505-9" tabindex="-1"></a>  df2 <span class="ot">&lt;-</span> <span class="fu">sum</span>(n) <span class="sc">-</span> g</span>
<span id="cb505-10"><a href="#cb505-10" tabindex="-1"></a></span>
<span id="cb505-11"><a href="#cb505-11" tabindex="-1"></a>  msbtw <span class="ot">&lt;-</span> <span class="fu">sum</span>(n <span class="sc">*</span> (x_bar <span class="sc">-</span> <span class="fu">mean</span>(sim_data<span class="sc">$</span>x))<span class="sc">^</span><span class="dv">2</span>) <span class="sc">/</span> df1</span>
<span id="cb505-12"><a href="#cb505-12" tabindex="-1"></a>  mswn <span class="ot">&lt;-</span> <span class="fu">sum</span>((n <span class="sc">-</span> <span class="dv">1</span>) <span class="sc">*</span> s_sq) <span class="sc">/</span> df2</span>
<span id="cb505-13"><a href="#cb505-13" tabindex="-1"></a>  fstat <span class="ot">&lt;-</span> msbtw <span class="sc">/</span> mswn</span>
<span id="cb505-14"><a href="#cb505-14" tabindex="-1"></a>  pval <span class="ot">&lt;-</span> <span class="fu">pf</span>(fstat, df1, df2, <span class="at">lower.tail =</span> <span class="cn">FALSE</span>)</span>
<span id="cb505-15"><a href="#cb505-15" tabindex="-1"></a></span>
<span id="cb505-16"><a href="#cb505-16" tabindex="-1"></a>  <span class="fu">return</span>(pval)</span>
<span id="cb505-17"><a href="#cb505-17" tabindex="-1"></a>}</span>
<span id="cb505-18"><a href="#cb505-18" tabindex="-1"></a></span>
<span id="cb505-19"><a href="#cb505-19" tabindex="-1"></a><span class="fu">ANOVA_F</span>(sim_data)</span></code></pre></div>
<pre><code>## [1] 0.004037895</code></pre>
<p>To see the difference between our version and R’s version, we can use an R package called <code>microbenchmark</code> to test how long the computations take for each version of the function.
The <code>microbenchmark</code> function runs each expression 100 times (by default) and tracks how long the computations take. It then summarizes the distribution of timings:</p>
<div class="sourceCode" id="cb507"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb507-1"><a href="#cb507-1" tabindex="-1"></a><span class="fu">library</span>(microbenchmark)</span>
<span id="cb507-2"><a href="#cb507-2" tabindex="-1"></a>timings <span class="ot">&lt;-</span> <span class="fu">microbenchmark</span>(<span class="at">Rfunction =</span> <span class="fu">ANOVA_F_aov</span>(sim_data),</span>
<span id="cb507-3"><a href="#cb507-3" tabindex="-1"></a>                          <span class="at">direct    =</span> <span class="fu">ANOVA_F</span>(sim_data))</span>
<span id="cb507-4"><a href="#cb507-4" tabindex="-1"></a>timings</span></code></pre></div>
<pre><code>## Unit: microseconds
##       expr   min     lq    mean median     uq
##  Rfunction 391.1 421.90 488.948 443.55 478.20
##     direct 146.3 168.35 211.901 187.80 203.15
##     max neval
##  2364.4   100
##   639.3   100</code></pre>
<p>The direct function is 2.3 times faster than the built-in R function.</p>
<p>This result is not unusual.
Built-in R functions usually include lots of checks and error-handling, which take time to compute. These checks are crucial for messy, real-world data analysis but unnecessary with our pristine, simulated data.
Here we can skip them by doing the calculations directly.
In general, however, this is a trade-off: writing something yourself gives you a lot of chance to do something wrong, throwing off all your simulations. It might be faster, but you may pay dearly for it in terms of extra hours coding and debugging.
Optimize only if you need to!</p>
</div>
<div id="sec_comp_efficiency" class="section level2 hasAnchor" number="15.2">
<h2 class="hasAnchor"><span class="header-section-number">15.2</span> Computational efficiency versus simplicity<a href="#sec_comp_efficiency" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>An alternative approach to having a function that, for each call, generates a single set of data, would be to write a function that generates <em>multiple</em> sets of simulated data all at once.</p>
<p>For example, for our ANOVA example we could specify that we want <code>R</code> replications of the study and have the function spit out a matrix with <code>R</code> columns, one for each simulated dataset:</p>
<div class="sourceCode" id="cb509"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb509-1"><a href="#cb509-1" tabindex="-1"></a>generate_data_matrix <span class="ot">&lt;-</span> <span class="cf">function</span>(mu, sigma_sq, sample_size, R) {</span>
<span id="cb509-2"><a href="#cb509-2" tabindex="-1"></a></span>
<span id="cb509-3"><a href="#cb509-3" tabindex="-1"></a>  N <span class="ot">&lt;-</span> <span class="fu">sum</span>(sample_size) </span>
<span id="cb509-4"><a href="#cb509-4" tabindex="-1"></a>  g <span class="ot">&lt;-</span> <span class="fu">length</span>(sample_size) </span>
<span id="cb509-5"><a href="#cb509-5" tabindex="-1"></a>  </span>
<span id="cb509-6"><a href="#cb509-6" tabindex="-1"></a>  group <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span>g, <span class="at">times =</span> sample_size) </span>
<span id="cb509-7"><a href="#cb509-7" tabindex="-1"></a>  mu_long <span class="ot">&lt;-</span> <span class="fu">rep</span>(mu, <span class="at">times =</span> sample_size)</span>
<span id="cb509-8"><a href="#cb509-8" tabindex="-1"></a>  sigma_long <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="fu">sqrt</span>(sigma_sq), <span class="at">times =</span> sample_size) </span>
<span id="cb509-9"><a href="#cb509-9" tabindex="-1"></a></span>
<span id="cb509-10"><a href="#cb509-10" tabindex="-1"></a>  x_mat <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">rnorm</span>(N <span class="sc">*</span> R, <span class="at">mean =</span> mu_long, <span class="at">sd =</span> sigma_long),</span>
<span id="cb509-11"><a href="#cb509-11" tabindex="-1"></a>                  <span class="at">nrow =</span> N, <span class="at">ncol =</span> R)</span>
<span id="cb509-12"><a href="#cb509-12" tabindex="-1"></a>  sim_data <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">group =</span> group, <span class="at">x_mat =</span> x_mat)</span>
<span id="cb509-13"><a href="#cb509-13" tabindex="-1"></a>    </span>
<span id="cb509-14"><a href="#cb509-14" tabindex="-1"></a>  <span class="fu">return</span>(sim_data)</span>
<span id="cb509-15"><a href="#cb509-15" tabindex="-1"></a>}</span>
<span id="cb509-16"><a href="#cb509-16" tabindex="-1"></a></span>
<span id="cb509-17"><a href="#cb509-17" tabindex="-1"></a><span class="fu">generate_data_matrix</span>(<span class="at">mu =</span> mu, <span class="at">sigma_sq =</span> sigma_sq,</span>
<span id="cb509-18"><a href="#cb509-18" tabindex="-1"></a>                     <span class="at">sample_size =</span> sample_size, <span class="at">R =</span> <span class="dv">4</span>)</span></code></pre></div>
<pre><code>## $group
##  [1] 1 1 1 2 2 2 2 2 2 3 3 4 4 4 4
## 
## $x_mat
##              [,1]       [,2]      [,3]       [,4]
##  [1,]  2.96039553  1.0817214 0.9306982  2.7125115
##  [2,]  0.02587199 -0.7682219 1.5680376  2.1269745
##  [3,]  2.88114106  0.2978131 2.3355904  0.1106900
##  [4,]  1.01902548  2.6659543 1.3387106  2.4997092
##  [5,] -1.63837246  1.0848865 5.1329608 -0.1282844
##  [6,]  3.99343045  0.2924431 2.2004092  0.1174160
##  [7,]  2.39267741  0.9759697 2.1228954  0.9974723
##  [8,]  3.41714220 -0.5215577 1.2727010  2.3444693
##  [9,]  1.65696125  2.7633675 4.4069232  1.6192802
## [10,] 10.35746552  6.2851555 6.7576291  0.7851318
## [11,]  3.31024400  7.1040594 2.9113329  6.1024155
## [12,]  6.50803008  5.4034067 6.7324589  8.2590013
## [13,]  5.34914591  6.8394295 5.7892140  7.4751236
## [14,]  8.31037815  5.8169003 5.6803400  4.9334919
## [15,]  4.89056404  5.6067566 5.7440179  5.7273543</code></pre>
<p>This approach is a bit more computationally efficient because the setup calculations (getting <code>N</code>, <code>g</code>, <code>group</code>, <code>mu_full</code>, and <code>sigma_full</code>) only have to be done once instead of once per replication. It also makes clever use of vector recycling in the call to <code>rnorm()</code>. However, the structure of the resulting data is more complicated, which will make it more difficult to do the later estimation steps.
Furthermore, if the number of replicates <code>R</code> is large and each replication produces a large dataset, this “all-at-once” approach will entail generating and holding very large amounts of data in memory, which can create other performance issues.
On balance, we recommend the simpler approach of writing a function that generates a single simulated dataset per call (unless and until you have a principled reason to do otherwise).</p>
</div>
<div id="reusing-code-to-speed-up-computation" class="section level2 hasAnchor" number="15.3">
<h2 class="hasAnchor"><span class="header-section-number">15.3</span> Reusing code to speed up computation<a href="#reusing-code-to-speed-up-computation" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Computational and programming efficiency should usually be a secondary consideration when you are starting to design a simulation study.
It is better to produce accurate code, even if it is a bit slow, than to write code that is speedy but hard to follow (or even worse, that produces incorrect results).
All that said, there is some glaring redundancy in the two functions used for the ANOVA simulation.
Both <code>ANOVA_F</code> and <code>Welch_F</code> start by taking the simulated data and calculating summary statistics for each group, using the following code:</p>
<div class="sourceCode" id="cb511"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb511-1"><a href="#cb511-1" tabindex="-1"></a>x_bar <span class="ot">&lt;-</span> <span class="fu">with</span>(sim_data, <span class="fu">tapply</span>(x, group, mean))</span>
<span id="cb511-2"><a href="#cb511-2" tabindex="-1"></a>s_sq <span class="ot">&lt;-</span> <span class="fu">with</span>(sim_data, <span class="fu">tapply</span>(x, group, var))</span>
<span id="cb511-3"><a href="#cb511-3" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="fu">table</span>(sim_data<span class="sc">$</span>group)</span>
<span id="cb511-4"><a href="#cb511-4" tabindex="-1"></a>g <span class="ot">&lt;-</span> <span class="fu">length</span>(x_bar)</span></code></pre></div>
<p>In the interest of not repeating ourselves, it would better to pull this code out as a separate function and then re-write the <code>ANOVA_F</code> and <code>Welch_F</code> functions to take the summary statistics as input. Here is a function that takes simulated data and returns a list of summary statistics:</p>
<div class="sourceCode" id="cb512"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb512-1"><a href="#cb512-1" tabindex="-1"></a>summarize_data <span class="ot">&lt;-</span> <span class="cf">function</span>(sim_data) {</span>
<span id="cb512-2"><a href="#cb512-2" tabindex="-1"></a>  </span>
<span id="cb512-3"><a href="#cb512-3" tabindex="-1"></a>  res <span class="ot">&lt;-</span> sim_data <span class="sc">%&gt;%</span> </span>
<span id="cb512-4"><a href="#cb512-4" tabindex="-1"></a>    <span class="fu">group_by</span>( group ) <span class="sc">%&gt;%</span></span>
<span id="cb512-5"><a href="#cb512-5" tabindex="-1"></a>    <span class="fu">summarise</span>( <span class="at">x_bar =</span> <span class="fu">mean</span>( x ),</span>
<span id="cb512-6"><a href="#cb512-6" tabindex="-1"></a>               <span class="at">s_sq =</span> <span class="fu">var</span>( x ),</span>
<span id="cb512-7"><a href="#cb512-7" tabindex="-1"></a>               <span class="at">n =</span> <span class="fu">n</span>() )</span>
<span id="cb512-8"><a href="#cb512-8" tabindex="-1"></a>  res</span>
<span id="cb512-9"><a href="#cb512-9" tabindex="-1"></a>}</span></code></pre></div>
<p>We just packaged the code from above, and puts our results in a nice table (and thus pivoted to using tidyverse to calculate these things):</p>
<div class="sourceCode" id="cb513"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb513-1"><a href="#cb513-1" tabindex="-1"></a>sim_data <span class="ot">=</span> <span class="fu">generate_data</span>(<span class="at">mu=</span>mu, <span class="at">sigma_sq=</span>sigma_sq, <span class="at">sample_size=</span>sample_size)</span>
<span id="cb513-2"><a href="#cb513-2" tabindex="-1"></a><span class="fu">summarize_data</span>(sim_data)</span></code></pre></div>
<pre><code>## # A tibble: 4 × 4
##   group x_bar     s_sq     n
##   &lt;int&gt; &lt;dbl&gt;    &lt;dbl&gt; &lt;int&gt;
## 1     1 0.898 12.3         3
## 2     2 1.79   2.28        6
## 3     3 4.48   0.00283     2
## 4     4 5.24   1.19        4</code></pre>
<p>Now we can re-write both <span class="math inline">\(F\)</span>-test functions to use the output of this function:</p>
<div class="sourceCode" id="cb515"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb515-1"><a href="#cb515-1" tabindex="-1"></a>ANOVA_F_agg <span class="ot">&lt;-</span> <span class="cf">function</span>(x_bar, s_sq, n) {</span>
<span id="cb515-2"><a href="#cb515-2" tabindex="-1"></a>  g <span class="ot">=</span> <span class="fu">length</span>(x_bar)</span>
<span id="cb515-3"><a href="#cb515-3" tabindex="-1"></a>  df1 <span class="ot">&lt;-</span> g <span class="sc">-</span> <span class="dv">1</span></span>
<span id="cb515-4"><a href="#cb515-4" tabindex="-1"></a>  df2 <span class="ot">&lt;-</span> <span class="fu">sum</span>(n) <span class="sc">-</span> g</span>
<span id="cb515-5"><a href="#cb515-5" tabindex="-1"></a>  </span>
<span id="cb515-6"><a href="#cb515-6" tabindex="-1"></a>  msbtw <span class="ot">&lt;-</span> <span class="fu">sum</span>(n <span class="sc">*</span> (x_bar <span class="sc">-</span> <span class="fu">weighted.mean</span>(x_bar, <span class="at">w =</span> n))<span class="sc">^</span><span class="dv">2</span>) <span class="sc">/</span> df1</span>
<span id="cb515-7"><a href="#cb515-7" tabindex="-1"></a>  mswn <span class="ot">&lt;-</span> <span class="fu">sum</span>((n <span class="sc">-</span> <span class="dv">1</span>) <span class="sc">*</span> s_sq) <span class="sc">/</span> df2</span>
<span id="cb515-8"><a href="#cb515-8" tabindex="-1"></a>  fstat <span class="ot">&lt;-</span> msbtw <span class="sc">/</span> mswn</span>
<span id="cb515-9"><a href="#cb515-9" tabindex="-1"></a>  pval <span class="ot">&lt;-</span> <span class="fu">pf</span>(fstat, df1, df2, <span class="at">lower.tail =</span> <span class="cn">FALSE</span>)</span>
<span id="cb515-10"><a href="#cb515-10" tabindex="-1"></a> </span>
<span id="cb515-11"><a href="#cb515-11" tabindex="-1"></a>  <span class="fu">return</span>(pval)</span>
<span id="cb515-12"><a href="#cb515-12" tabindex="-1"></a>}</span>
<span id="cb515-13"><a href="#cb515-13" tabindex="-1"></a></span>
<span id="cb515-14"><a href="#cb515-14" tabindex="-1"></a>summary_stats <span class="ot">&lt;-</span> <span class="fu">summarize_data</span>(sim_data)</span>
<span id="cb515-15"><a href="#cb515-15" tabindex="-1"></a><span class="fu">with</span>(summary_stats, <span class="fu">ANOVA_F_agg</span>(<span class="at">x_bar =</span> x_bar, <span class="at">s_sq =</span> s_sq, <span class="at">n =</span> n))</span></code></pre></div>
<pre><code>## [1] 0.03123286</code></pre>
<div class="sourceCode" id="cb517"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb517-1"><a href="#cb517-1" tabindex="-1"></a>Welch_F_agg <span class="ot">&lt;-</span> <span class="cf">function</span>(x_bar, s_sq, n) {</span>
<span id="cb517-2"><a href="#cb517-2" tabindex="-1"></a>  g <span class="ot">=</span> <span class="fu">length</span>(x_bar)</span>
<span id="cb517-3"><a href="#cb517-3" tabindex="-1"></a>  w <span class="ot">&lt;-</span> n <span class="sc">/</span> s_sq</span>
<span id="cb517-4"><a href="#cb517-4" tabindex="-1"></a>  u <span class="ot">&lt;-</span> <span class="fu">sum</span>(w)</span>
<span id="cb517-5"><a href="#cb517-5" tabindex="-1"></a>  x_tilde <span class="ot">&lt;-</span> <span class="fu">sum</span>(w <span class="sc">*</span> x_bar) <span class="sc">/</span> u</span>
<span id="cb517-6"><a href="#cb517-6" tabindex="-1"></a>  msbtw <span class="ot">&lt;-</span> <span class="fu">sum</span>(w <span class="sc">*</span> (x_bar <span class="sc">-</span> x_tilde)<span class="sc">^</span><span class="dv">2</span>) <span class="sc">/</span> (g <span class="sc">-</span> <span class="dv">1</span>)</span>
<span id="cb517-7"><a href="#cb517-7" tabindex="-1"></a></span>
<span id="cb517-8"><a href="#cb517-8" tabindex="-1"></a>  G <span class="ot">&lt;-</span> <span class="fu">sum</span>((<span class="dv">1</span> <span class="sc">-</span> w <span class="sc">/</span> u)<span class="sc">^</span><span class="dv">2</span> <span class="sc">/</span> (n <span class="sc">-</span> <span class="dv">1</span>))</span>
<span id="cb517-9"><a href="#cb517-9" tabindex="-1"></a>  denom <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">+</span>  G <span class="sc">*</span> <span class="dv">2</span> <span class="sc">*</span> (g <span class="sc">-</span> <span class="dv">2</span>) <span class="sc">/</span> (g<span class="sc">^</span><span class="dv">2</span> <span class="sc">-</span> <span class="dv">1</span>)</span>
<span id="cb517-10"><a href="#cb517-10" tabindex="-1"></a>  W <span class="ot">&lt;-</span> msbtw <span class="sc">/</span> denom</span>
<span id="cb517-11"><a href="#cb517-11" tabindex="-1"></a>  f <span class="ot">&lt;-</span> (g<span class="sc">^</span><span class="dv">2</span> <span class="sc">-</span> <span class="dv">1</span>) <span class="sc">/</span> (<span class="dv">3</span> <span class="sc">*</span> G)</span>
<span id="cb517-12"><a href="#cb517-12" tabindex="-1"></a></span>
<span id="cb517-13"><a href="#cb517-13" tabindex="-1"></a>  pval <span class="ot">&lt;-</span> <span class="fu">pf</span>(W, <span class="at">df1 =</span> g <span class="sc">-</span> <span class="dv">1</span>, <span class="at">df2 =</span> f, <span class="at">lower.tail =</span> <span class="cn">FALSE</span>)</span>
<span id="cb517-14"><a href="#cb517-14" tabindex="-1"></a></span>
<span id="cb517-15"><a href="#cb517-15" tabindex="-1"></a>  <span class="fu">return</span>(pval)</span>
<span id="cb517-16"><a href="#cb517-16" tabindex="-1"></a>}</span>
<span id="cb517-17"><a href="#cb517-17" tabindex="-1"></a></span>
<span id="cb517-18"><a href="#cb517-18" tabindex="-1"></a><span class="fu">with</span>(summary_stats, <span class="fu">ANOVA_F_agg</span>(<span class="at">x_bar =</span> x_bar, <span class="at">s_sq =</span> s_sq, <span class="at">n =</span> n))</span></code></pre></div>
<pre><code>## [1] 0.03123286</code></pre>
<p>The results are the same as before.</p>
<p>We should always test any optimized code against something we know is stable, since optimization is an easy way to get bad bugs.
Here we check against R’s implementation:</p>
<div class="sourceCode" id="cb519"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb519-1"><a href="#cb519-1" tabindex="-1"></a>summary_stats <span class="ot">&lt;-</span> <span class="fu">summarize_data</span>(sim_data)</span>
<span id="cb519-2"><a href="#cb519-2" tabindex="-1"></a>F_results <span class="ot">&lt;-</span> <span class="fu">with</span>(summary_stats,</span>
<span id="cb519-3"><a href="#cb519-3" tabindex="-1"></a>                  <span class="fu">ANOVA_F_agg</span>(<span class="at">x_bar =</span> x_bar, <span class="at">s_sq =</span> s_sq, <span class="at">n =</span> n))</span>
<span id="cb519-4"><a href="#cb519-4" tabindex="-1"></a>aov_results <span class="ot">&lt;-</span> <span class="fu">oneway.test</span>(x <span class="sc">~</span> <span class="fu">factor</span>(group), <span class="at">data =</span> sim_data, </span>
<span id="cb519-5"><a href="#cb519-5" tabindex="-1"></a>                           <span class="at">var.equal =</span> <span class="cn">TRUE</span>)</span>
<span id="cb519-6"><a href="#cb519-6" tabindex="-1"></a><span class="fu">all.equal</span>(aov_results<span class="sc">$</span>p.value, F_results)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode" id="cb521"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb521-1"><a href="#cb521-1" tabindex="-1"></a>W_results <span class="ot">&lt;-</span> <span class="fu">with</span>(summary_stats,</span>
<span id="cb521-2"><a href="#cb521-2" tabindex="-1"></a>                  <span class="fu">Welch_F_agg</span>( <span class="at">x_bar =</span> x_bar,</span>
<span id="cb521-3"><a href="#cb521-3" tabindex="-1"></a>                               <span class="at">s_sq =</span> s_sq, <span class="at">n =</span> n))</span>
<span id="cb521-4"><a href="#cb521-4" tabindex="-1"></a>aov_results <span class="ot">&lt;-</span> <span class="fu">oneway.test</span>(x <span class="sc">~</span> <span class="fu">factor</span>(group),</span>
<span id="cb521-5"><a href="#cb521-5" tabindex="-1"></a>                           <span class="at">data =</span> sim_data, </span>
<span id="cb521-6"><a href="#cb521-6" tabindex="-1"></a>                           <span class="at">var.equal =</span> <span class="cn">FALSE</span>)</span>
<span id="cb521-7"><a href="#cb521-7" tabindex="-1"></a><span class="fu">all.equal</span>(aov_results<span class="sc">$</span>p.value, W_results)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>Here we are able to check against a known baseline.
Checking estimation functions can be a bit more difficult for procedures that are not already implemented in R. For example, the two other procedures examined by Brown and Forsythe, the James’ test and Brown and Forsythe’s <span class="math inline">\(F*\)</span> test, are not available in base R.
They are, however, available in the user-contributed package <code>onewaytests</code>, found by searching for “Brown-Forsythe” at <a href="http://rseek.org/" class="uri">http://rseek.org/</a>. We could benchmark our calculations against this package, but of course there is some risk that the package might not be correct. Another route is to verify your results on numerical examples reported in authoritative papers, on the assumption that there’s less risk of an error there. In the original paper that proposed the test, Welch (1951) provides a worked numerical example of the procedure. He reports the following summary statistics:</p>
<div class="sourceCode" id="cb523"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb523-1"><a href="#cb523-1" tabindex="-1"></a>g <span class="ot">&lt;-</span> <span class="dv">3</span></span>
<span id="cb523-2"><a href="#cb523-2" tabindex="-1"></a>x_bar <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">27.8</span>, <span class="fl">24.1</span>, <span class="fl">22.2</span>)</span>
<span id="cb523-3"><a href="#cb523-3" tabindex="-1"></a>s_sq <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">60.1</span>, <span class="fl">6.3</span>, <span class="fl">15.4</span>)</span>
<span id="cb523-4"><a href="#cb523-4" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">20</span>, <span class="dv">20</span>, <span class="dv">10</span>)</span></code></pre></div>
<p>He also reports <span class="math inline">\(W = 3.35\)</span> and <span class="math inline">\(f = 22.6\)</span>. Replicating the calculations with our <code>Welch_F_agg</code> function:</p>
<div class="sourceCode" id="cb524"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb524-1"><a href="#cb524-1" tabindex="-1"></a><span class="fu">Welch_F_agg</span>(<span class="at">x_bar =</span> x_bar, <span class="at">s_sq =</span> s_sq, <span class="at">n =</span> n)</span></code></pre></div>
<pre><code>## [1] 0.05479049</code></pre>
<p>We get slightly different results! But we know that our function is correct—or at least consistent with <code>oneway.test</code>—so what’s going on? It turns out that there was an error in some of Welch’s intermediate calculations, which can only be spotted because he reported all of his work in the paper.</p>
<p>We then put all these pieces in our revised <code>one_run()</code> method as so:</p>
<div class="sourceCode" id="cb526"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb526-1"><a href="#cb526-1" tabindex="-1"></a>one_run_fast <span class="ot">&lt;-</span> <span class="cf">function</span>( mu, sigma_sq, sample_size ) {</span>
<span id="cb526-2"><a href="#cb526-2" tabindex="-1"></a>  sim_data <span class="ot">&lt;-</span> <span class="fu">generate_data</span>(<span class="at">mu =</span> mu, <span class="at">sigma_sq =</span> sigma_sq,</span>
<span id="cb526-3"><a href="#cb526-3" tabindex="-1"></a>                            <span class="at">sample_size =</span> sample_size)</span>
<span id="cb526-4"><a href="#cb526-4" tabindex="-1"></a>  summary_stats <span class="ot">&lt;-</span> <span class="fu">summarize_data</span>(sim_data)</span>
<span id="cb526-5"><a href="#cb526-5" tabindex="-1"></a>  anova_p <span class="ot">&lt;-</span> <span class="fu">with</span>(summary_stats, </span>
<span id="cb526-6"><a href="#cb526-6" tabindex="-1"></a>                  <span class="fu">ANOVA_F_agg</span>(<span class="at">x_bar =</span> x_bar,<span class="at">s_sq =</span> s_sq, <span class="at">n =</span> n))</span>
<span id="cb526-7"><a href="#cb526-7" tabindex="-1"></a>  Welch_p <span class="ot">&lt;-</span> <span class="fu">with</span>(summary_stats, </span>
<span id="cb526-8"><a href="#cb526-8" tabindex="-1"></a>                  <span class="fu">Welch_F_agg</span>(<span class="at">x_bar =</span> x_bar, <span class="at">s_sq =</span> s_sq, <span class="at">n =</span> n))</span>
<span id="cb526-9"><a href="#cb526-9" tabindex="-1"></a>  <span class="fu">tibble</span>(<span class="at">ANOVA =</span> anova_p, <span class="at">Welch =</span> Welch_p)</span>
<span id="cb526-10"><a href="#cb526-10" tabindex="-1"></a>}</span>
<span id="cb526-11"><a href="#cb526-11" tabindex="-1"></a></span>
<span id="cb526-12"><a href="#cb526-12" tabindex="-1"></a><span class="fu">one_run_fast</span>( <span class="at">mu =</span> mu, <span class="at">sigma_sq =</span> sigma_sq,</span>
<span id="cb526-13"><a href="#cb526-13" tabindex="-1"></a>              <span class="at">sample_size =</span> sample_size )</span></code></pre></div>
<pre><code>## # A tibble: 1 × 2
##     ANOVA  Welch
##     &lt;dbl&gt;  &lt;dbl&gt;
## 1 0.00955 0.0221</code></pre>
<p>The reason this is important is we are now doing our group aggregation only once, rather than once per method. We can use our microbenchmark to see our speedup:</p>
<div class="sourceCode" id="cb528"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb528-1"><a href="#cb528-1" tabindex="-1"></a><span class="fu">library</span>(microbenchmark)</span>
<span id="cb528-2"><a href="#cb528-2" tabindex="-1"></a>timings <span class="ot">&lt;-</span> <span class="fu">microbenchmark</span>(<span class="at">noagg =</span> <span class="fu">one_run</span>(<span class="at">mu =</span> mu, <span class="at">sigma_sq =</span> sigma_sq, </span>
<span id="cb528-3"><a href="#cb528-3" tabindex="-1"></a>                                          <span class="at">sample_size =</span> sample_size),</span>
<span id="cb528-4"><a href="#cb528-4" tabindex="-1"></a>                          <span class="at">agg =</span> <span class="fu">one_run_fast</span>(<span class="at">mu =</span> mu, <span class="at">sigma_sq =</span> sigma_sq, </span>
<span id="cb528-5"><a href="#cb528-5" tabindex="-1"></a>                                             <span class="at">sample_size =</span> sample_size) )</span>
<span id="cb528-6"><a href="#cb528-6" tabindex="-1"></a>timings</span></code></pre></div>
<pre><code>## Unit: milliseconds
##   expr    min      lq     mean  median      uq
##  noagg 1.1770 1.25895 1.742579 1.30565 1.41235
##    agg 2.7591 3.05700 3.381898 3.23665 3.55755
##      max neval
##  21.6725   100
##   7.0232   100</code></pre>
<p>And our relative speedup is:</p>
<div class="sourceCode" id="cb530"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb530-1"><a href="#cb530-1" tabindex="-1"></a><span class="fu">with</span>(<span class="fu">summary</span>(timings), <span class="fu">round</span>(mean[<span class="dv">1</span>] <span class="sc">/</span> mean[<span class="dv">2</span>], <span class="dv">1</span>))</span></code></pre></div>
<pre><code>## [1] 0.5</code></pre>
<p>To recap, there are two advantages of this kind of coding:</p>
<ol style="list-style-type: decimal">
<li><p>Code reuse is generally good because when you have the same code in multiple places it can make it harder to read and understand your code. If you see two blocks of code you might worry they are only mostly similar, not exactly similar, and waste time trying to differentiate. If you have a single, well-named function, you immediately know what a block of code is doing.</p></li>
<li><p>Saving the results of calculations can speed up your computation since you are saving your partial work. This can be useful to reduce calculations that are particularly time intensive.</p></li>
</ol>
<!--chapter:end:090-optimization.Rmd-->
</div>
</div>
<div id="error-trapping-and-other-headaches" class="section level1 hasAnchor" number="16">
<h1 class="hasAnchor"><span class="header-section-number">16</span> Error trapping and other headaches<a href="#error-trapping-and-other-headaches" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<div id="what-to-do-with-warnings-in-simulations" class="section level3 hasAnchor" number="16.0.1">
<h3 class="hasAnchor"><span class="header-section-number">16.0.1</span> What to do with warnings in simulations<a href="#what-to-do-with-warnings-in-simulations" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Sometimes our analytic strategy might give some sort of warning (or fail altogether).
For example, from the cluster randomized experiment case study we have:</p>
<div class="sourceCode" id="cb532"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb532-1"><a href="#cb532-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">101012</span>)  <span class="co"># (I picked this to show a warning.)</span></span>
<span id="cb532-2"><a href="#cb532-2" tabindex="-1"></a>dat <span class="ot">&lt;-</span> <span class="fu">gen_cluster_RCT</span>( <span class="at">J =</span> <span class="dv">50</span>, <span class="at">n_bar =</span> <span class="dv">100</span>, <span class="at">sigma2_u =</span> <span class="dv">0</span> )</span>
<span id="cb532-3"><a href="#cb532-3" tabindex="-1"></a>mod <span class="ot">&lt;-</span> <span class="fu">lmer</span>( Yobs <span class="sc">~</span> <span class="dv">1</span> <span class="sc">+</span> Z <span class="sc">+</span> (<span class="dv">1</span><span class="sc">|</span>sid), <span class="at">data=</span>dat )</span></code></pre></div>
<pre><code>## boundary (singular) fit: see help(&#39;isSingular&#39;)</code></pre>
<p>We have to make a deliberate decision as to what to do about this:</p>
<ul>
<li>Keep these “weird” trials?</li>
<li>Drop them?</li>
</ul>
<p>If you decide to drop them, you should drop the entire simulation iteration including the other estimators, even if they worked fine!
If there is something particularly unusual about the dataset, then dropping for one estimator, and keeping for the others that maybe didn’t give a warning, but did struggle to estimate the estimand, would be unfair: in the final performance measures the estimators that did not give a warning could be being held to a higher standard, making the comparisons between estimators biased.</p>
<p>If your estimators generate warnings, you should calculate the rate of errors or warning messages as a performance measure.
Especially if you drop some trials, it is important to see how often things are acting pecularly.</p>
<p>The main tool for doing this is the <code>quietly()</code> function:</p>
<div class="sourceCode" id="cb534"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb534-1"><a href="#cb534-1" tabindex="-1"></a>quiet_lmer <span class="ot">=</span> <span class="fu">quietly</span>( lmer )</span>
<span id="cb534-2"><a href="#cb534-2" tabindex="-1"></a>qmod <span class="ot">&lt;-</span> <span class="fu">quiet_lmer</span>( Yobs <span class="sc">~</span> <span class="dv">1</span> <span class="sc">+</span> Z <span class="sc">+</span> (<span class="dv">1</span><span class="sc">|</span>sid), <span class="at">data=</span>dat )</span>
<span id="cb534-3"><a href="#cb534-3" tabindex="-1"></a>qmod</span></code></pre></div>
<pre><code>## $result
## Linear mixed model fit by REML [&#39;lmerModLmerTest&#39;]
## Formula: ..1
##    Data: ..2
## REML criterion at convergence: 14026.44
## Random effects:
##  Groups   Name        Std.Dev.
##  sid      (Intercept) 0.0000  
##  Residual             0.9828  
## Number of obs: 5000, groups:  sid, 50
## Fixed Effects:
## (Intercept)            Z  
##   -0.013930    -0.008804  
## optimizer (nloptwrap) convergence code: 0 (OK) ; 0 optimizer warnings; 1 lme4 warnings 
## 
## $output
## [1] &quot;&quot;
## 
## $warnings
## character(0)
## 
## $messages
## [1] &quot;boundary (singular) fit: see help(&#39;isSingular&#39;)\n&quot;</code></pre>
<p>You then might have, in your analyzing code:</p>
<div class="sourceCode" id="cb536"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb536-1"><a href="#cb536-1" tabindex="-1"></a>analyze_data <span class="ot">&lt;-</span> <span class="cf">function</span>( dat ) {</span>
<span id="cb536-2"><a href="#cb536-2" tabindex="-1"></a>    </span>
<span id="cb536-3"><a href="#cb536-3" tabindex="-1"></a>    M1 <span class="ot">&lt;-</span> <span class="fu">quiet_lmer</span>( Yobs <span class="sc">~</span> <span class="dv">1</span> <span class="sc">+</span> Z <span class="sc">+</span> (<span class="dv">1</span><span class="sc">|</span>sid), <span class="at">data=</span>dat )</span>
<span id="cb536-4"><a href="#cb536-4" tabindex="-1"></a>    message1 <span class="ot">=</span> <span class="fu">ifelse</span>( <span class="fu">length</span>( M1<span class="sc">$</span>message ) <span class="sc">&gt;</span> <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span> )</span>
<span id="cb536-5"><a href="#cb536-5" tabindex="-1"></a>    warning1 <span class="ot">=</span> <span class="fu">ifelse</span>( <span class="fu">length</span>( M1<span class="sc">$</span>warning ) <span class="sc">&gt;</span> <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span> )</span>
<span id="cb536-6"><a href="#cb536-6" tabindex="-1"></a></span>
<span id="cb536-7"><a href="#cb536-7" tabindex="-1"></a>    <span class="co"># Compile our results</span></span>
<span id="cb536-8"><a href="#cb536-8" tabindex="-1"></a>    <span class="fu">tibble</span>( <span class="at">ATE_hat =</span> <span class="fu">coef</span>(M1)[<span class="st">&quot;Z&quot;</span>],</span>
<span id="cb536-9"><a href="#cb536-9" tabindex="-1"></a>            <span class="at">SE_hat =</span> <span class="fu">se.coef</span>(M1)[<span class="st">&quot;Z&quot;</span>],</span>
<span id="cb536-10"><a href="#cb536-10" tabindex="-1"></a>            <span class="at">message =</span> message1,</span>
<span id="cb536-11"><a href="#cb536-11" tabindex="-1"></a>            <span class="at">warning =</span> warning1 )</span>
<span id="cb536-12"><a href="#cb536-12" tabindex="-1"></a>}</span></code></pre></div>
<p>Now you have your primary estimates, and also flags for whether there was a convergence issue.
In the analysis section you can then evaluate what proportion of the time there was a warning or message, and then do subset analyses to those simulation trials where there was no such warning.</p>
<!--chapter:end:100-error-trapping.Rmd-->
</div>
</div>
<div id="saving-files" class="section level1 hasAnchor" number="17">
<h1 class="hasAnchor"><span class="header-section-number">17</span> Saving files and results<a href="#saving-files" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p>Always save your simulation results to a file.
Simulations are painful and time consuming to run, and you will invariably want to analyze the results of them in a variety of different ways, once you have looked at your preliminary analysis.
We advocate saving your simulation as soon as it is complete.
But there are some ways to do better than that, such as saving as you go.
This can protect you if your simulation occasionally crashes, or if you want to rerun only parts of your simulation for some reason.</p>
<div id="saving-simulations-in-general" class="section level2 hasAnchor" number="17.1">
<h2 class="hasAnchor"><span class="header-section-number">17.1</span> Saving simulations in general<a href="#saving-simulations-in-general" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Once your simulation has completed, you can save it like so:</p>
<div class="sourceCode" id="cb537"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb537-1"><a href="#cb537-1" tabindex="-1"></a><span class="fu">dir.create</span>(<span class="st">&quot;results&quot;</span>, <span class="at">showWarnings =</span> <span class="cn">FALSE</span> )</span>
<span id="cb537-2"><a href="#cb537-2" tabindex="-1"></a><span class="fu">write_csv</span>( res, <span class="st">&quot;results/simulation_CRT.csv&quot;</span> )</span></code></pre></div>
<p><code>write_csv()</code> is a tidyverse file-writing command; see “R for Data Science”
textbook, 11.5.</p>
<p>You can then load it, just before analysis, as so:</p>
<div class="sourceCode" id="cb538"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb538-1"><a href="#cb538-1" tabindex="-1"></a>res <span class="ot">=</span> <span class="fu">read_csv</span>( <span class="st">&quot;results/simulation_CRT.csv&quot;</span> )</span></code></pre></div>
<p>There are two general tools for saving. The <code>read/write_csv</code> methods save your file in a way where you can open it with a spreadsheet program and look at it.
But your results should be in a vanilla format (non-fancy data frame without list columns).</p>
<p>Alternatively, you can use the <code>saveRDS()</code> and <code>readRDS()</code> methods; these save objects to a file such that when you load them, they are as you left them.
(The simpler format of a csv file means your factors, if you have them, may not preseve as factors, and so forth.)</p>
</div>
<div id="saving-simulations-as-you-go" class="section level2 hasAnchor" number="17.2">
<h2 class="hasAnchor"><span class="header-section-number">17.2</span> Saving simulations as you go<a href="#saving-simulations-as-you-go" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>If you are not sure you have time to run your entire simulation, or you think your computer might crash half way through, or something similar, you can save each chunk you run as you go, in its own file. You then stack those files at the end to get your final results.
With clever design, you can even then selectively delete files to rerun only parts of your larger simulation—but be sure to rerun everything from scratch before you run off and publish your results, to avoid embarrassing errors.</p>
<p>Here, for example, is a script from a research project examining how one might use post-stratification to improve the precision of an IV estimate.
This is the script that runs the simulation.
Note the sourcing of other scripts that have all the relevant functions; these are not important here.
Due to modular programming, we can see what this script does, even without those detail.</p>
<div class="sourceCode" id="cb539"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb539-1"><a href="#cb539-1" tabindex="-1"></a><span class="fu">source</span>( <span class="st">&quot;pack_simulation_functions.R&quot;</span> )</span>
<span id="cb539-2"><a href="#cb539-2" tabindex="-1"></a></span>
<span id="cb539-3"><a href="#cb539-3" tabindex="-1"></a><span class="cf">if</span> ( <span class="sc">!</span><span class="fu">file.exists</span>(<span class="st">&quot;results/frags&quot;</span> ) ) {</span>
<span id="cb539-4"><a href="#cb539-4" tabindex="-1"></a>    <span class="fu">dir.create</span>(<span class="st">&quot;results/frags&quot;</span>)</span>
<span id="cb539-5"><a href="#cb539-5" tabindex="-1"></a>}</span>
<span id="cb539-6"><a href="#cb539-6" tabindex="-1"></a></span>
<span id="cb539-7"><a href="#cb539-7" tabindex="-1"></a><span class="co"># Number of simulation replicates per scenario</span></span>
<span id="cb539-8"><a href="#cb539-8" tabindex="-1"></a>R <span class="ot">=</span> <span class="dv">1000</span></span>
<span id="cb539-9"><a href="#cb539-9" tabindex="-1"></a></span>
<span id="cb539-10"><a href="#cb539-10" tabindex="-1"></a><span class="co"># Do simulation breaking up R into this many chunks</span></span>
<span id="cb539-11"><a href="#cb539-11" tabindex="-1"></a>M_CHUNK <span class="ot">=</span> <span class="dv">10</span></span>
<span id="cb539-12"><a href="#cb539-12" tabindex="-1"></a></span>
<span id="cb539-13"><a href="#cb539-13" tabindex="-1"></a><span class="do">###### Set up the multifactor simulation #######</span></span>
<span id="cb539-14"><a href="#cb539-14" tabindex="-1"></a></span>
<span id="cb539-15"><a href="#cb539-15" tabindex="-1"></a><span class="co"># chunkNo is a hack to make a bunch of smaller chunks for doing parallel more</span></span>
<span id="cb539-16"><a href="#cb539-16" tabindex="-1"></a><span class="co"># efficiently.</span></span>
<span id="cb539-17"><a href="#cb539-17" tabindex="-1"></a>factors <span class="ot">=</span> <span class="fu">expand_grid</span>( <span class="at">chunkNo =</span> <span class="dv">1</span><span class="sc">:</span>M_CHUNK,</span>
<span id="cb539-18"><a href="#cb539-18" tabindex="-1"></a>                       <span class="at">N =</span> <span class="fu">c</span>( <span class="dv">500</span>, <span class="dv">1000</span>, <span class="dv">2000</span> ),</span>
<span id="cb539-19"><a href="#cb539-19" tabindex="-1"></a>                       <span class="at">pi_c =</span> <span class="fu">c</span>( <span class="fl">0.05</span>, <span class="fl">0.075</span>, <span class="fl">0.10</span> ),</span>
<span id="cb539-20"><a href="#cb539-20" tabindex="-1"></a>                       <span class="at">nt_shift =</span> <span class="fu">c</span>( <span class="sc">-</span><span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span> ),</span>
<span id="cb539-21"><a href="#cb539-21" tabindex="-1"></a>                       <span class="at">pred_comp =</span> <span class="fu">c</span>( <span class="st">&quot;yes&quot;</span>, <span class="st">&quot;no&quot;</span> ),</span>
<span id="cb539-22"><a href="#cb539-22" tabindex="-1"></a>                       <span class="at">pred_Y =</span> <span class="fu">c</span>( <span class="st">&quot;yes&quot;</span>, <span class="st">&quot;no&quot;</span> ),</span>
<span id="cb539-23"><a href="#cb539-23" tabindex="-1"></a>                       <span class="at">het_tx =</span> <span class="fu">c</span>( <span class="st">&quot;yes&quot;</span>, <span class="st">&quot;no&quot;</span> ),</span>
<span id="cb539-24"><a href="#cb539-24" tabindex="-1"></a>                       <span class="at">sd0 =</span> <span class="dv">1</span></span>
<span id="cb539-25"><a href="#cb539-25" tabindex="-1"></a>                       )</span>
<span id="cb539-26"><a href="#cb539-26" tabindex="-1"></a>factors <span class="ot">&lt;-</span> factors <span class="sc">%&gt;%</span> <span class="fu">mutate</span>(</span>
<span id="cb539-27"><a href="#cb539-27" tabindex="-1"></a>    <span class="at">reps =</span> R <span class="sc">/</span> M_CHUNK,</span>
<span id="cb539-28"><a href="#cb539-28" tabindex="-1"></a>    <span class="at">seed =</span> <span class="dv">16200320</span> <span class="sc">+</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">n</span>()</span>
<span id="cb539-29"><a href="#cb539-29" tabindex="-1"></a>)</span></code></pre></div>
<p>This generates a data frame of all our factor combinations.
This is our list of “tasks” (each row of factors).
These tasks have repeats: the “chunks” means we do a portion of each scenario, as specified by our simulation factors, as a process.
This would allow for greater parallelization (e.g., if we had more cores), and also lets us save our work without finishing an entire scenario of, in this case, 1000 iterations.</p>
<p>To set up our simulation we make a little helper method to do one row.
With each row, once we have run it, we save it to disk.
This means if we kill our simulation half-way through, most of the work would be saved.
Our function is then going to either do the simulation (and save the result to disk immediately), or, if it can find the file with the results from a previous run, load those results from disk:</p>
<div class="sourceCode" id="cb540"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb540-1"><a href="#cb540-1" tabindex="-1"></a>safe_run_sim <span class="ot">=</span> <span class="fu">safely</span>( run_sim )</span>
<span id="cb540-2"><a href="#cb540-2" tabindex="-1"></a>file_saving_sim <span class="ot">=</span> <span class="cf">function</span>( chunkNo, seed, ... ) {</span>
<span id="cb540-3"><a href="#cb540-3" tabindex="-1"></a>    fname <span class="ot">=</span> <span class="fu">paste0</span>( <span class="st">&quot;results/frags/fragment_&quot;</span>, chunkNo, <span class="st">&quot;_&quot;</span>, seed, <span class="st">&quot;.rds&quot;</span> )</span>
<span id="cb540-4"><a href="#cb540-4" tabindex="-1"></a>    res <span class="ot">=</span> <span class="cn">NA</span></span>
<span id="cb540-5"><a href="#cb540-5" tabindex="-1"></a>    <span class="cf">if</span> ( <span class="sc">!</span><span class="fu">file.exists</span>(fname) ) {</span>
<span id="cb540-6"><a href="#cb540-6" tabindex="-1"></a>        res <span class="ot">=</span> <span class="fu">safe_run_sim</span>( <span class="at">chunkNo=</span>chunkNo, <span class="at">seed=</span>seed, ... )</span>
<span id="cb540-7"><a href="#cb540-7" tabindex="-1"></a>        <span class="fu">saveRDS</span>(res, <span class="at">file =</span> fname )</span>
<span id="cb540-8"><a href="#cb540-8" tabindex="-1"></a>    } <span class="cf">else</span> {</span>
<span id="cb540-9"><a href="#cb540-9" tabindex="-1"></a>        res <span class="ot">=</span> <span class="fu">readRDS</span>( <span class="at">file=</span>fname )</span>
<span id="cb540-10"><a href="#cb540-10" tabindex="-1"></a>    }</span>
<span id="cb540-11"><a href="#cb540-11" tabindex="-1"></a>    <span class="fu">return</span>( res )</span>
<span id="cb540-12"><a href="#cb540-12" tabindex="-1"></a>}</span></code></pre></div>
<p>Note how we wrap our core <code>run_sim</code> method in <code>safely</code>; it was crashing very occasionally, and so to make the code more robust, we wrapped it so we could see any error messages.</p>
<p>We next run the simulation.
We shuffle the rows of our task list so that which process gets what task is randomized.
If some tasks are much longer (e.g., due to larger sample size) then this will get balanced out across our processes.</p>
<p>We have an <code>if-then</code> structure to easily switch between parallel and nonparallel code.
This makes debugging easier: when running in parallel, stuff printed to the console does not show until the simulation is over.
Plus it would be all mixed up since multiple processes are working simultaneously.</p>
<p>This overall structure allows the researcher to delete one of the “fragment” files from the disk, run the simulation code, and have it just do one tiny piece of the simulation.
This means the researcher can insert a <code>browser()</code> command somewhere inside the code, and debug the code, in the natural context of how the simulation is being run.</p>
<div class="sourceCode" id="cb541"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb541-1"><a href="#cb541-1" tabindex="-1"></a><span class="co"># Shuffle the rows so we run in random order to load balance.</span></span>
<span id="cb541-2"><a href="#cb541-2" tabindex="-1"></a>factors <span class="ot">=</span> <span class="fu">sample_n</span>(factors, <span class="fu">nrow</span>(factors) )</span>
<span id="cb541-3"><a href="#cb541-3" tabindex="-1"></a></span>
<span id="cb541-4"><a href="#cb541-4" tabindex="-1"></a><span class="cf">if</span> ( <span class="cn">TRUE</span> ) {</span>
<span id="cb541-5"><a href="#cb541-5" tabindex="-1"></a>    <span class="co"># Run in parallel</span></span>
<span id="cb541-6"><a href="#cb541-6" tabindex="-1"></a>    parallel<span class="sc">::</span><span class="fu">detectCores</span>()</span>
<span id="cb541-7"><a href="#cb541-7" tabindex="-1"></a>    </span>
<span id="cb541-8"><a href="#cb541-8" tabindex="-1"></a>    <span class="fu">library</span>(future)</span>
<span id="cb541-9"><a href="#cb541-9" tabindex="-1"></a>    <span class="fu">library</span>(furrr)</span>
<span id="cb541-10"><a href="#cb541-10" tabindex="-1"></a>    </span>
<span id="cb541-11"><a href="#cb541-11" tabindex="-1"></a>    <span class="co">#plan(multiprocess) # choose an appropriate plan from future package</span></span>
<span id="cb541-12"><a href="#cb541-12" tabindex="-1"></a>    <span class="co">#plan(multicore)</span></span>
<span id="cb541-13"><a href="#cb541-13" tabindex="-1"></a>    <span class="fu">plan</span>(multisession, <span class="at">workers =</span> parallel<span class="sc">::</span><span class="fu">detectCores</span>() <span class="sc">-</span> <span class="dv">2</span> )</span>
<span id="cb541-14"><a href="#cb541-14" tabindex="-1"></a>    </span>
<span id="cb541-15"><a href="#cb541-15" tabindex="-1"></a>    factors<span class="sc">$</span>res <span class="ot">&lt;-</span> <span class="fu">future_pmap</span>(factors, <span class="at">.f =</span> file_saving_sim,</span>
<span id="cb541-16"><a href="#cb541-16" tabindex="-1"></a>                          <span class="at">.options =</span> <span class="fu">furrr_options</span>(<span class="at">seed =</span> <span class="cn">NULL</span>),</span>
<span id="cb541-17"><a href="#cb541-17" tabindex="-1"></a>                          <span class="at">.progress =</span> <span class="cn">TRUE</span> )</span>
<span id="cb541-18"><a href="#cb541-18" tabindex="-1"></a>    </span>
<span id="cb541-19"><a href="#cb541-19" tabindex="-1"></a>} <span class="cf">else</span> {</span>
<span id="cb541-20"><a href="#cb541-20" tabindex="-1"></a>  <span class="co"># Run not in parallel, used for debugging</span></span>
<span id="cb541-21"><a href="#cb541-21" tabindex="-1"></a>  factors<span class="sc">$</span>res <span class="ot">&lt;-</span> <span class="fu">pmap</span>(factors, <span class="at">.f =</span> file_saving_sim )</span>
<span id="cb541-22"><a href="#cb541-22" tabindex="-1"></a>}</span>
<span id="cb541-23"><a href="#cb541-23" tabindex="-1"></a></span>
<span id="cb541-24"><a href="#cb541-24" tabindex="-1"></a>tictoc<span class="sc">::</span><span class="fu">toc</span>()</span></code></pre></div>
<p>Our method cleverly loads files in, or generates them, for each chunk.
The seed setting ensures reproducibility.
Once we are done, we need to clean up our results:</p>
<div class="sourceCode" id="cb542"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb542-1"><a href="#cb542-1" tabindex="-1"></a>sim_results <span class="ot">&lt;-</span> </span>
<span id="cb542-2"><a href="#cb542-2" tabindex="-1"></a>    factors <span class="sc">%&gt;%</span> </span>
<span id="cb542-3"><a href="#cb542-3" tabindex="-1"></a>    <span class="fu">unnest</span>(<span class="at">cols =</span> res)</span>
<span id="cb542-4"><a href="#cb542-4" tabindex="-1"></a></span>
<span id="cb542-5"><a href="#cb542-5" tabindex="-1"></a><span class="co"># Cut apart the results and error messages</span></span>
<span id="cb542-6"><a href="#cb542-6" tabindex="-1"></a>sim_results<span class="sc">$</span>sr <span class="ot">=</span> <span class="fu">rep</span>( <span class="fu">c</span>(<span class="st">&quot;res&quot;</span>,<span class="st">&quot;err&quot;</span>), <span class="fu">nrow</span>(sim_results)<span class="sc">/</span><span class="dv">2</span>)</span>
<span id="cb542-7"><a href="#cb542-7" tabindex="-1"></a>sim_results <span class="ot">=</span> <span class="fu">pivot_wider</span>( sim_results, <span class="at">names_from =</span> sr, <span class="at">values_from =</span> res )</span>
<span id="cb542-8"><a href="#cb542-8" tabindex="-1"></a></span>
<span id="cb542-9"><a href="#cb542-9" tabindex="-1"></a><span class="fu">saveRDS</span>( sim_results, <span class="at">file=</span><span class="st">&quot;results/simulation_results.rds&quot;</span> )</span></code></pre></div>
</div>
<div id="dynamically-making-directories" class="section level2 hasAnchor" number="17.3">
<h2 class="hasAnchor"><span class="header-section-number">17.3</span> Dynamically making directories<a href="#dynamically-making-directories" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>If you are generating a lot of files, then you should put them somewhere.
But where?
It is nice to dynamically generate a directory for your files on fly.
One way to do this is to write a function that will make any needed directory, if it doesn’t exist, and then put your file in that spot.
For example, you might have your own version of <code>write_csv</code> as:</p>
<div class="sourceCode" id="cb543"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb543-1"><a href="#cb543-1" tabindex="-1"></a>my_write_csv <span class="ot">&lt;-</span> <span class="cf">function</span>( data, path, file ) {</span>
<span id="cb543-2"><a href="#cb543-2" tabindex="-1"></a>  </span>
<span id="cb543-3"><a href="#cb543-3" tabindex="-1"></a>  <span class="cf">if</span> ( <span class="sc">!</span><span class="fu">dir.exists</span>( here<span class="sc">::</span><span class="fu">here</span>( path ) ) ) {</span>
<span id="cb543-4"><a href="#cb543-4" tabindex="-1"></a>    <span class="fu">dir.create</span>( here<span class="sc">::</span><span class="fu">here</span>( path ), <span class="at">recursive=</span><span class="cn">TRUE</span> ) </span>
<span id="cb543-5"><a href="#cb543-5" tabindex="-1"></a>  }</span>
<span id="cb543-6"><a href="#cb543-6" tabindex="-1"></a>  <span class="fu">write_csv</span>( data, <span class="fu">paste0</span>( path, file ) )</span>
<span id="cb543-7"><a href="#cb543-7" tabindex="-1"></a>}</span></code></pre></div>
<p>This will look for a path (starting from your R Project, by taking advantage of the <code>here</code> package), and put your data file in that spot.
If the spot doesn’t exist, it will make it for you.</p>
</div>
<div id="loading-and-combining-files-of-simulation-results" class="section level2 hasAnchor" number="17.4">
<h2 class="hasAnchor"><span class="header-section-number">17.4</span> Loading and combining files of simulation results<a href="#loading-and-combining-files-of-simulation-results" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Once your simulation files are all generated, the following code will stack them all into a giant set of results, assuming all the files are themselves data frames stored in RDS objects.
This function will try and stack all files found in a given directory; for it to work, you should ensure there are no other files stored there.</p>
<div class="sourceCode" id="cb544"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb544-1"><a href="#cb544-1" tabindex="-1"></a>load.all.sims <span class="ot">=</span> <span class="cf">function</span>( <span class="at">filehead=</span><span class="st">&quot;results/&quot;</span> ) {</span>
<span id="cb544-2"><a href="#cb544-2" tabindex="-1"></a>  </span>
<span id="cb544-3"><a href="#cb544-3" tabindex="-1"></a>  files <span class="ot">=</span> <span class="fu">list.files</span>( filehead, <span class="at">full.names=</span><span class="cn">TRUE</span>)</span>
<span id="cb544-4"><a href="#cb544-4" tabindex="-1"></a>  </span>
<span id="cb544-5"><a href="#cb544-5" tabindex="-1"></a>  res <span class="ot">=</span> <span class="fu">map_df</span>( files, <span class="cf">function</span>( fname ) {</span>
<span id="cb544-6"><a href="#cb544-6" tabindex="-1"></a>    <span class="fu">cat</span>( <span class="st">&quot;Reading results from &quot;</span>, fname, <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> )</span>
<span id="cb544-7"><a href="#cb544-7" tabindex="-1"></a>    rs <span class="ot">=</span> <span class="fu">readRDS</span>( <span class="at">file =</span> fname )</span>
<span id="cb544-8"><a href="#cb544-8" tabindex="-1"></a>    rs<span class="sc">$</span>filename <span class="ot">=</span> fname</span>
<span id="cb544-9"><a href="#cb544-9" tabindex="-1"></a>    rs</span>
<span id="cb544-10"><a href="#cb544-10" tabindex="-1"></a>  })</span>
<span id="cb544-11"><a href="#cb544-11" tabindex="-1"></a>  res</span>
<span id="cb544-12"><a href="#cb544-12" tabindex="-1"></a>}</span></code></pre></div>
<p>You would use as so:</p>
<div class="sourceCode" id="cb545"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb545-1"><a href="#cb545-1" tabindex="-1"></a>results <span class="ot">=</span> <span class="fu">load.all.sims</span>( <span class="at">filehead=</span><span class="st">&quot;raw_results/&quot;</span> )</span></code></pre></div>
<!--chapter:end:105-file-management.Rmd-->
</div>
</div>
<div id="parallel-processing" class="section level1 hasAnchor" number="18">
<h1 class="hasAnchor"><span class="header-section-number">18</span> Parallel Processing<a href="#parallel-processing" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p>Especially if you take our advice of “when in doubt, go more general” and if you calculate monte carlo standard errors, you will quickly come up against the limits of your computer.
Simultions can be incredibly computationally intensive, and there are a few means for dealing with that.
The first, touched on at times throughout the book, is to optimize ones code by looking for ways to remove extraneous calculation (e.g., by writing ones own methods rather than using the safety-checking and thus sometimes slower methods in R, or by saving calculations that are shared across different estimation approaches).
The second is to use more computing power.
This latter approach is the topic of this chapter.</p>
<p>There are two general ways to do parallel calculation.
The first is to take advantage of the fact that most modern computers have multiple cores (i.e., computers) built in.
With this approach, we tell R to use more of the processing power of your desktop or laptop.
If your computer has eight cores, you can easily get a near eight-fold increase in the speed of your simulation.</p>
<p>The second is to use cloud computing, or compute on a cluster.
A computing cluster is a network of hundreds or thousands of computers, coupled with commands where you break apart a simulation into pieces and send the pieces to your army of computers.
Conceptually, this is the same as when you do baby parallel on your desktop: more cores equals more simulations per minute and thus faster simulation overall.
But the interface to a cluster can be a bit tricky, and very cluster-dependent.</p>
<p>But once you get it up and running, it can be a very powerful tool.
First, it takes the computing off your computer entirely, making it easier to set up a job to run for days or weeks without making your day to day life any more difficult.
Second, it gives you hundreds of cores, potentially, which means a speed-up of hundreds rather than four or eight.</p>
<p>Simulations are a very natural choice for parallel computation.
With a multifactor experiment it is very easy to break apart the overall into pieces.
For example, you might send each factor combination to a single machine.
Even without multi factor experiments, due to the cycle of “generate data, then analyze,” it is easy to have a bunch of computers doing the same thing, with a final collection step where all the individual iterations are combined into one at the end.</p>
<div id="parallel-on-your-computer" class="section level2 hasAnchor" number="18.1">
<h2 class="hasAnchor"><span class="header-section-number">18.1</span> Parallel on your computer<a href="#parallel-on-your-computer" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Most modern computers have multiple cores, so you can run a parallel simulation right in the privacy of your own home!</p>
<p>To assess how many cores you have on your computer, you can use the <code>detectCores()</code> method in the <code>parallel</code> package:</p>
<div class="sourceCode" id="cb546"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb546-1"><a href="#cb546-1" tabindex="-1"></a>parallel<span class="sc">::</span><span class="fu">detectCores</span>()</span></code></pre></div>
<pre><code>## [1] 12</code></pre>
<p>Normally, unless you tell it to do otherwise, <strong><em>R only uses one core</em></strong>.
This is obviously a bit lazy on R’s part.
But it is easy to take advantage of multiple cores using the <code>future</code> and <code>furrr</code> packages.</p>
<div class="sourceCode" id="cb548"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb548-1"><a href="#cb548-1" tabindex="-1"></a><span class="fu">library</span>(future)</span>
<span id="cb548-2"><a href="#cb548-2" tabindex="-1"></a><span class="fu">library</span>(furrr)</span></code></pre></div>
<p>In particular, the <code>furrr</code> package replicates our <code>map</code> functions, but in parallel.
We first tell our R session what kind of parallel processing we want using the <code>future</code> package.
In general, using <code>plan(multisession)</code> is the cleanest: it will start one entire R session per core, and have each session do work for you.
The alternative, <code>multicore</code> does not seem to work well with Windows machines, nor with RStudio in general.</p>
<p>The call is simple:</p>
<div class="sourceCode" id="cb549"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb549-1"><a href="#cb549-1" tabindex="-1"></a><span class="fu">plan</span>(multisession, <span class="at">workers =</span> parallel<span class="sc">::</span><span class="fu">detectCores</span>() <span class="sc">-</span> <span class="dv">1</span> )</span></code></pre></div>
<p>The <code>workers</code> parameter specifies how many of your cores you want to use.
Using all but one will let your computer still operate mostly normally for checking email and so forth.
You are carving out a bit of space for your own adventures.</p>
<p>Once you set up your plan, you use <code>future_pmap()</code>; it works just like <code>pmap()</code> but evaluates across all available workers specified in the plan call.
Here we are running a parallel version of the multifactor experiment discussed in Chapter @ref(exp_design) (see chapter @ref(case_Cronback) for the simulation itself).</p>
<div class="sourceCode" id="cb550"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb550-1"><a href="#cb550-1" tabindex="-1"></a>tictoc<span class="sc">::</span><span class="fu">tic</span>()</span>
<span id="cb550-2"><a href="#cb550-2" tabindex="-1"></a>params<span class="sc">$</span>res <span class="ot">=</span> <span class="fu">future_pmap</span>(params,</span>
<span id="cb550-3"><a href="#cb550-3" tabindex="-1"></a>                         <span class="at">.f =</span> run_alpha_sim,</span>
<span id="cb550-4"><a href="#cb550-4" tabindex="-1"></a>                         <span class="at">.options =</span> <span class="fu">furrr_options</span>(<span class="at">seed =</span> <span class="cn">NULL</span>))</span>
<span id="cb550-5"><a href="#cb550-5" tabindex="-1"></a>tictoc<span class="sc">::</span><span class="fu">tic</span>()</span></code></pre></div>
<p>Note the <code>.options = furrr_options(seed = NULL)</code> part of the argument.
This is to silence some warnings.
Given how tasks are handed out, R will get upset if you don’t do some handholding regarding how it should set seeds for pseudoranom number generation.
In particular, if you don’t set the seed, the multiple sessions could end up having the same starting seed and thus run the exact same simulations (in principle).
We have seen before how to set specific seed for each simulation scenario, but <code>furrr</code> doesn’t know we have done this.
This is why the extra argument about seeds: it is being explicit that we are handling seed setting on our own.</p>
<p>We can compare the running time to running in serial (i.e. using only one worker):</p>
<div class="sourceCode" id="cb551"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb551-1"><a href="#cb551-1" tabindex="-1"></a>tictoc<span class="sc">::</span><span class="fu">tic</span>()</span>
<span id="cb551-2"><a href="#cb551-2" tabindex="-1"></a>params<span class="sc">$</span>res2 <span class="ot">=</span> dplyr<span class="sc">::</span><span class="fu">select</span>(params, n<span class="sc">:</span>seed) <span class="sc">%&gt;%</span></span>
<span id="cb551-3"><a href="#cb551-3" tabindex="-1"></a>  <span class="fu">pmap</span>(<span class="at">.f =</span> run_alpha_sim)</span>
<span id="cb551-4"><a href="#cb551-4" tabindex="-1"></a>tictoc<span class="sc">::</span><span class="fu">tic</span>()</span></code></pre></div>
<p>(The <code>select</code> command is to drop the <code>res</code> column from the parallel run; it would otherwise be passed as as parameter to <code>run_alpha_sim</code> which would in turn cause an error due to the unrecognized parameter.)</p>
</div>
<div id="parallel-off-your-computer" class="section level2 hasAnchor" number="18.2">
<h2 class="hasAnchor"><span class="header-section-number">18.2</span> Parallel off your computer<a href="#parallel-off-your-computer" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>In general, a “cluster” is a system of computers that are connected up to form a large distributed network that many different people can use to do large computational tasks (e.g., simulations!).
These clusters will have some overlaying coordinating programs that you, the user, will interact with to set up a “job,” or set of jobs, which is a set of tasks you want some number of the computers on the cluster to do for you in tandum.</p>
<p>These coordinating programs will differ, depending on what cluster you are using, but have some similarities that bear mention.
For running simulations, you only need the smallest amount of knowledge about how to engage with these systems because you don’t need all the individual computers working on your project communicating with each other (which is the hard part of distributed computing, in general).</p>
<div id="what-is-a-command-line-interface" class="section level3 hasAnchor" number="18.2.1">
<h3 class="hasAnchor"><span class="header-section-number">18.2.1</span> What is a command-line interface?<a href="#what-is-a-command-line-interface" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>In the good ol’ days, when things were simpler, yet more difficult, you would interact with your computer via a “command-line interface.”
The easiest way to think about this is as an R console, but in a different language that the entire computer speaks.
A command line interface is designed to do things like find files with a specific name, or copy entire directories, or, importantly, start different programs.
Another place you may have used a command line inteface is when working with Git: anything fancy with Git is often done via command-line.
People will talk about a “shell” (a generic term for this computer interface) or “bash” or “csh.”
You can get access to a shell from within RStudio by clicking on the “Terminal” tab.
Try it, if you’ve never done anything like this before, and type</p>
<pre><code>ls</code></pre>
<p>It should list some file names.
Note this command does <em>not</em> have the parenthesis after the command, like in R or most other programming languages.
The syntax of a shell is usually mystifying and brutal: it is best to just steal scripts from the internet and try not to think about it too much, unless you want to think about it a lot.</p>
<p>Importantly for us, from the command line interface you can start an R program, telling it to start up and run a script for you.
This way of running R is noninteractive: you say “go do this thing,” and R starts up, goes and does it, and then quits.
Any output R generates on the way will be saved in a file, and any files you save along the way will also be at your disposal once R has completed.</p>
<p>To see this in action make the following script in a file called “dumb_job.R”:</p>
<pre><code>library( tidyverse )
cat( &quot;Making numbers\n&quot; )
Sys.sleep(30)
cat( &quot;Now I&#39;m ready\n&quot; )
dat = tibble( A = rnorm( 1000 ), B = runif( 1000 ) * A )
write_csv( dat, file=&quot;sim_results.csv&quot; )
Sys.sleep(30)
cat( &quot;Finished\n&quot; )</code></pre>
<p>Then open the terminal and type (the “&gt;” is not part of what you type):</p>
<pre><code>&gt; ls</code></pre>
<p>Do you see your <code>dumb_job.R</code> file? If not, your terminal session is in the wrong directory.
In your computer system, files are stored in a directory structure, and when you open a terminal, you are somewhere in that structure.</p>
<p>To find out where, you can type</p>
<pre><code>&gt; pwd</code></pre>
<p>for “Print Working Directory”.
Save your dumb job file to wherever the above says.
You can also change directories using <code>cd</code>, e.g., <code>cd ~/Desktop/temp</code> means “change directory to the temp folder inside Desktop inside my home directory” (the <code>~</code> is shorthand for home directory).
One more useful commands is <code>cd ..</code> (go up to the parent directory).</p>
<p>Once you are in the directory with your file, type:</p>
<pre><code>&gt; R CMD BATCH dumb_job.R R_output.txt --no-save</code></pre>
<p>The above command says “Run R” (the first part) in batch mode (the “CMD BATCH” part), meaning source the <code>dumb_job.R</code> script as soon as R starts, saving all console output in the file <code>R_output.txt</code> (it will be saved in the current directory where you run the program), and where you don’t save the workspace when finished.</p>
<p>This command should take about a minute to complete, because our script sleeps a lot (the sleep represents your script doing a lot of work, like a real simulation would do).
Once the command completes (you will see your “&gt;” prompt come back), verify that you have the <code>R_output.txt</code> and the data file <code>sim_results.csv</code> by typing <code>ls</code>.
If you open up your Finder or Microsoft equivilent, you can actually see the <code>R_output.txt</code> file appear half-way through, while your job is running.
If you open it, you will see the usual header of R telling you what it loading, the “Making numbers” comment, and so forth.
R is saving everything as it works through your script.</p>
<p>Running R in this fashion is the key element to a basic way of setting up a massive job on the cluster: you will have a bunch of R programs all “going and doing something” on different computers in the cluster.
They will all save their results to files (they will have files of different names, or you will not be happy with the end result) and then you will gather these files together to get your final set of results.</p>
<p><em>Small Exercise:</em> Try putting an error in your <code>dumb_job.R</code> script. What happens when you run it in batch mode?</p>
</div>
<div id="running-a-job-on-a-cluster" class="section level3 hasAnchor" number="18.2.2">
<h3 class="hasAnchor"><span class="header-section-number">18.2.2</span> Running a job on a cluster<a href="#running-a-job-on-a-cluster" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>In the above, you can run a command on the command-line, and the command line interfact will pause while it runs.
As you saw, when you hit return with the above R command, the program just sat there for a minute before you got your command-line prompt back, due to the sleep.</p>
<p>When you properlly run a big job (program) on a cluster, it doesn’t quite work that way.
You will instead set a program to run, but tell the cluster to run it somewhere else (people might say “run in the background”).
This is good because you get your command-line prompt back, and can do other things, while the program runs in the background.</p>
<p>There are various methods for doing this, but they usually boil down to a request from you to some sort of managerial process that takes requests and assigns some computer, somewhere, to do them.
(Imagine a dispatcher at a taxi company. You call up, ask for a ride, and it sends you a taxi to do it. The dispatcher is just fielding requests, assinging them to taxis.)</p>
<p>For example, one dispatcher is the slurm (which may or may not be on the cluster you are attempting to use; this is where a lot of this information gets very cluster-specific).</p>
<p>You first set up a script that describes the job to be run.
It is like a work request.
This would be a plain text file, such as this example (<code>sbatch_runScript.txt</code>):</p>
<pre><code>#!/bin/bash
#SBATCH -n 32                                                   # Number of cores requested
#SBATCH -N 1                                                      # Ensure that all cores are on one machine
#SBATCH -t 480                                                  # Runtime in minutes
#SBATCH -p stats                                                # Partition to submit to
#SBATCH --mem-per-cpu=1000                    # Memory per cpu in MB
#SBATCH --open-mode=append                      # Append to output file, don&#39;t truncate
#SBATCH -o /output/directory/out/%j.out # Standard out goes to this file
#SBATCH -e /output/directory/out/%j.err # Standard err goes to this file
#SBATCH --mail-type=ALL                         # Type of email notification- BEGIN,END,FAIL,ALL
#SBATCH --mail-user=email@gmail.com         # Email address

# You might have some special loading of modules in the computing environment
source new-modules.sh
module load gcc/7.1.0-fasrc01
module load R
export R_LIBS_USER=$HOME/apps/R:$R_LIBS_USER

#R file to run, and txt files to produce for output and errors
R CMD BATCH estimator_performance_simulation.R logs/R_output_${INDEX_VAR}.txt --no-save --no-restore</code></pre>
<p>This file starts with a bunch of variables that describe how sbatch should handle the request.
It then has a series of commands that get the computer environment ready.
Finally, it has the <code>R CMD BATCH</code> command that does the work you want.</p>
<p>These scripts can be quite confusing to understand.
There are so many options!
What do these things even do?
The answer is, for researchers early on their journey to do this kind of work, “Who knows?”
The general rule is to find an example file for the system you are working on that works, and then modify it for your own purposes.</p>
<p>Once you have such a file, you could run it on the command line, like this:</p>
<pre><code>sbatch -o stdout.txt \
        --job-name=my_script \
        sbatch_runScript.txt</code></pre>
<p>You do this, and it will <em>not</em> sit there and wait for the job to be done.
The <code>sbatch</code> command will instead send the job off to some computer which will do the work in parallel.</p>
<p>Interestingly, your R script could, at this point, do the “one computer” parallel type code listed above.
Note the script above has 32 cores; your single job could then have 32 cores all working away on their individual pieces of the simulation, as before (e.g., with <code>future_pmap</code>).
You would have a 32-fold speedup, in this case.</p>
<p>This is the core element to having your simulation run on a cluster.
The next step is to do this <em>a lot</em>, sending off a bunch of these jobs to different computers.</p>
<p>Some final tips</p>
<ul>
<li><p>Remember to save a workspace or RDS!! Once you tell Odyssey to run an R file, it, well, runs the R file. But, you probably want information after it’s done - like an R object or even an R workspace. For any R file you want to run on Odyssey, remember at the end of the R file to put a command to save something after everything else is done. If you want to save a bunch of R objects, an R workspace might be a good way to go, but those files can be huge. A lot of times I find myself wanting only one or two R objects, and RDS files are a lot smaller.</p></li>
<li><p>Moving files from a cluster to your computer. You will need to first upload your files and code to the cluster, and then, once you’ve saved your workspace/RDS, you need those back on your computer. Using a scp client such as FileZilla is an easy way to do this file-transfer stuff. You can also use a Git repo for the code, but checking in the simulation results is not generally advisable: they are big, and not really in the spirit of a verson control system. Download your simulation results outside of Git, and keep your code in Git, is a good rule of thumb.</p></li>
</ul>
</div>
<div id="checking-on-a-job" class="section level3 hasAnchor" number="18.2.3">
<h3 class="hasAnchor"><span class="header-section-number">18.2.3</span> Checking on a job<a href="#checking-on-a-job" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Once your job is working on the cluster, it will keep at it until it finishes (or crashes, or is terminated for taking up too much memory or time).
As it chugs away, there will be different ways to check on it.
For example, you can, from the console, list the jobs you have running to see what is happening:</p>
<pre><code>sacct -u lmiratrix</code></pre>
<p>except, of course, “<code>lmiratrix</code>” would be changed to whatever your username is.
This will list if your file is running, pending, timed out, etc. If it’s pending, that usually means that someone else is hogging up space on the cluster and your job request is in a queue waiting to be assigned.</p>
<p>The <code>sacct</code> command is customizable, e.g.,</p>
<pre><code>sacct -u lmiratrix --format=JobID,JobName%30,State</code></pre>
<p>will not truncate your job names, so you can find them more easily.</p>
<p>You can check on a specific job, if you know the ID:</p>
<pre><code>squeue -j JOBID</code></pre>
<p>Something that’s fun is you can check who’s running files on the stats server by typing:</p>
<pre><code>showq-slurm -p stats -o</code></pre>
<p>You can also look at the log files</p>
<pre><code>tail my_log_file.log</code></pre>
<p>to see if it is logging information as it is working.</p>
<p>The email arguments, above, cause the system to email you before and after the job is complete.
The email notifications you can choose are <code>BEGIN</code>, <code>END</code>, <code>FAIL</code>, and <code>ALL</code>; <code>ALL</code> is generally good. What is a few more emails?</p>
</div>
<div id="running-lots-of-jobs-on-a-cluster" class="section level3 hasAnchor" number="18.2.4">
<h3 class="hasAnchor"><span class="header-section-number">18.2.4</span> Running lots of jobs on a cluster<a href="#running-lots-of-jobs-on-a-cluster" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>We have seen how to fire off a job (possibly a big job) that can run over days or weeks to give you your results.
There is one more piece that can allow you to use even more computing resources to do things even faster, which is to do a whole bunch of job requests like the above, all at once.
This multiple dispatching of sbatch commands is the final component for large simulations on a cluster: you are setting in motion a bunch of processes, each set to a specific task.</p>
<p>Asking for multiple, smaller, jobs is also nicer for the cluster than having one giant job that goes on for a long time.
By dividing a job into smaller pieces, and asking the scheduler to schedule those pieces, you can let the scheduler share and allocate resources between you and others more fairly.
It can make a list of your jobs, and farm them out as it has space.
This might go faster for you; with a really big job, the scheduler can’t even allocate it until the needed number of workers is available.
With smaller jobs, you can take a lot of little spaces to get your work done.
Especially since simulation is so independent (just doing the same thing over and over) there is rarely any need for one giant process that has to do everything.</p>
<p>To make multiple, related, requests, we create a for-loop in the Terminal to make a whole series sbatch requests.
Then, each sbatch request will do one part of the overall simulation.
We can write this program in the shell, just like you can write R scripts in R.
A shell scripts does a bunch of shell commands for you, and can even have variables and loops and all of that fun stuff.</p>
<p>For example, the following <code>run_full_simulation.sh</code> is a script that fires off a bunch of jobs for a simulation.
Note that it makes a variable <code>INDEX_VAR</code>, and sets up a loop so it can run 500 tasks indexed 1 through 500.</p>
<p>The first <code>export</code> line adds a collection of R libraries to the path stored in <code>R_LIBS_USER</code> (a “path” is a list of places where R will look for libraries).
The next line sets up a for loop: it will run the indented code once for each number from 1 to 500.
The script also specifies where to put log files and names each job with the index so you can know who is generating what file.</p>
<pre><code>export R_LIBS_USER=$HOME/apps/R:$R_LIBS_USER

for INDEX_VAR in $(seq 1 500); do

  #print out indexes
  echo &quot;${INDEX_VAR}&quot;

  #give indexes to R so it can find them.
  export INDEX_VAR 

  #Run R script, and produce output files
  sbatch -o logs/sbout_p${INDEX_VAR}.stdout.txt \
        --job-name=runScr_p${INDEX_VAR} \
        sbatch_runScript.txt
  
  sleep 1 # pause to be kind to the scheduler

done</code></pre>
<p>One question is then how do the different processes know what part of the simulation they should be working on?
E.g., each worker needs to have its own seed so it don’t do exactly the same simulation as a different worker!
The workers also need their own filenames so they save things in their own files.
The key is the <code>export INDEX_VAR</code> line: this puts a variable in the environment that will be set to a specific number.
Inside your R script, you can get that index like so:</p>
<div class="sourceCode" id="cb565"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb565-1"><a href="#cb565-1" tabindex="-1"></a>index <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(<span class="fu">as.character</span>(<span class="fu">Sys.getenv</span>(<span class="st">&quot;INDEX_VAR&quot;</span>)))</span></code></pre></div>
<p>You can then use the index to make unique filenames when you save your results, so each process has its own filename:</p>
<div class="sourceCode" id="cb566"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb566-1"><a href="#cb566-1" tabindex="-1"></a>filename <span class="ot">=</span> <span class="fu">paste0</span>( <span class="st">&quot;raw_results/simulation_results_&quot;</span>, index, _<span class="st">&quot;.rds&quot;</span> )</span></code></pre></div>
<p>You can also modify your seed such as with:</p>
<div class="sourceCode" id="cb567"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb567-1"><a href="#cb567-1" tabindex="-1"></a>factors <span class="ot">=</span> <span class="fu">mutate</span>( factors,</span>
<span id="cb567-2"><a href="#cb567-2" tabindex="-1"></a>                  <span class="at">seed =</span> <span class="fu">set.seed</span>( <span class="dv">1000</span> <span class="sc">*</span> seed <span class="sc">+</span> index ) )</span></code></pre></div>
<p>Now even if you have a series of seeds within the simulation script (as we have seen before), each script will have unique seeds not shared by any other script (assuming you have fewer than 1000 separate job requests).</p>
<p>This still doesn’t exactly answer how to have each worker know what to work on.
Conider the case of our multifactor experiment, where we have a large combination of simulation trials we want to run.</p>
<p>There are two approaches one might use here.
One simple approach is the following: we first generate all the factors with <code>expand_grid()</code> as usual, and then we take the row of this grid that corresponds to our index.</p>
<div class="sourceCode" id="cb568"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb568-1"><a href="#cb568-1" tabindex="-1"></a>sim_factors <span class="ot">=</span> <span class="fu">expand_grid</span>( ... )</span>
<span id="cb568-2"><a href="#cb568-2" tabindex="-1"></a>index <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(<span class="fu">as.character</span>(<span class="fu">Sys.getenv</span>(<span class="st">&quot;INDEX_VAR&quot;</span>)))</span>
<span id="cb568-3"><a href="#cb568-3" tabindex="-1"></a>filename <span class="ot">=</span> <span class="fu">paste0</span>( <span class="st">&quot;raw_results/simulation_results_&quot;</span>, index, _<span class="st">&quot;.rds&quot;</span> )</span>
<span id="cb568-4"><a href="#cb568-4" tabindex="-1"></a></span>
<span id="cb568-5"><a href="#cb568-5" tabindex="-1"></a><span class="fu">stopifnot</span>( index <span class="sc">&gt;=</span> <span class="dv">1</span> <span class="sc">&amp;&amp;</span> index <span class="sc">&lt;=</span> <span class="fu">nrow</span>(sim_factors ) )</span>
<span id="cb568-6"><a href="#cb568-6" tabindex="-1"></a><span class="fu">do.call</span>( my_sim_function, sim_factors[ index, ] )</span></code></pre></div>
<p>The <code>do.call()</code> command runs the simulation function, passing all the arguments listed in the targeted row.
You then need to make sure you have your shell call the right number of workers to run your entire simulation.</p>
<p>One problem with this approach is some simulations might be a lot more work than others: consider your simulation with a huge sample size vs. one with a small sample size.
Instead, you can have each worker run a small number of simulations of each scenario, and then stack your results later.
E.g.,</p>
<div class="sourceCode" id="cb569"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb569-1"><a href="#cb569-1" tabindex="-1"></a>sim_factors <span class="ot">=</span> <span class="fu">expand_grid</span>( ... )</span>
<span id="cb569-2"><a href="#cb569-2" tabindex="-1"></a>index <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(<span class="fu">as.character</span>(<span class="fu">Sys.getenv</span>(<span class="st">&quot;INDEX_VAR&quot;</span>)))</span>
<span id="cb569-3"><a href="#cb569-3" tabindex="-1"></a>sim_factors<span class="sc">$</span>seed <span class="ot">=</span> <span class="dv">1000000</span> <span class="sc">*</span> index <span class="sc">+</span> <span class="dv">17</span> <span class="sc">*</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(sim_factors)</span></code></pre></div>
<p>and then do your usual <code>pmap</code> call with <code>R = 10</code> (or some other small number of replicates.)</p>
<p>For saving files and then loading and combining them for analysis, see Section @ref(saving-files).</p>
</div>
<div id="resources-for-harvards-odyssey" class="section level3 hasAnchor" number="18.2.5">
<h3 class="hasAnchor"><span class="header-section-number">18.2.5</span> Resources for Harvard’s Odyssey<a href="#resources-for-harvards-odyssey" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>The above guidiance is tailored for Harvard’ computing environment, primarily.
For that environment in particular, there are many additional resources such as:</p>
<ul>
<li>Odyssey Guide: <a href="https://rc.fas.harvard.edu/resources/odyssey-quickstart-guide/" class="uri">https://rc.fas.harvard.edu/resources/odyssey-quickstart-guide/</a></li>
<li>R on Odyssey: <a href="https://rc.fas.harvard.edu/resources/documentation/software/r/" class="uri">https://rc.fas.harvard.edu/resources/documentation/software/r/</a></li>
</ul>
<p>For installing R packages so they are seen by the scripts run by sbatch, see (<a href="https://www.rc.fas.harvard.edu/resources/documentation/software-on-odyssey/r/" class="uri">https://www.rc.fas.harvard.edu/resources/documentation/software-on-odyssey/r/</a>)</p>
<p>Other clusters should have similar documents giving needed guidance for their specific contexts.</p>
</div>
<div id="acknowledgements-1" class="section level3 hasAnchor" number="18.2.6">
<h3 class="hasAnchor"><span class="header-section-number">18.2.6</span> Acknowledgements<a href="#acknowledgements-1" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Some of the above material is based on tutorials built by Kristen Hunter and Zach Branson, past doctoral students of Harvard’s statistics department.</p>
<!--chapter:end:120-parallel-processing.Rmd-->
</div>
</div>
</div>
<div id="simulations-as-evidence" class="section level1 hasAnchor" number="19">
<h1 class="hasAnchor"><span class="header-section-number">19</span> Simulations as evidence<a href="#simulations-as-evidence" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p>We began this book with an acknowledgement that simulation is fraught with the potential for misuse: <em>simulations are doomed to succeed</em>.
We close by reiterating this point, and then discuss several ways researchers might design their simulations so they more arguably produce real evidence on how well things might work.</p>
<p>When our work is done, ideally we will have generated simulations that provide a sort of “consumer product testing” for the study designs and statistical methods we are exploring.
Clearly, it is important to do some consumer product tests that are grounded in how consumers will actually use the product in real life—but before you get to that point, it can be helpful to cover an array of conditions that are probably more extreme than what will be experienced in practice (like dropping things off buildings or driving over them with cars or whatever else).
These extreme contexts give us more clear results, and can help us understand the limits of our methods.
These extreme contexts are also usually best-case (or at least optimistic) scenarios for when our estimator of interest will excel, giving in effect an upper bound on how well things could go.</p>
<p>Extreme and clear simulations are also usually easier to write, manipulate, and understand.
Such simulations can help us learn about the estimators themselves.
For example, simulation can help uncover how different aspects of a data generating process affect the performance of an estimator.
To discover this, you need a data generation process with clear levers controlling those aspects.
Simple simulations can be used to push theory further—we can experiment to gain an inclination of whether a model is a good idea at all, or to verify we are right about an intuition or derivation about how well an estimator can work.</p>
<p>But such simulations cannot be the end of our journey.
In general, a researcher should work to ensure their simulation evidence is <em>relevant</em>.
A set of simulations only using unreaslistic data generating processes may not be that useful.
Unless the estimators being tested have truly universally stable properties, we will not learn much from a simulation that is not relevant to the problem at hand.
We have to circle back to providing testing of the sorts of situations an eventual user of our methods might encounter in practice.
So how can we make our simulations more relevant?</p>
<div id="strategies-for-making-relevant-simulations" class="section level2 hasAnchor" number="19.1">
<h2 class="hasAnchor"><span class="header-section-number">19.1</span> Strategies for making relevant simulations<a href="#strategies-for-making-relevant-simulations" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>In the following subsections we go through a range of general strategies for making relevant simulations:</p>
<ol style="list-style-type: decimal">
<li>Use extensive multi-factor simulations</li>
<li>Generate simulations based on prior literature.</li>
<li>Pick simulation factors based on real data</li>
<li>Resample real data directly to get authentic distributions</li>
<li>Design a fully calibrated simulation</li>
</ol>
<div id="make-your-simulation-general-with-an-extensive-multi-factor-experiment" class="section level3 hasAnchor" number="19.1.1">
<h3 class="hasAnchor"><span class="header-section-number">19.1.1</span> Make your simulation general with an extensive multi-factor experiment<a href="#make-your-simulation-general-with-an-extensive-multi-factor-experiment" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>“If a single simulation is not convincing, use more of them,” is one principle a researcher might take.
By conducting extensive multifactor simulations, once can explore a large space of possible data generating scenarios.
If, across the full range of scenarios, a general story bears out, then perhaps that will be more convincing than a narrower range.</p>
<p>Of course, the critic will claim that some aspect that is not varying is the real culprit.
If this aspect is unrealistic, then the findings, across the board, may be less relevant.
Thus, pick the factors one varies with care.</p>
</div>
<div id="use-previously-published-simulations-to-beat-them-at-their-own-game" class="section level3 hasAnchor" number="19.1.2">
<h3 class="hasAnchor"><span class="header-section-number">19.1.2</span> Use previously published simulations to beat them at their own game<a href="#use-previously-published-simulations-to-beat-them-at-their-own-game" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>If a relevant prior paper uses a simulation to make a case, one approach is to replicate that simulation, adding in the new estimator one wants to evaluate.
This makes it (more) clear that you are not fishing: you are using something established in the literature as a published benchmark.
By constraining oneself to published simulations, one has less wiggle room to cherry pick a data generating process that works the way you want.</p>
</div>
<div id="calibrate-simulation-factors-to-real-data" class="section level3 hasAnchor" number="19.1.3">
<h3 class="hasAnchor"><span class="header-section-number">19.1.3</span> Calibrate simulation factors to real data<a href="#calibrate-simulation-factors-to-real-data" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Use real data to inform choice of factor levels or other data generation features.
For example, in James’s work on designing methods for meta-analysis, there is often a question of how big sample sizes should be and how many different outcomes per study there should be when simulating effect size estimates from hypothetical studies to be included in a hypothetical meta-analysis.
To make the simulations realistic, James obtained data from a set of past real meta-analyses and fit parametric models to these features, and used the resulting parameter estimates as benchmarks for how large and how varied the simulated meta analyses should be.</p>
<p>In this case, one would probably not use the exact estimated values, but instead use them as a point of reference and possibly explore a range of values around them.
For instance, say we find that the distribution of study sizes fits a Poisson(63) pretty well.
We might then then simulate study sizes using a Poisson with mean parameters of 40, 60, or 80 (where 40, 60, and 80 would be one factor in our multifactor experiment).</p>
</div>
<div id="use-real-data-to-obtain-directly" class="section level3 hasAnchor" number="19.1.4">
<h3 class="hasAnchor"><span class="header-section-number">19.1.4</span> Use real data to obtain directly<a href="#use-real-data-to-obtain-directly" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>You can also use real data directly to avoid a parametric model.
For example, say you need a population distribution for a slew of covariates.
Rather than using something artificial (like multivariate normal), you can pull population data on a bunch of covariates from some administrative data and then use those data as a (finite) population distribution.
You then simple sample (possibly with replacement) rows from your reference population to generate your simulationsample.</p>
<p>The appeal here is that your covariates will then have distributions that are much more authentic than some multivariate normal–they will include both continuous and categorical variables, they will tend to be skewed, and they will be correlated in different ways that are more interesting than anything someone could make up.</p>
<p>As an illustration of this approach, an old paper on heteroscedasticity-robust standard errors (Long and Irvin, 2000) does something similar.
It was important in the context that they’re studying because the behavior of heteroscedasticity-robust SEs is influenced by leverage, which is a function of the covariate distribution.
Getting authentic leverage was hard to do with a parametric model, so getting examples of it from real life made the simulation more relevant.</p>
</div>
<div id="fully-calibrated-simulations" class="section level3 hasAnchor" number="19.1.5">
<h3 class="hasAnchor"><span class="header-section-number">19.1.5</span> Fully calibrated simulations<a href="#fully-calibrated-simulations" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Extending some of the prior ideas even further, one practice in increasing vogue is to generate <em>calibrated simulations</em>.
These are simulations tailored to a specific applied contexts, where we design our simulation study to more narrowly inform what assumptions and structures are necessary in order to make progress in that specific context.</p>
<p>Often we would do this by building our simulations out of existing data.
For an example from above, one might sample, with replacement, from the covariate distribution of an actual dataset so that the distribution of covariates is authentic in how the covariates are distributed and, more importantly, how they co-relate.</p>
<p>But this is not far enough.
We also need to generate a realistic relationship between our covariates and outcome to truly assess how well the estimators work in practice.
It is very easy to accidentally put a very simple model in place for this final component, thus making a calibrated simulation quite naive in, perhaps, the very way that counts.</p>
<p>We next walk through how you might calibrate further in the context of evaluating estimators for some sort of causal inference context where we are assessing methods of estimating a treatment effect of some binary treatment.
If we just resample our covariates, but then layer a constant treatment effect on top, we may be missing critical aspects of how our estimators might fail in practice.</p>
<p>In the area of causal inference, the potential outcomes framework provides a natural path for generating calibrated simulations <span class="citation">(<a href="#ref-Kern_calibrated">Kern et al. 2014</a>)</span>.
Also see @ref(potential-outcomes) for more discussion of simulations in the potential outcomes framework.
Under this framework, we would take an existing randomized experiment or observational study and then impute all the missing potential outcomes under some specific scheme.
This fully defines the sample of interest and thus any target parameters, such as a measure of heterogeneity, are then fully known.
For our simulation we then synthetically, and repeatedly, randomize and ``observe’’ outcomes to be analyzed with the methods we are testing.
We could also resample from our dataset to generate datasets of different size, or to have a superpopulation target as our estimand.</p>
<p>The key feature here is the imputation step: how do we build our full set of covariates and outcomes?
One baseline method one can use is to generate a matched-pairs dataset by, for each unit, finding a close match given all the demographic and other covariate information of the sample. We then use the matched unit as the imputed potential outcome.<br />
By doing this (with replacement) for all units we can generate a fully imputed dataset which we then use as our population, with all outcomes being “real,” as they are taken from actual data.
Such matching can preserve complex relationships in the data that are not model dependent.
In particular, if outcomes tend to be coarsely defined (e.g., on an integer scale) or have specific clumps (such as zero-inflation or rounding), this structure will be preserved.</p>
<p>One concern with this approach is the noise in the matching could in general dilute the structure of the treatment effect as the control- and treatment-side potential outcomes may be very unrelated, creating a lot of so-called idiosyncratic treatment variation (unit-to-unit variation in the treatment effects that is not explained by the covariates).
This is akin to measurement error diluting found relationships in linear models.
We could reduce such variation by first imputing missing outcomes using some model (e.g., a random forest) fit to the original data, and then matching on all units including the imputed potential outcome as a hidden “covariate.”
This is not a data analysis strategy, but instead a method of generating synthetic data that both has a given structure of interest and also remains faithful to the idiosyncrasies of an actual dataset.</p>
<p>A second approach that allows for varying the level of a systematic effect is to specify a treatment effect model, predict treatment effects for all units and use those to impute the treatment potential outcome for all control units.
This will perfectly preserve the complex structure between the covariates and the <span class="math inline">\(Y_i(0)\)</span>s.
Unfortunately, this would also give no idiosyncratic treatment variation .
To add in idiosyncratic variation we could then need to generate a distribution of perturbations and add these to the imputed outcomes just as an error term in a regression model.</p>
<p>Regardless of how we generate them, once we have a “fully observed” sample with the full set of treatment and control potential outcomes for all of our units, we can calculate any target estimands we like on our population, and then compare our estimators to these ground truths (even if they have no parametric analog) as desired.</p>
<p>Clearly, these calibration games can be fairly complex.
They do not lend themselves to a clear factor-based structure that have levers that change targeted aspects of the data generating process (although sometimes you can build in controls to make such levers possible).
In exchange, we end up with a simulation that might be more faithfully capturing aspects of a specific context, making our simulations more relevant to answering the narrower question of “how will things work here?”</p>
<!--chapter:end:130-calibrated-simulations.Rmd-->
</div>
</div>
</div>
<div id="part-complex-data-structures" class="section level1 unnumbered hasAnchor">
<h1 class="unnumbered hasAnchor">(PART) Complex Data Structures<a href="#part-complex-data-structures" class="anchor-section" aria-label="Anchor link to header"></a></h1>
</div>
<div id="using-simulation-as-a-power-calculator" class="section level1 hasAnchor" number="20">
<h1 class="hasAnchor"><span class="header-section-number">20</span> Using simulation as a power calculator<a href="#using-simulation-as-a-power-calculator" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p>We can use simulation as a power calculator.
In particular, to estimate power, we generate data according to our best guess as to what we might find in a planned evaluation, and then analyze these synthetic data and see if we detect the effect we built into our DGP.
We then do this repeatedly, and see how often we detect our effect.
This is power.</p>
<p>Now, if we are generally right about our guesses about our DGP and the associated parameters we plugged into it, in terms of some planned study, then our power will be right on.
This is all a power analysis is, using simulation or otherwise.</p>
<p>Simulation has benefits over using power calculators because we can take into account odd aspects of our modeling, and also do non-standard approaches to evaluation that we might not find in a normal power calculator.</p>
<p>We illustrate this idea with a case study.
In this example, we are planning a school-level intervention to reduce rates of discipline via a socio-emotional targeting intervention on both teachers and students, where we have strongly predictive historic data and a time-series component.
This is a planned RCT, where we will treat entire schools (so a cluster-randomized study).
We are struggling because treating each school is very expensive (we have to run a large training and coaching of the staff), so each unit is a major decision.
We want something like 4, 5, or maybe 6 treated schools.
Our diving question is: Can we get away with this?</p>
<div id="getting-design-parameters-from-pilot-data" class="section level2 hasAnchor" number="20.1">
<h2 class="hasAnchor"><span class="header-section-number">20.1</span> Getting design parameters from pilot data<a href="#getting-design-parameters-from-pilot-data" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>We had pilot data from school administrative records (in particular discipline rates for each school and year for a series of five years), and we use those to estimate parameters to plug into our simulation.
We assume our experimental sample will be on schools that have chronic issues
with discipline, so we filtered our historic data to get schools we imagined to likely be in our study.</p>
<p>We ended up with the following data, with log-transformed discipline rates for each year (we did this to put things on a multiplicative scale, and to make our data more normal given heavy skew in the original). Each row is a potential school in the district.</p>
<div class="sourceCode" id="cb570"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb570-1"><a href="#cb570-1" tabindex="-1"></a>datW <span class="ot">=</span> <span class="fu">read_csv</span>( <span class="st">&quot;data/discipline_data.csv&quot;</span> )</span></code></pre></div>
<pre><code>## Rows: 27 Columns: 6
## ── Column specification ──────────────────────────
## Delimiter: &quot;,&quot;
## chr (1): Code
## dbl (5): 2015, 2016, 2017, 2018, 2019
## 
## ℹ Use `spec()` to retrieve the full column specification for this data.
## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.</code></pre>
<div class="sourceCode" id="cb572"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb572-1"><a href="#cb572-1" tabindex="-1"></a>datW</span></code></pre></div>
<pre><code>## # A tibble: 27 × 6
##    Code  `2015` `2016` `2017` `2018` `2019`
##    &lt;chr&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;
##  1 S1     -2.87  -2.81  -2.93  -3.52  -4.90
##  2 S2     -3.60  -2.83  -2.56  -2.76  -3.32
##  3 S3     -3.00  -2.88  -2.81  -3.39  -4.91
##  4 S4     -3.90  -3.20  -2.53  -3.67  -4.34
##  5 S5     -2.46  -2.00  -3.34  -3.66  -4.71
##  6 S6     -2.86  -2.74  -2.51  -3.21  -3.80
##  7 S7     -2.47  -2.59  -2.69  -2.15  -2.43
##  8 S8     -2.13  -1.93  -1.82  -2.21  -2.95
##  9 S9     -3.36  -3.16  -3.06  -3.26  -3.10
## 10 S10    -2.89  -2.54  -2.26  -2.89  -3.25
## # ℹ 17 more rows</code></pre>
<p>We use these to calculate a mean and covariance structure for generating data:</p>
<div class="sourceCode" id="cb574"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb574-1"><a href="#cb574-1" tabindex="-1"></a>lpd_mns <span class="ot">=</span> <span class="fu">apply</span>( datW[,<span class="sc">-</span><span class="dv">1</span>], <span class="dv">2</span>, mean )</span>
<span id="cb574-2"><a href="#cb574-2" tabindex="-1"></a>lpd_mns</span></code></pre></div>
<pre><code>##      2015      2016      2017      2018      2019 
## -3.076298 -2.868337 -2.931562 -3.337221 -4.011440</code></pre>
<div class="sourceCode" id="cb576"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb576-1"><a href="#cb576-1" tabindex="-1"></a>lpd_cov <span class="ot">=</span> <span class="fu">cov</span>( datW[,<span class="sc">-</span><span class="dv">1</span>] )</span>
<span id="cb576-2"><a href="#cb576-2" tabindex="-1"></a>lpd_cov</span></code></pre></div>
<pre><code>##           2015      2016      2017      2018
## 2015 0.4191843 0.2996073 0.2282627 0.3691894
## 2016 0.2996073 0.3656335 0.2014201 0.2511376
## 2017 0.2282627 0.2014201 0.3084799 0.2927782
## 2018 0.3691894 0.2511376 0.2927782 0.5767486
## 2019 0.1921622 0.1623542 0.2541191 0.2927812
##           2019
## 2015 0.1921622
## 2016 0.1623542
## 2017 0.2541191
## 2018 0.2927812
## 2019 0.5425783</code></pre>
</div>
<div id="the-data-generating-process-1" class="section level2 hasAnchor" number="20.2">
<h2 class="hasAnchor"><span class="header-section-number">20.2</span> The data generating process<a href="#the-data-generating-process-1" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>We then write a data generator that, given a desired number of control and treatment schools, and a treatment effect, makes a dataset by sampling vectors of discipline rates, and then imposes a “treatment effect” of scaling the discipline rate by the treatment coefficient for the last two years.</p>
<div class="sourceCode" id="cb578"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb578-1"><a href="#cb578-1" tabindex="-1"></a>make_dat_param <span class="ot">=</span> <span class="cf">function</span>( n_c, n_t, <span class="at">tx=</span><span class="dv">1</span> ) {</span>
<span id="cb578-2"><a href="#cb578-2" tabindex="-1"></a>    n <span class="ot">=</span> n_c <span class="sc">+</span> n_t</span>
<span id="cb578-3"><a href="#cb578-3" tabindex="-1"></a>    lpdisc <span class="ot">=</span> MASS<span class="sc">::</span><span class="fu">mvrnorm</span>( n, <span class="at">mu =</span> lpd_mns, <span class="at">Sigma =</span> lpd_cov )</span>
<span id="cb578-4"><a href="#cb578-4" tabindex="-1"></a>    lpdisc <span class="ot">=</span> <span class="fu">exp</span>( lpdisc )</span>
<span id="cb578-5"><a href="#cb578-5" tabindex="-1"></a>    <span class="fu">colnames</span>( lpdisc ) <span class="ot">=</span> <span class="fu">paste0</span>( <span class="st">&quot;pdisc_&quot;</span>, <span class="fu">colnames</span>( lpdisc ) )</span>
<span id="cb578-6"><a href="#cb578-6" tabindex="-1"></a>    lpdisc <span class="ot">=</span> <span class="fu">as.data.frame</span>( lpdisc ) <span class="sc">%&gt;%</span></span>
<span id="cb578-7"><a href="#cb578-7" tabindex="-1"></a>        <span class="fu">mutate</span>( <span class="at">ID =</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">n</span>(),</span>
<span id="cb578-8"><a href="#cb578-8" tabindex="-1"></a>                <span class="at">Z =</span> <span class="dv">0</span> <span class="sc">+</span> ( <span class="fu">sample</span>( n ) <span class="sc">&lt;=</span> n_t ) )</span>
<span id="cb578-9"><a href="#cb578-9" tabindex="-1"></a>    </span>
<span id="cb578-10"><a href="#cb578-10" tabindex="-1"></a>    <span class="co"># Add in treatment effect</span></span>
<span id="cb578-11"><a href="#cb578-11" tabindex="-1"></a>    lpdisc <span class="ot">=</span> <span class="fu">mutate</span>( lpdisc, </span>
<span id="cb578-12"><a href="#cb578-12" tabindex="-1"></a>                     <span class="at">pdisc_2018 =</span> pdisc_2018 <span class="sc">*</span> <span class="fu">ifelse</span>( Z <span class="sc">==</span> <span class="dv">1</span>, tx, <span class="dv">1</span> ),</span>
<span id="cb578-13"><a href="#cb578-13" tabindex="-1"></a>                     <span class="at">pdisc_2019 =</span> pdisc_2019 <span class="sc">*</span> <span class="fu">ifelse</span>( Z <span class="sc">==</span> <span class="dv">1</span>, tx, <span class="dv">1</span> ) )</span>
<span id="cb578-14"><a href="#cb578-14" tabindex="-1"></a> </span>
<span id="cb578-15"><a href="#cb578-15" tabindex="-1"></a>    lpdisc <span class="sc">%&gt;%</span> </span>
<span id="cb578-16"><a href="#cb578-16" tabindex="-1"></a>      <span class="fu">relocate</span>( ID, Z )</span>
<span id="cb578-17"><a href="#cb578-17" tabindex="-1"></a>}</span></code></pre></div>
<p>Our function generates schools with discipline given by the provided mean and covariance structure; we have calibrated our data generating process to give us data that looks very similar to the data we would see in the field.</p>
<p>For our impact model, the treatment kicks in for the final two years, multiplying discipline rate by <code>tx</code> (so <code>tx = 1</code> means no treatment effect).</p>
<p>Testing our function gives this:</p>
<div class="sourceCode" id="cb579"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb579-1"><a href="#cb579-1" tabindex="-1"></a><span class="fu">set.seed</span>( <span class="dv">59585</span> )</span>
<span id="cb579-2"><a href="#cb579-2" tabindex="-1"></a>a <span class="ot">=</span> <span class="fu">make_dat_param</span>( <span class="dv">100</span>, <span class="dv">100</span>, <span class="fl">0.5</span> )  </span>
<span id="cb579-3"><a href="#cb579-3" tabindex="-1"></a><span class="fu">head</span>( a, <span class="at">n =</span> <span class="dv">4</span> )</span></code></pre></div>
<pre><code>##   ID Z pdisc_2015 pdisc_2016 pdisc_2017
## 1  1 1 0.03118036 0.05594299 0.03283595
## 2  2 1 0.04209213 0.01716175 0.02388633
## 3  3 1 0.18736890 0.26266248 0.14379326
## 4  4 0 0.04389430 0.04571297 0.03378810
##   pdisc_2018  pdisc_2019
## 1 0.01051475 0.005732411
## 2 0.01155785 0.009120705
## 3 0.04832345 0.027621311
## 4 0.01101846 0.007154335</code></pre>
<p>We can group each treatment arm and look at discipline over the years:</p>
<div class="sourceCode" id="cb581"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb581-1"><a href="#cb581-1" tabindex="-1"></a>  aL <span class="ot">=</span> a <span class="sc">%&gt;%</span> </span>
<span id="cb581-2"><a href="#cb581-2" tabindex="-1"></a>        <span class="fu">pivot_longer</span>( pdisc_2015<span class="sc">:</span>pdisc_2019, </span>
<span id="cb581-3"><a href="#cb581-3" tabindex="-1"></a>                      <span class="at">names_to =</span> <span class="fu">c</span>( <span class="st">&quot;.value&quot;</span>, <span class="st">&quot;year&quot;</span> ),</span>
<span id="cb581-4"><a href="#cb581-4" tabindex="-1"></a>                      <span class="at">names_pattern =</span> <span class="st">&quot;(.*)_(.*)&quot;</span> ) <span class="sc">%&gt;%</span></span>
<span id="cb581-5"><a href="#cb581-5" tabindex="-1"></a>        <span class="fu">mutate</span>( <span class="at">year =</span> <span class="fu">as.numeric</span>( year ) )</span>
<span id="cb581-6"><a href="#cb581-6" tabindex="-1"></a>    </span>
<span id="cb581-7"><a href="#cb581-7" tabindex="-1"></a>    aLg <span class="ot">=</span> aL <span class="sc">%&gt;%</span> <span class="fu">group_by</span>( year, Z ) <span class="sc">%&gt;%</span></span>
<span id="cb581-8"><a href="#cb581-8" tabindex="-1"></a>        <span class="fu">summarise</span>( <span class="at">pdisc =</span> <span class="fu">mean</span>( pdisc ) )</span>
<span id="cb581-9"><a href="#cb581-9" tabindex="-1"></a>    <span class="fu">ggplot</span>( aLg, <span class="fu">aes</span>( year, pdisc, <span class="at">col=</span><span class="fu">as.factor</span>(Z) ) ) <span class="sc">+</span></span>
<span id="cb581-10"><a href="#cb581-10" tabindex="-1"></a>        <span class="fu">geom_line</span>() <span class="sc">+</span></span>
<span id="cb581-11"><a href="#cb581-11" tabindex="-1"></a>      <span class="fu">labs</span>( <span class="at">color =</span> <span class="st">&quot;Tx?&quot;</span> )</span></code></pre></div>
<p><img src="Designing-Simulations-in-R_files/figure-html/unnamed-chunk-306-1.png" width="75%" style="display: block; margin: auto;" /></p>
<p>Our treatment group drops faster than the control. We see the nonlinear structure actually observed in our original data in terms of discipline over time has been replicated.</p>
<p>We next write some functions to analyze our data.
This should feel very familiar: we are just doing our simulation framework, as usual.</p>
<div class="sourceCode" id="cb582"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb582-1"><a href="#cb582-1" tabindex="-1"></a>eval_dat <span class="ot">=</span> <span class="cf">function</span>( sdat ) {</span>
<span id="cb582-2"><a href="#cb582-2" tabindex="-1"></a>    </span>
<span id="cb582-3"><a href="#cb582-3" tabindex="-1"></a>    <span class="co"># No covariate adjustment, average change model (on log outcome)</span></span>
<span id="cb582-4"><a href="#cb582-4" tabindex="-1"></a>    M_raw <span class="ot">=</span> <span class="fu">lm</span>( <span class="fu">log</span>( pdisc_2018 ) <span class="sc">~</span> <span class="dv">1</span> <span class="sc">+</span> Z, <span class="at">data=</span>sdat )</span>
<span id="cb582-5"><a href="#cb582-5" tabindex="-1"></a></span>
<span id="cb582-6"><a href="#cb582-6" tabindex="-1"></a>    <span class="co"># Simple average change model using 2018 as outcome.</span></span>
<span id="cb582-7"><a href="#cb582-7" tabindex="-1"></a>    M_simple <span class="ot">=</span> <span class="fu">lm</span>( pdisc_2018 <span class="sc">~</span> <span class="dv">1</span> <span class="sc">+</span> Z <span class="sc">+</span> pdisc_2017 <span class="sc">+</span> pdisc_2016 <span class="sc">+</span> pdisc_2015,</span>
<span id="cb582-8"><a href="#cb582-8" tabindex="-1"></a>                   <span class="at">data=</span>sdat )</span>
<span id="cb582-9"><a href="#cb582-9" tabindex="-1"></a></span>
<span id="cb582-10"><a href="#cb582-10" tabindex="-1"></a>    <span class="co"># Simple model on logged outcome</span></span>
<span id="cb582-11"><a href="#cb582-11" tabindex="-1"></a>    M_log <span class="ot">=</span> <span class="fu">lm</span>( <span class="fu">log</span>( pdisc_2018 ) <span class="sc">~</span> <span class="dv">1</span> <span class="sc">+</span> Z <span class="sc">+</span> <span class="fu">log</span>( pdisc_2017) <span class="sc">+</span> <span class="fu">log</span>( pdisc_2016) <span class="sc">+</span> <span class="fu">log</span>( pdisc_2015 ),</span>
<span id="cb582-12"><a href="#cb582-12" tabindex="-1"></a>                <span class="at">data=</span>sdat )</span>
<span id="cb582-13"><a href="#cb582-13" tabindex="-1"></a>    </span>
<span id="cb582-14"><a href="#cb582-14" tabindex="-1"></a>    <span class="co"># Ratio of average disc to average prior disc as outcome</span></span>
<span id="cb582-15"><a href="#cb582-15" tabindex="-1"></a>    sdat <span class="ot">=</span> <span class="fu">mutate</span>( sdat,</span>
<span id="cb582-16"><a href="#cb582-16" tabindex="-1"></a>                   <span class="at">avg_disc =</span> (pdisc_2018 <span class="sc">+</span> pdisc_2019)<span class="sc">/</span><span class="dv">2</span>,</span>
<span id="cb582-17"><a href="#cb582-17" tabindex="-1"></a>                   <span class="at">prior_disc =</span> (pdisc_2017 <span class="sc">+</span> pdisc_2016 <span class="sc">+</span> pdisc_2015 )<span class="sc">/</span><span class="dv">3</span>,</span>
<span id="cb582-18"><a href="#cb582-18" tabindex="-1"></a>                   <span class="at">disc =</span> pdisc_2018 <span class="sc">/</span> prior_disc,</span>
<span id="cb582-19"><a href="#cb582-19" tabindex="-1"></a>                   <span class="at">disc_two =</span> avg_disc <span class="sc">/</span> prior_disc )</span>
<span id="cb582-20"><a href="#cb582-20" tabindex="-1"></a>    M_ratio <span class="ot">=</span> <span class="fu">lm</span>( disc <span class="sc">~</span> <span class="dv">1</span> <span class="sc">+</span> Z, <span class="at">data =</span> sdat )</span>
<span id="cb582-21"><a href="#cb582-21" tabindex="-1"></a>    M_ratio_twopost <span class="ot">=</span> <span class="fu">lm</span>( disc_two <span class="sc">~</span> <span class="dv">1</span> <span class="sc">+</span> Z, <span class="at">data =</span> sdat )</span>
<span id="cb582-22"><a href="#cb582-22" tabindex="-1"></a>    </span>
<span id="cb582-23"><a href="#cb582-23" tabindex="-1"></a>    <span class="co"># Use average of two post-tx time periods, averaged to reduce noise</span></span>
<span id="cb582-24"><a href="#cb582-24" tabindex="-1"></a>    M_twopost <span class="ot">=</span> <span class="fu">lm</span>( <span class="fu">log</span>( avg_disc ) <span class="sc">~</span> <span class="dv">1</span> <span class="sc">+</span> Z <span class="sc">+</span> <span class="fu">log</span>( pdisc_2017 ) <span class="sc">+</span> <span class="fu">log</span>( pdisc_2016 ) <span class="sc">+</span> <span class="fu">log</span>( pdisc_2015 ), <span class="at">data=</span>sdat )</span>
<span id="cb582-25"><a href="#cb582-25" tabindex="-1"></a></span>
<span id="cb582-26"><a href="#cb582-26" tabindex="-1"></a>    <span class="co"># Time and unit fixed effects</span></span>
<span id="cb582-27"><a href="#cb582-27" tabindex="-1"></a>    sdatL <span class="ot">=</span> <span class="fu">pivot_longer</span>( sdat, <span class="at">cols =</span> pdisc_2015<span class="sc">:</span>pdisc_2019, </span>
<span id="cb582-28"><a href="#cb582-28" tabindex="-1"></a>                          <span class="at">names_to =</span> <span class="st">&quot;year&quot;</span>,</span>
<span id="cb582-29"><a href="#cb582-29" tabindex="-1"></a>                          <span class="at">values_to =</span> <span class="st">&quot;pdisc&quot;</span> ) <span class="sc">%&gt;%</span></span>
<span id="cb582-30"><a href="#cb582-30" tabindex="-1"></a>        <span class="fu">mutate</span>( <span class="at">Z =</span> Z <span class="sc">*</span> (year <span class="sc">%in%</span> <span class="fu">c</span>( <span class="st">&quot;pdisc_2018&quot;</span>, <span class="st">&quot;pdisc_2019&quot;</span> ) ),</span>
<span id="cb582-31"><a href="#cb582-31" tabindex="-1"></a>                <span class="at">ID =</span> <span class="fu">paste0</span>( <span class="st">&quot;S&quot;</span>, ID ) )</span>
<span id="cb582-32"><a href="#cb582-32" tabindex="-1"></a>    </span>
<span id="cb582-33"><a href="#cb582-33" tabindex="-1"></a>    M_2wfe <span class="ot">=</span> <span class="fu">lm</span>( <span class="fu">log</span>( pdisc ) <span class="sc">~</span> <span class="dv">0</span> <span class="sc">+</span> ID <span class="sc">+</span> year <span class="sc">+</span> Z,</span>
<span id="cb582-34"><a href="#cb582-34" tabindex="-1"></a>                 <span class="at">data=</span>sdatL )</span>
<span id="cb582-35"><a href="#cb582-35" tabindex="-1"></a></span>
<span id="cb582-36"><a href="#cb582-36" tabindex="-1"></a>    <span class="co"># Bundle all our models by getting the estimated treatment impact</span></span>
<span id="cb582-37"><a href="#cb582-37" tabindex="-1"></a>    <span class="co"># from each.</span></span>
<span id="cb582-38"><a href="#cb582-38" tabindex="-1"></a>    models <span class="ot">&lt;-</span> <span class="fu">list</span>( <span class="at">raw=</span>M_raw, <span class="at">simple=</span>M_simple,</span>
<span id="cb582-39"><a href="#cb582-39" tabindex="-1"></a>                       <span class="at">log=</span>M_log, <span class="at">ratio =</span> M_ratio, </span>
<span id="cb582-40"><a href="#cb582-40" tabindex="-1"></a>                       <span class="at">ratio_twopost =</span> M_ratio_twopost,</span>
<span id="cb582-41"><a href="#cb582-41" tabindex="-1"></a>                       <span class="at">log_twopost =</span> M_twopost, </span>
<span id="cb582-42"><a href="#cb582-42" tabindex="-1"></a>                       <span class="at">FE =</span> M_2wfe )</span>
<span id="cb582-43"><a href="#cb582-43" tabindex="-1"></a>    rs <span class="ot">&lt;-</span> <span class="fu">map_df</span>( models, broom<span class="sc">::</span>tidy, <span class="at">.id=</span><span class="st">&quot;model&quot;</span> ) <span class="sc">%&gt;%</span></span>
<span id="cb582-44"><a href="#cb582-44" tabindex="-1"></a>        <span class="fu">filter</span>( term<span class="sc">==</span><span class="st">&quot;Z&quot;</span> ) <span class="sc">%&gt;%</span></span>
<span id="cb582-45"><a href="#cb582-45" tabindex="-1"></a>        dplyr<span class="sc">::</span><span class="fu">select</span>( <span class="sc">-</span>term ) <span class="sc">%&gt;%</span></span>
<span id="cb582-46"><a href="#cb582-46" tabindex="-1"></a>      <span class="fu">arrange</span>( model )</span>
<span id="cb582-47"><a href="#cb582-47" tabindex="-1"></a>    </span>
<span id="cb582-48"><a href="#cb582-48" tabindex="-1"></a>    rs</span>
<span id="cb582-49"><a href="#cb582-49" tabindex="-1"></a>}</span></code></pre></div>
<p>Our method marches through a host of models; we weren’t sure what the gains would be from one model to another, so we decided to conduct power analyses on all of them.
Again, we look at what our evaluation function does:</p>
<div class="sourceCode" id="cb583"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb583-1"><a href="#cb583-1" tabindex="-1"></a>dat <span class="ot">=</span> <span class="fu">make_dat_param</span>( <span class="at">n_c =</span> <span class="dv">4</span>, <span class="at">n_t =</span> <span class="dv">4</span>, <span class="at">tx =</span> <span class="fl">0.5</span> )</span>
<span id="cb583-2"><a href="#cb583-2" tabindex="-1"></a><span class="fu">eval_dat</span>( dat )</span></code></pre></div>
<pre><code>## # A tibble: 7 × 5
##   model       estimate std.error statistic p.value
##   &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;
## 1 FE          -0.644      0.325     -1.98   0.0576
## 2 log         -0.841      0.478     -1.76   0.176 
## 3 log_twopost -1.22       0.437     -2.80   0.0680
## 4 ratio       -0.126      0.136     -0.923  0.392 
## 5 ratio_twop… -0.269      0.139     -1.93   0.102 
## 6 raw         -0.650      0.300     -2.17   0.0733
## 7 simple      -0.00983    0.0133    -0.742  0.512</code></pre>
<p>We have a nice set of estimates, one for each model.</p>
</div>
<div id="running-the-simulation-1" class="section level2 hasAnchor" number="20.3">
<h2 class="hasAnchor"><span class="header-section-number">20.3</span> Running the simulation<a href="#running-the-simulation-1" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Now we put it all together in our classic simulator:</p>
<div class="sourceCode" id="cb585"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb585-1"><a href="#cb585-1" tabindex="-1"></a>sim_run <span class="ot">=</span> <span class="cf">function</span>( n_c, n_t, tx, R, <span class="at">seed =</span> <span class="cn">NULL</span> ) {</span>
<span id="cb585-2"><a href="#cb585-2" tabindex="-1"></a>    <span class="cf">if</span> ( <span class="sc">!</span><span class="fu">is.null</span>( seed ) ) {</span>
<span id="cb585-3"><a href="#cb585-3" tabindex="-1"></a>        <span class="fu">set.seed</span>(seed)</span>
<span id="cb585-4"><a href="#cb585-4" tabindex="-1"></a>    }</span>
<span id="cb585-5"><a href="#cb585-5" tabindex="-1"></a>    <span class="fu">cat</span>( <span class="st">&quot;Running n_c, n_t =&quot;</span>, n_c, n_t, <span class="st">&quot;tx =&quot;</span>, tx, <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> )</span>
<span id="cb585-6"><a href="#cb585-6" tabindex="-1"></a>    rps <span class="ot">=</span> <span class="fu">rerun</span>( R, {</span>
<span id="cb585-7"><a href="#cb585-7" tabindex="-1"></a>        sdat <span class="ot">=</span> <span class="fu">make_dat_param</span>(<span class="at">n_c =</span> n_c, <span class="at">n_t =</span> n_t, <span class="at">tx =</span> tx)</span>
<span id="cb585-8"><a href="#cb585-8" tabindex="-1"></a>        <span class="fu">eval_dat</span>( sdat )</span>
<span id="cb585-9"><a href="#cb585-9" tabindex="-1"></a>    })</span>
<span id="cb585-10"><a href="#cb585-10" tabindex="-1"></a>    <span class="fu">bind_rows</span>( rps )</span>
<span id="cb585-11"><a href="#cb585-11" tabindex="-1"></a>}</span></code></pre></div>
<p>We then do the usual to run across a set of scenarios, running <code>sim_run</code> on each row of the following:</p>
<div class="sourceCode" id="cb586"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb586-1"><a href="#cb586-1" tabindex="-1"></a>res <span class="ot">=</span> <span class="fu">expand_grid</span>( <span class="at">tx =</span> <span class="fu">c</span>( <span class="dv">1</span>, <span class="fl">0.75</span>, <span class="fl">0.5</span> ),</span>
<span id="cb586-2"><a href="#cb586-2" tabindex="-1"></a>                   <span class="at">n_c =</span> <span class="fu">c</span>( <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">8</span>, <span class="dv">12</span>, <span class="dv">20</span> ),</span>
<span id="cb586-3"><a href="#cb586-3" tabindex="-1"></a>                   <span class="at">n_t =</span> <span class="fu">c</span>( <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span> ) )</span>
<span id="cb586-4"><a href="#cb586-4" tabindex="-1"></a>res<span class="sc">$</span>R <span class="ot">=</span> <span class="dv">1000</span></span>
<span id="cb586-5"><a href="#cb586-5" tabindex="-1"></a>res<span class="sc">$</span>seed <span class="ot">=</span> <span class="dv">1010203</span> <span class="sc">+</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(res)</span></code></pre></div>
<p>For evaluation, we load our saved results and calculate rejection rates (we use an alpha of 0.10 since we are doing one-sided testing):</p>
<div class="sourceCode" id="cb587"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb587-1"><a href="#cb587-1" tabindex="-1"></a>res <span class="ot">=</span> <span class="fu">readRDS</span>( <span class="at">file=</span><span class="st">&quot;data/discipline_simulation.rds&quot;</span> )</span>
<span id="cb587-2"><a href="#cb587-2" tabindex="-1"></a></span>
<span id="cb587-3"><a href="#cb587-3" tabindex="-1"></a>sres <span class="ot">&lt;-</span> res <span class="sc">%&gt;%</span> <span class="fu">group_by</span>( n_c, n_t, tx, model ) <span class="sc">%&gt;%</span></span>
<span id="cb587-4"><a href="#cb587-4" tabindex="-1"></a>    <span class="fu">summarise</span>( <span class="at">E_est =</span> <span class="fu">mean</span>( estimate ),</span>
<span id="cb587-5"><a href="#cb587-5" tabindex="-1"></a>               <span class="at">SE =</span> <span class="fu">sd</span>( estimate ),</span>
<span id="cb587-6"><a href="#cb587-6" tabindex="-1"></a>               <span class="at">E_SE_hat =</span> <span class="fu">mean</span>( std.error ),</span>
<span id="cb587-7"><a href="#cb587-7" tabindex="-1"></a>               <span class="at">pow =</span> <span class="fu">mean</span>( p.value <span class="sc">&lt;=</span> <span class="fl">0.10</span> ) ) <span class="co"># one-sided testing</span></span>
<span id="cb587-8"><a href="#cb587-8" tabindex="-1"></a>sres</span></code></pre></div>
<pre><code>## # A tibble: 378 × 8
## # Groups:   n_c, n_t, tx [54]
##      n_c   n_t    tx model   E_est     SE E_SE_hat
##    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;
##  1     4     4  0.5  FE    -0.693  0.313    0.277 
##  2     4     4  0.5  log   -0.694  0.476    0.430 
##  3     4     4  0.5  log_… -0.692  0.431    0.383 
##  4     4     4  0.5  ratio -0.374  0.219    0.203 
##  5     4     4  0.5  rati… -0.291  0.151    0.139 
##  6     4     4  0.5  raw   -0.719  0.535    0.515 
##  7     4     4  0.5  simp… -0.0195 0.0194   0.0157
##  8     4     4  0.75 FE    -0.292  0.310    0.274 
##  9     4     4  0.75 log   -0.295  0.488    0.435 
## 10     4     4  0.75 log_… -0.305  0.424    0.373 
## # ℹ 368 more rows
## # ℹ 1 more variable: pow &lt;dbl&gt;</code></pre>
</div>
<div id="evaluating-power" class="section level2 hasAnchor" number="20.4">
<h2 class="hasAnchor"><span class="header-section-number">20.4</span> Evaluating power<a href="#evaluating-power" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Once our simulation is run, we can explore power as a function of the design characteristics.
In particular, we eventually want to calculate the chance of noticing effects of different sizes, given various sample sizes we might employ.
Our driving question is how few schools on the treated side can we get away with?
Also, we want to know how much having more schools on the control side allows us to get away with fewer schools on the treated side.</p>
<div id="checking-validity-of-our-models" class="section level3 hasAnchor" number="20.4.1">
<h3 class="hasAnchor"><span class="header-section-number">20.4.1</span> Checking validity of our models<a href="#checking-validity-of-our-models" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Before we look at power, we need to check on whether our different models are valid.
This is especiallt important as we are in a small <span class="math inline">\(n\)</span> context, so we know asymptotics may not hold as they should.
To check our models for validity we subset our trials to where <code>tx = 1</code>, and look at the rejection rates.</p>
<p>We first run a regression to see if rejection is a function of sample size (are smaller samples more invalid) and treatment-control imbalance.
We center both variables so our intercepts are overall average rejection rates for each model considered:</p>
<div class="sourceCode" id="cb589"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb589-1"><a href="#cb589-1" tabindex="-1"></a>sres <span class="ot">=</span> <span class="fu">mutate</span>( sres,</span>
<span id="cb589-2"><a href="#cb589-2" tabindex="-1"></a>               <span class="at">n =</span> n_c <span class="sc">+</span> n_t,</span>
<span id="cb589-3"><a href="#cb589-3" tabindex="-1"></a>               <span class="at">imbalance =</span> <span class="fu">pmax</span>( n_t <span class="sc">/</span> n_c, n_c <span class="sc">/</span> n_t ) <span class="sc">-</span> <span class="dv">1</span> )</span>
<span id="cb589-4"><a href="#cb589-4" tabindex="-1"></a>sres<span class="sc">$</span>n <span class="ot">=</span> (sres<span class="sc">$</span>n <span class="sc">-</span> <span class="fu">mean</span>(sres<span class="sc">$</span>n)) <span class="sc">/</span> <span class="fu">sd</span>(sres<span class="sc">$</span>n)</span>
<span id="cb589-5"><a href="#cb589-5" tabindex="-1"></a>mod <span class="ot">=</span> <span class="fu">lm</span>( pow <span class="sc">~</span> <span class="dv">0</span> <span class="sc">+</span> (n <span class="sc">+</span> imbalance) <span class="sc">*</span> model <span class="sc">-</span> n <span class="sc">-</span> imbalance,</span>
<span id="cb589-6"><a href="#cb589-6" tabindex="-1"></a>          <span class="at">data =</span> <span class="fu">filter</span>( sres, tx <span class="sc">==</span> <span class="dv">1</span> ) )</span>
<span id="cb589-7"><a href="#cb589-7" tabindex="-1"></a>broom<span class="sc">::</span><span class="fu">tidy</span>(mod) <span class="sc">%&gt;%</span></span>
<span id="cb589-8"><a href="#cb589-8" tabindex="-1"></a>  knitr<span class="sc">::</span><span class="fu">kable</span>( <span class="at">digits =</span> <span class="dv">3</span>)</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="left">term</th>
<th align="right">estimate</th>
<th align="right">std.error</th>
<th align="right">statistic</th>
<th align="right">p.value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">modelFE</td>
<td align="right">0.143</td>
<td align="right">0.006</td>
<td align="right">24.593</td>
<td align="right">0.000</td>
</tr>
<tr class="even">
<td align="left">modellog</td>
<td align="right">0.099</td>
<td align="right">0.006</td>
<td align="right">16.999</td>
<td align="right">0.000</td>
</tr>
<tr class="odd">
<td align="left">modellog_twopost</td>
<td align="right">0.093</td>
<td align="right">0.006</td>
<td align="right">15.939</td>
<td align="right">0.000</td>
</tr>
<tr class="even">
<td align="left">modelratio</td>
<td align="right">0.090</td>
<td align="right">0.006</td>
<td align="right">15.437</td>
<td align="right">0.000</td>
</tr>
<tr class="odd">
<td align="left">modelratio_twopost</td>
<td align="right">0.093</td>
<td align="right">0.006</td>
<td align="right">15.967</td>
<td align="right">0.000</td>
</tr>
<tr class="even">
<td align="left">modelraw</td>
<td align="right">0.092</td>
<td align="right">0.006</td>
<td align="right">15.751</td>
<td align="right">0.000</td>
</tr>
<tr class="odd">
<td align="left">modelsimple</td>
<td align="right">0.091</td>
<td align="right">0.006</td>
<td align="right">15.571</td>
<td align="right">0.000</td>
</tr>
<tr class="even">
<td align="left">n:modelFE</td>
<td align="right">-0.003</td>
<td align="right">0.006</td>
<td align="right">-0.459</td>
<td align="right">0.647</td>
</tr>
<tr class="odd">
<td align="left">n:modellog</td>
<td align="right">0.001</td>
<td align="right">0.006</td>
<td align="right">0.141</td>
<td align="right">0.888</td>
</tr>
<tr class="even">
<td align="left">n:modellog_twopost</td>
<td align="right">-0.005</td>
<td align="right">0.006</td>
<td align="right">-0.919</td>
<td align="right">0.360</td>
</tr>
<tr class="odd">
<td align="left">n:modelratio</td>
<td align="right">0.000</td>
<td align="right">0.006</td>
<td align="right">0.071</td>
<td align="right">0.944</td>
</tr>
<tr class="even">
<td align="left">n:modelratio_twopost</td>
<td align="right">0.002</td>
<td align="right">0.006</td>
<td align="right">0.414</td>
<td align="right">0.680</td>
</tr>
<tr class="odd">
<td align="left">n:modelraw</td>
<td align="right">-0.006</td>
<td align="right">0.006</td>
<td align="right">-1.008</td>
<td align="right">0.316</td>
</tr>
<tr class="even">
<td align="left">n:modelsimple</td>
<td align="right">0.001</td>
<td align="right">0.006</td>
<td align="right">0.191</td>
<td align="right">0.849</td>
</tr>
<tr class="odd">
<td align="left">imbalance:modelFE</td>
<td align="right">0.005</td>
<td align="right">0.005</td>
<td align="right">0.857</td>
<td align="right">0.394</td>
</tr>
<tr class="even">
<td align="left">imbalance:modellog</td>
<td align="right">-0.003</td>
<td align="right">0.005</td>
<td align="right">-0.587</td>
<td align="right">0.558</td>
</tr>
<tr class="odd">
<td align="left">imbalance:modellog_twopost</td>
<td align="right">0.004</td>
<td align="right">0.005</td>
<td align="right">0.708</td>
<td align="right">0.480</td>
</tr>
<tr class="even">
<td align="left">imbalance:modelratio</td>
<td align="right">0.000</td>
<td align="right">0.005</td>
<td align="right">-0.001</td>
<td align="right">0.999</td>
</tr>
<tr class="odd">
<td align="left">imbalance:modelratio_twopost</td>
<td align="right">0.001</td>
<td align="right">0.005</td>
<td align="right">0.249</td>
<td align="right">0.804</td>
</tr>
<tr class="even">
<td align="left">imbalance:modelraw</td>
<td align="right">0.006</td>
<td align="right">0.005</td>
<td align="right">1.154</td>
<td align="right">0.251</td>
</tr>
<tr class="odd">
<td align="left">imbalance:modelsimple</td>
<td align="right">0.001</td>
<td align="right">0.005</td>
<td align="right">0.180</td>
<td align="right">0.858</td>
</tr>
</tbody>
</table>
<p>We can also plot the nominal rejection rates under the null:</p>
<div class="sourceCode" id="cb590"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb590-1"><a href="#cb590-1" tabindex="-1"></a>sres <span class="sc">%&gt;%</span> <span class="fu">filter</span>( tx <span class="sc">==</span> <span class="dv">1</span> ) <span class="sc">%&gt;%</span></span>
<span id="cb590-2"><a href="#cb590-2" tabindex="-1"></a><span class="fu">ggplot</span>( <span class="fu">aes</span>( n_c, pow, <span class="at">col=</span>model ) ) <span class="sc">+</span></span>
<span id="cb590-3"><a href="#cb590-3" tabindex="-1"></a>  <span class="fu">facet_wrap</span>( <span class="sc">~</span> n_t, <span class="at">nrow=</span><span class="dv">1</span> ) <span class="sc">+</span></span>
<span id="cb590-4"><a href="#cb590-4" tabindex="-1"></a>  <span class="fu">geom_line</span>() <span class="sc">+</span></span>
<span id="cb590-5"><a href="#cb590-5" tabindex="-1"></a>  <span class="fu">geom_hline</span>( <span class="at">yintercept =</span> <span class="fl">0.10</span> ) <span class="sc">+</span></span>
<span id="cb590-6"><a href="#cb590-6" tabindex="-1"></a>  <span class="fu">scale_x_log10</span>(<span class="at">breaks=</span><span class="fu">unique</span>(sres<span class="sc">$</span>n_c) )</span></code></pre></div>
<p><img src="Designing-Simulations-in-R_files/figure-html/unnamed-chunk-312-1.png" width="75%" style="display: block; margin: auto;" /></p>
<p>We see the fixed effect models have elevated rates of rejection.
Interestingly, these rates do not seem particularly dependent on sample size or treatment-control imbalance (note lack of significant coefficeints on our regression model).
The other models all appear valid.</p>
<p>We can also check for bias of our methods:</p>
<div class="sourceCode" id="cb591"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb591-1"><a href="#cb591-1" tabindex="-1"></a>sres <span class="sc">%&gt;%</span> <span class="fu">group_by</span>( model, tx ) <span class="sc">%&gt;%</span></span>
<span id="cb591-2"><a href="#cb591-2" tabindex="-1"></a>  <span class="fu">summarise</span>( <span class="at">E_est =</span> <span class="fu">mean</span>( E_est ) ) <span class="sc">%&gt;%</span></span>
<span id="cb591-3"><a href="#cb591-3" tabindex="-1"></a>  <span class="fu">pivot_wider</span>( <span class="at">names_from=</span><span class="st">&quot;tx&quot;</span>, <span class="at">values_from=</span><span class="st">&quot;E_est&quot;</span> )</span></code></pre></div>
<pre><code>## # A tibble: 7 × 4
## # Groups:   model [7]
##   model           `0.5`  `0.75`        `1`
##   &lt;chr&gt;           &lt;dbl&gt;   &lt;dbl&gt;      &lt;dbl&gt;
## 1 FE            -0.692  -0.290  -0.000703 
## 2 log           -0.692  -0.288   0.00120  
## 3 log_twopost   -0.692  -0.291   0.00241  
## 4 ratio         -0.372  -0.187  -0.000937 
## 5 ratio_twopost -0.289  -0.145  -0.00108  
## 6 raw           -0.694  -0.290   0.00327  
## 7 simple        -0.0206 -0.0104  0.0000998</code></pre>
<p>We see our models are estimating different things, none of which are the treatment effect as we parameterized it.
In particular, “FE,” “log,” “raw,” and “log_twopost” are all estimating the impact on the log scale.
Note that <span class="math inline">\(log( 0.5 ) \approx -0.69\)</span> and <span class="math inline">\(log( 0.75 ) \approx -0.29\)</span>.
Our “simple” estimator is estimating the impact on the absolute scale; reducing discipline rates by 50% corresponds to about a 2% reduction in actual cases.
Finally, “ratio” and “ratio_twopost” are estimating the change in the average ratio of post-policy discipline to pre; they are akin to a gain score as compared to the log regressions.</p>
</div>
<div id="assessing-precision-se" class="section level3 hasAnchor" number="20.4.2">
<h3 class="hasAnchor"><span class="header-section-number">20.4.2</span> Assessing Precision (SE)<a href="#assessing-precision-se" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Now, which methods are the most precise?
We look at the true standard errors across our methods (we drop “simple” and the “ratio” estimators since they are not on the ratio scale):</p>
<div class="sourceCode" id="cb593"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb593-1"><a href="#cb593-1" tabindex="-1"></a>sres <span class="sc">%&gt;%</span> </span>
<span id="cb593-2"><a href="#cb593-2" tabindex="-1"></a>  <span class="fu">group_by</span>( model, n_c, n_t ) <span class="sc">%&gt;%</span></span>
<span id="cb593-3"><a href="#cb593-3" tabindex="-1"></a>  <span class="fu">summarise</span>( <span class="at">SE =</span> <span class="fu">mean</span>(SE ) ) <span class="sc">%&gt;%</span></span>
<span id="cb593-4"><a href="#cb593-4" tabindex="-1"></a>  <span class="fu">filter</span>( <span class="sc">!</span>(model <span class="sc">%in%</span> <span class="fu">c</span>( <span class="st">&quot;simple&quot;</span>, <span class="st">&quot;ratio&quot;</span>, <span class="st">&quot;ratio_twopost&quot;</span> ) ) ) <span class="sc">%&gt;%</span></span>
<span id="cb593-5"><a href="#cb593-5" tabindex="-1"></a>  <span class="fu">ggplot</span>( <span class="fu">aes</span>( n_c, SE, <span class="at">col=</span>model )) <span class="sc">+</span></span>
<span id="cb593-6"><a href="#cb593-6" tabindex="-1"></a>    <span class="fu">facet_grid</span>( . <span class="sc">~</span> n_t ) <span class="sc">+</span></span>
<span id="cb593-7"><a href="#cb593-7" tabindex="-1"></a>    <span class="fu">geom_line</span>() <span class="sc">+</span> <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb593-8"><a href="#cb593-8" tabindex="-1"></a>    <span class="fu">geom_hline</span>( <span class="at">yintercept =</span> <span class="dv">0</span> ) <span class="sc">+</span></span>
<span id="cb593-9"><a href="#cb593-9" tabindex="-1"></a>  <span class="fu">labs</span>( <span class="at">colour =</span> <span class="st">&quot;Model&quot;</span> )</span></code></pre></div>
<p><img src="Designing-Simulations-in-R_files/figure-html/disc_precision-1.png" width="75%" style="display: block; margin: auto;" /></p>
<p>It looks like averaging two years for the outcome is helpful, and bumps up precision.
The two way fixed effects model seems to react to the number of control units differently than the other estimators; it is way more precise when the number of controls is few, but the other estimators catch up.
The “raw” estimator gives a baseline of no covariate adjustment; everything is substantially more precise than it.
The covariates matter a lot.</p>
</div>
<div id="assessing-power" class="section level3 hasAnchor" number="20.4.3">
<h3 class="hasAnchor"><span class="header-section-number">20.4.3</span> Assessing power<a href="#assessing-power" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>We next look at power over our explored contexts, for the models that we find to be valid (i.e., not FE).</p>
<div class="sourceCode" id="cb594"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb594-1"><a href="#cb594-1" tabindex="-1"></a>sres <span class="sc">%&gt;%</span> </span>
<span id="cb594-2"><a href="#cb594-2" tabindex="-1"></a>  <span class="fu">filter</span>( model <span class="sc">!=</span> <span class="st">&quot;FE&quot;</span>,tx <span class="sc">!=</span> <span class="dv">1</span> ) <span class="sc">%&gt;%</span></span>
<span id="cb594-3"><a href="#cb594-3" tabindex="-1"></a>  <span class="fu">ggplot</span>( <span class="fu">aes</span>( n_c, pow, <span class="at">col=</span>model )) <span class="sc">+</span></span>
<span id="cb594-4"><a href="#cb594-4" tabindex="-1"></a>    <span class="fu">facet_grid</span>(  . <span class="sc">~</span> tx <span class="sc">+</span> n_t, <span class="at">labeller =</span> label_both ) <span class="sc">+</span></span>
<span id="cb594-5"><a href="#cb594-5" tabindex="-1"></a>    <span class="fu">geom_line</span>() <span class="sc">+</span> <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb594-6"><a href="#cb594-6" tabindex="-1"></a>    <span class="fu">geom_hline</span>( <span class="at">yintercept =</span> <span class="dv">0</span>, <span class="at">col=</span><span class="st">&quot;grey&quot;</span> ) <span class="sc">+</span></span>
<span id="cb594-7"><a href="#cb594-7" tabindex="-1"></a>    <span class="fu">geom_hline</span>( <span class="at">yintercept =</span> <span class="fu">c</span>( <span class="fl">0.10</span>, <span class="fl">0.80</span> ), <span class="at">lty=</span><span class="dv">2</span> ) <span class="sc">+</span></span>
<span id="cb594-8"><a href="#cb594-8" tabindex="-1"></a>  <span class="fu">theme_minimal</span>()<span class="sc">+</span> <span class="fu">theme</span>( <span class="at">legend.position=</span><span class="st">&quot;bottom&quot;</span>,</span>
<span id="cb594-9"><a href="#cb594-9" tabindex="-1"></a>                          <span class="at">legend.direction=</span><span class="st">&quot;horizontal&quot;</span>,</span>
<span id="cb594-10"><a href="#cb594-10" tabindex="-1"></a>                          <span class="at">legend.key.width=</span><span class="fu">unit</span>(<span class="dv">1</span>,<span class="st">&quot;cm&quot;</span>),</span>
<span id="cb594-11"><a href="#cb594-11" tabindex="-1"></a>                          <span class="at">panel.border =</span> <span class="fu">element_blank</span>() ) <span class="sc">+</span></span>
<span id="cb594-12"><a href="#cb594-12" tabindex="-1"></a>  <span class="fu">labs</span>( <span class="at">title=</span><span class="st">&quot;Power for various methods vs number of controls.&quot;</span>,</span>
<span id="cb594-13"><a href="#cb594-13" tabindex="-1"></a>      <span class="at">y =</span> <span class="st">&quot;Power&quot;</span> )</span></code></pre></div>
<p><img src="Designing-Simulations-in-R_files/figure-html/disc_power-1.png" width="75%" style="display: block; margin: auto;" /></p>
<p>We mark 80% power with a dashed line. For a 25% reduction in discipline, nothing reaches desired levels of power.
For 50% reduction, some designs do, but we need substantial numbers of control schools.
Averaging two years of outcomes post-treatment seems important: the “twopost” methods have a distinct power bump.
For a single year of outcome data, the log model seems our best bet.</p>
</div>
<div id="assessing-minimum-detectable-effects" class="section level3 hasAnchor" number="20.4.4">
<h3 class="hasAnchor"><span class="header-section-number">20.4.4</span> Assessing Minimum Detectable Effects<a href="#assessing-minimum-detectable-effects" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Sometimes we want to know, given a design, what size effect we might be able to detect.
The usual measure for this is the Minimum Detectable Effect (MDE), which is usually the size of the smallest effect we could detect with power 80%.</p>
<p>To calculate Minimal Detectable Effects (MDEs) for the log-scale estimators,
we first average our SEs over our different designs, grouped by sample size, and then convert the SEs to MDEs by multiplying by 2.8.
We then have to convert to our treatment scale by flipping the sign and exponentiating, to get out of the log scale.</p>
<div class="sourceCode" id="cb595"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb595-1"><a href="#cb595-1" tabindex="-1"></a>sres2 <span class="ot">=</span> sres <span class="sc">%&gt;%</span> </span>
<span id="cb595-2"><a href="#cb595-2" tabindex="-1"></a>  <span class="fu">group_by</span>( model, n_c, n_t ) <span class="sc">%&gt;%</span></span>
<span id="cb595-3"><a href="#cb595-3" tabindex="-1"></a>  <span class="fu">summarise</span>( <span class="at">SE =</span> <span class="fu">mean</span>( SE ),</span>
<span id="cb595-4"><a href="#cb595-4" tabindex="-1"></a>             <span class="at">E_SE_hat =</span> <span class="fu">mean</span>( E_SE_hat ) ) <span class="sc">%&gt;%</span></span>
<span id="cb595-5"><a href="#cb595-5" tabindex="-1"></a>  <span class="fu">mutate</span>( <span class="at">MDE =</span> <span class="fu">exp</span>( <span class="sc">-</span> (<span class="fl">1.64</span> <span class="sc">+</span> <span class="fl">0.8</span>) <span class="sc">*</span> SE ) )</span>
<span id="cb595-6"><a href="#cb595-6" tabindex="-1"></a></span>
<span id="cb595-7"><a href="#cb595-7" tabindex="-1"></a>sres2 <span class="sc">%&gt;%</span> </span>
<span id="cb595-8"><a href="#cb595-8" tabindex="-1"></a>  <span class="fu">filter</span>( <span class="sc">!</span>(model <span class="sc">%in%</span> <span class="fu">c</span>( <span class="st">&quot;simple&quot;</span>, <span class="st">&quot;ratio&quot;</span>, <span class="st">&quot;ratio_twopost&quot;</span> ) ) ) <span class="sc">%&gt;%</span></span>
<span id="cb595-9"><a href="#cb595-9" tabindex="-1"></a>  <span class="fu">ggplot</span>( <span class="fu">aes</span>( n_c, MDE, <span class="at">col=</span>model ) ) <span class="sc">+</span></span>
<span id="cb595-10"><a href="#cb595-10" tabindex="-1"></a>  <span class="fu">facet_wrap</span>( <span class="sc">~</span> n_t, <span class="at">labeller =</span> label_both ) <span class="sc">+</span></span>
<span id="cb595-11"><a href="#cb595-11" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span> <span class="fu">geom_line</span>()  <span class="sc">+</span></span>
<span id="cb595-12"><a href="#cb595-12" tabindex="-1"></a>  <span class="fu">geom_hline</span>( <span class="at">yintercept =</span> <span class="fl">0.5</span> ) <span class="sc">+</span></span>
<span id="cb595-13"><a href="#cb595-13" tabindex="-1"></a>  <span class="fu">theme_minimal</span>() <span class="sc">+</span></span>
<span id="cb595-14"><a href="#cb595-14" tabindex="-1"></a>  <span class="fu">scale_x_log10</span>( <span class="at">breaks =</span> <span class="fu">unique</span>( sres<span class="sc">$</span>n_c ) ) <span class="sc">+</span></span>
<span id="cb595-15"><a href="#cb595-15" tabindex="-1"></a>  <span class="fu">theme</span>( <span class="at">legend.position=</span><span class="st">&quot;bottom&quot;</span>,</span>
<span id="cb595-16"><a href="#cb595-16" tabindex="-1"></a>         <span class="at">legend.direction=</span><span class="st">&quot;horizontal&quot;</span>, <span class="at">legend.key.width=</span><span class="fu">unit</span>(<span class="dv">1</span>,<span class="st">&quot;cm&quot;</span>),</span>
<span id="cb595-17"><a href="#cb595-17" tabindex="-1"></a>         <span class="at">panel.border =</span> <span class="fu">element_blank</span>() ) <span class="sc">+</span></span>
<span id="cb595-18"><a href="#cb595-18" tabindex="-1"></a>  <span class="fu">labs</span>( <span class="at">x =</span> <span class="st">&quot;Number of control units&quot;</span>, <span class="at">y =</span> <span class="st">&quot;MDE (proportion reduction of rate)&quot;</span>,</span>
<span id="cb595-19"><a href="#cb595-19" tabindex="-1"></a>        <span class="at">caption =</span> <span class="st">&quot;A MDE of 0.6 means a 60% reduction (more than half) in discipline rates&quot;</span>,</span>
<span id="cb595-20"><a href="#cb595-20" tabindex="-1"></a>        <span class="at">title =</span> <span class="st">&quot;MDE vs number of control units for various methods&quot;</span> )</span></code></pre></div>
<p><img src="Designing-Simulations-in-R_files/figure-html/disc_mde-1.png" width="75%" style="display: block; margin: auto;" /></p>
<p>Corresponding with our findings regarding precision, above, the twopost estimator is the most sensitive, finding the smallest effects.</p>
<!--chapter:end:140-simulation-for-power-analysis.Rmd-->
</div>
</div>
</div>
<div id="potential-outcomes" class="section level1 hasAnchor" number="21">
<h1 class="hasAnchor"><span class="header-section-number">21</span> Simulation under the Potential Outcomes Framework<a href="#potential-outcomes" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p>If we are in the business of evaluating how various methods such as matching or propensity score weighting work in practice, we would probably turn to the potential outcomes framework for our simulations.
The potential outcomes framework is a framework typically used in the causal inference literature to make very explicit statements regarding the mechanics of causality and the associated estimands one might target when estimating causal effects.
While we recommend reading, for a more thourough overview, either [CITE Raudenbush or Field Experiments textbook], we briefly outline this framework here to set out our notation.</p>
<p>Take a sample of experimental units, indexed by <span class="math inline">\(i\)</span>.
For each unit, we can treat it or not.
Denote treatment as <span class="math inline">\(Z_i = 1\)</span> for treated or <span class="math inline">\(Z_i = 0\)</span> for not treated.
Now we imagine each unit has two potential outcomes being the outcome we would see if we treated it (<span class="math inline">\(Y_i(1)\)</span>) or if we did not (<span class="math inline">\(Y_i(0)\)</span>).
Finally, our observed outcome is then
<span class="math display">\[ Y_i^{obs} = Z_i Y_i(1) + (1-Z_i)Y_i(0) .\]</span>
For a unit, the treatment effect is <span class="math inline">\(\tau_i = Y_i(1) - Y_i(0)\)</span>; it is how much our outcome changes if we treat vs. not treat.
Frustratingly, for each unit we can only see one of its two potential outcomes, so we can never get an estimate of these individual <span class="math inline">\(\tau_i\)</span>.
Under this view, causality is a missing data problem: if we only were able to impute the missing potential outcomes, we could have a dataset where we could calculate any estimands we wanted. E.g., the true average treatment effect <em>for the sample</em> <span class="math inline">\(\mathcal{S}\)</span> would be:</p>
<p><span class="math display">\[ ATE_{\mathcal{S}} = \frac{1}{N} \sum_{i} Y_i(1) - Y_i( 0 ) . \]</span>
The average proportion increase, by contrast, would be</p>
<p><span class="math display">\[ API_{\mathcal{S}} = \frac{1}{N} \sum_{i} \frac{Y_i(1)}{Y_i(0)} \]</span></p>
<div id="finite-vs.-superpopulation-inference" class="section level2 hasAnchor" number="21.1">
<h2 class="hasAnchor"><span class="header-section-number">21.1</span> Finite vs. Superpopulation inference<a href="#finite-vs.-superpopulation-inference" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Consider a sample of <span class="math inline">\(n\)</span> units, <span class="math inline">\(\mathcal{S}\)</span>, along with their set of potential outcomes.
We can talk about the true ATE of the sample, or, if we thought of the sample as being drawn from some larger population, we could talk about the true ATE of that larger population.</p>
<p>This is a tension that often arises in potential outcomes based simulations: if we are focused on <span class="math inline">\(ATE_{\mathcal{S}}\)</span> then for each sample we generate, our estimand could be (maybe only slightly) different, depending on whether our sample has more or fewer units with high <span class="math inline">\(\tau_i\)</span>.
If, on the other hand, we are focused on where the units came from (which is our data generating model), our estimand is a property of the DGP, and would be the same for each sample generated.</p>
<p>The catch is when we calculate our performance metrics, we now have two possible targets to pick from.
Furthermore, if we are targeting the superpopulation ATE, then our error in estimation may be due in part to the representativeness of the sample, <em>not</em> the estimation or uncertainty due to the random assignment.</p>
<p>We will follow this theme throughout this chapter.</p>
</div>
<div id="data-generation-processes-for-potential-outcomes" class="section level2 hasAnchor" number="21.2">
<h2 class="hasAnchor"><span class="header-section-number">21.2</span> Data generation processes for potential outcomes<a href="#data-generation-processes-for-potential-outcomes" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>If we want to write a simulation using the potential outcomes framework, it is clear and transparent to first generate a complete set of potential outcomes, then generate a random assignment based on some assignment mechanism, and finally generate the observed outcomes as a function of assignment and original potential outcomes.</p>
<p>For example, we might say that our data generation process is as follows: First generate each unit <span class="math inline">\(i = 1, \ldots, n\)</span>, as
<span class="math display">\[
\begin{aligned}
X_i &amp;\sim exp( 1 ) - 1 \\
Y_i(0) &amp;= \beta_0 + \beta_1 X_i + \epsilon_i \mbox{ with } \epsilon_i \sim N( 0, \sigma^2 ) \\
\tau_i &amp;= \tau_0 + \tau_1 X_i + \alpha u_i \mbox{ with } u_i \sim t_{df} \\
Y_i(1) &amp;= Y_i(0) + \tau_i
\end{aligned}
\]</span>
with <span class="math inline">\(exp(1)\)</span> being the standard exponential distribution and <span class="math inline">\(t_{df}\)</span> being a <span class="math inline">\(t\)</span> distribution with <span class="math inline">\(df\)</span> degrees of freedom.
We subtract 1 from <span class="math inline">\(X_i\)</span> to zero-center it (it is often convenient to have zero-centered covariates so we can then, e.g., interpret <span class="math inline">\(\tau_0\)</span> as the true superpopulation ATE of our experiment).</p>
<p>The above model is saying that we first, for each unit, generate a covariate.
We then generate our two potential outcomes.
I.e., we are generating what the outcome would be for each unit if it were treated and if it were not treated.
We are driving both the level and the treatment effect with <span class="math inline">\(X_i\)</span>, assuming <span class="math inline">\(\beta_1\)</span> and <span class="math inline">\(\tau_1\)</span> are non-zero.</p>
<p>One advantage of generating all the potential outcomes is we can then calculate the finite-sample estimands such as the true average treatment effect for the generated sample: we just take the average of <span class="math inline">\(Y_i(1) - Y_i(0)\)</span> for our sample.</p>
<p>Here is some code to illustrate the first part of the data generating process (we leave treatment assignment to later):</p>
<div class="sourceCode" id="cb596"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb596-1"><a href="#cb596-1" tabindex="-1"></a>gen_data <span class="ot">&lt;-</span> <span class="cf">function</span>( <span class="at">n =</span> <span class="dv">100</span>,</span>
<span id="cb596-2"><a href="#cb596-2" tabindex="-1"></a>                      <span class="at">R2 =</span> <span class="fl">0.5</span>,</span>
<span id="cb596-3"><a href="#cb596-3" tabindex="-1"></a>                      <span class="at">beta_0 =</span> <span class="dv">0</span>, <span class="at">beta_1 =</span> <span class="dv">1</span>,</span>
<span id="cb596-4"><a href="#cb596-4" tabindex="-1"></a>                      <span class="at">tau_0 =</span> <span class="dv">1</span>, <span class="at">tau_1 =</span> <span class="dv">1</span>, </span>
<span id="cb596-5"><a href="#cb596-5" tabindex="-1"></a>                      <span class="at">alpha =</span> <span class="dv">1</span>, <span class="at">df =</span> <span class="dv">3</span> ) {</span>
<span id="cb596-6"><a href="#cb596-6" tabindex="-1"></a>  <span class="fu">stopifnot</span>( R2 <span class="sc">&gt;=</span> <span class="dv">0</span> <span class="sc">&amp;&amp;</span> R2 <span class="sc">&lt;</span> <span class="dv">1</span> )</span>
<span id="cb596-7"><a href="#cb596-7" tabindex="-1"></a>  X_i <span class="ot">=</span> <span class="fu">rexp</span>( n, <span class="at">rate =</span> <span class="dv">1</span> ) <span class="sc">-</span> <span class="dv">1</span></span>
<span id="cb596-8"><a href="#cb596-8" tabindex="-1"></a>  beta_1 <span class="ot">=</span> <span class="fu">sqrt</span>( <span class="dv">1</span> <span class="sc">-</span> R2 )</span>
<span id="cb596-9"><a href="#cb596-9" tabindex="-1"></a>  sigma_e <span class="ot">=</span> <span class="fu">sqrt</span>( R2 )</span>
<span id="cb596-10"><a href="#cb596-10" tabindex="-1"></a>  Y0_i <span class="ot">=</span> beta_0 <span class="sc">+</span> beta_1 <span class="sc">*</span> X_i <span class="sc">+</span> <span class="fu">rnorm</span>( n, <span class="at">sd=</span>sigma_e )</span>
<span id="cb596-11"><a href="#cb596-11" tabindex="-1"></a>  tau_i <span class="ot">=</span> tau_0 <span class="sc">+</span> tau_1 <span class="sc">*</span> X_i <span class="sc">+</span> alpha <span class="sc">*</span> <span class="fu">rt</span>( n, <span class="at">df =</span> df )</span>
<span id="cb596-12"><a href="#cb596-12" tabindex="-1"></a>  Y1_i <span class="ot">=</span> Y0_i <span class="sc">+</span> tau_i</span>
<span id="cb596-13"><a href="#cb596-13" tabindex="-1"></a>  </span>
<span id="cb596-14"><a href="#cb596-14" tabindex="-1"></a>  <span class="fu">tibble</span>( <span class="at">X =</span> X_i, <span class="at">Y0 =</span> Y0_i, <span class="at">Y1 =</span> Y1_i )</span>
<span id="cb596-15"><a href="#cb596-15" tabindex="-1"></a>}</span></code></pre></div>
<p>And now we see our estimand can change:</p>
<div class="sourceCode" id="cb597"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb597-1"><a href="#cb597-1" tabindex="-1"></a><span class="fu">set.seed</span>( <span class="dv">40454</span> )</span>
<span id="cb597-2"><a href="#cb597-2" tabindex="-1"></a>d1 <span class="ot">&lt;-</span> <span class="fu">gen_data</span>( <span class="dv">50</span> )</span>
<span id="cb597-3"><a href="#cb597-3" tabindex="-1"></a><span class="fu">mean</span>( d1<span class="sc">$</span>Y1 <span class="sc">-</span> d1<span class="sc">$</span>Y0 )</span></code></pre></div>
<pre><code>## [1] 0.6374925</code></pre>
<div class="sourceCode" id="cb599"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb599-1"><a href="#cb599-1" tabindex="-1"></a>d2 <span class="ot">&lt;-</span> <span class="fu">gen_data</span>( <span class="dv">50</span> )</span>
<span id="cb599-2"><a href="#cb599-2" tabindex="-1"></a><span class="fu">mean</span>( d2<span class="sc">$</span>Y1 <span class="sc">-</span> d2<span class="sc">$</span>Y0 )</span></code></pre></div>
<pre><code>## [1] 0.5479788</code></pre>
<p>In reviewing our code, we know our superpopulation ATE should be <code>tau</code>, or 1 exactly.
If our estimate for <code>d1</code> is 0.6 do we say that is close or far from the target?
From a finite sample performance approach, we nailed it.
From superpopulation, less so.</p>
<p>Also in looking at the above, there are a few details to call out:</p>
<ul>
<li>We can store the latent, intermediate quantities (both potential outcomes, in particular) so we can calculate the estimands of interest or learn about our data generating process. When we hand the data to an estimator, we would not provide this “secret” information.</li>
<li>We are using a trick to index our DGP by an R2 value rather than coefficients on X so we can have a standardized control-side outcome (the expected variation of <span class="math inline">\(Y_i(0)\)</span> will be 1). The treatment outcomes will have more variation due to the heterogeniety of the treatment impacts.</li>
<li>If we were generating data with a constant treatment impact, then <span class="math inline">\(ATE_{\mathcal{S}} = ATE\)</span> always; this is typical for many similations in the literature. That being said, treatment variation is what causes a lot of methods to fail and so having simulations that have this variation is usually important.</li>
</ul>
<p>Once we have our <em>schedule of potential outcomes</em>, we would then generate the <em>observed outcomes</em> by assigning our (synthetic, randomly generated) <span class="math inline">\(n\)</span> units to treatment or control.
For example, say we wanted to simulate an observational context where treatment was a function of our covariate.
We could model each unit as flipping a weighted coin with some probability that was a function of <span class="math inline">\(X_i\)</span> as so:</p>
<p><span class="math display">\[
\begin{aligned}
p_i &amp;= logit^{-1}( \xi_0 + \xi_1 X_i ) \\
Z_i &amp;= Bern( p_i ) \\
Y_i &amp;= Z_i Y_i(1) + (1-Z_i) Y_i(0)
\end{aligned}
\]</span></p>
<p>Here is code for assigning our data to treatment and control:</p>
<div class="sourceCode" id="cb601"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb601-1"><a href="#cb601-1" tabindex="-1"></a>assign_data <span class="ot">&lt;-</span> <span class="cf">function</span>( dat,</span>
<span id="cb601-2"><a href="#cb601-2" tabindex="-1"></a>                         <span class="at">xi_0 =</span> <span class="sc">-</span><span class="dv">1</span>, <span class="at">xi_1 =</span> <span class="dv">1</span> ) {</span>
<span id="cb601-3"><a href="#cb601-3" tabindex="-1"></a>  n <span class="ot">=</span> <span class="fu">nrow</span>(dat)</span>
<span id="cb601-4"><a href="#cb601-4" tabindex="-1"></a>  dat <span class="ot">=</span> <span class="fu">mutate</span>( dat,</span>
<span id="cb601-5"><a href="#cb601-5" tabindex="-1"></a>                <span class="at">p =</span> arm<span class="sc">::</span><span class="fu">invlogit</span>( xi_0 <span class="sc">+</span> xi_1 <span class="sc">*</span> X ),</span>
<span id="cb601-6"><a href="#cb601-6" tabindex="-1"></a>                <span class="at">Z =</span> <span class="fu">rbinom</span>( n, <span class="dv">1</span>, <span class="at">prob=</span>p ),</span>
<span id="cb601-7"><a href="#cb601-7" tabindex="-1"></a>                <span class="at">Yobs =</span> <span class="fu">ifelse</span>( Z <span class="sc">==</span> <span class="dv">1</span>, Y1, Y0 ) )</span>
<span id="cb601-8"><a href="#cb601-8" tabindex="-1"></a>  dat</span>
<span id="cb601-9"><a href="#cb601-9" tabindex="-1"></a>}</span></code></pre></div>
<p>We can then add our assignment variable to our given data as so:</p>
<div class="sourceCode" id="cb602"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb602-1"><a href="#cb602-1" tabindex="-1"></a><span class="fu">assign_data</span>( d2 )</span></code></pre></div>
<pre><code>## # A tibble: 50 × 6
##           X     Y0      Y1     p     Z    Yobs
##       &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;   &lt;dbl&gt;
##  1  0.670    0.667   2.58  0.418     1   2.58 
##  2  0.371    0.314   4.57  0.348     1   4.57 
##  3  1.94     1.29    3.03  0.719     0   1.29 
##  4 -0.244    0.119 -10.0   0.224     1 -10.0  
##  5  0.00850  1.44    2.88  0.271     0   1.44 
##  6  1.41     1.14    5.02  0.600     1   5.02 
##  7 -0.864    0.461   0.802 0.134     1   0.802
##  8 -0.00533 -0.914  -1.17  0.268     0  -0.914
##  9 -0.907   -0.202   0.555 0.129     1   0.555
## 10 -0.363   -0.141   1.16  0.204     1   1.16 
## # ℹ 40 more rows</code></pre>
<p>Note how <code>Yobs</code> is, depending on <code>Z</code>, either <code>Y0</code> or <code>Y1</code>.
Separating our our DGP and our random assignment underscores the potential outcomes framework adage of the data are what they are, and we the experimenters (or nature) is randomly assigning these whole units to various conditions and observing the consequences.</p>
<p>In general, we might instead put the <code>p_i</code> part of the model in our code generating the outcomes, if we wanted to view the chance of treatment assignment as inherent to the unit (which is what we usually expect in an observational context).</p>
</div>
<div id="finite-sample-performance-measures" class="section level2 hasAnchor" number="21.3">
<h2 class="hasAnchor"><span class="header-section-number">21.3</span> Finite sample performance measures<a href="#finite-sample-performance-measures" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Let’s generate a single dataset with our DGP from above, and run a small experiment where we actually randomize units to treatment and control:</p>
<div class="sourceCode" id="cb604"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb604-1"><a href="#cb604-1" tabindex="-1"></a>n <span class="ot">=</span> <span class="dv">100</span></span>
<span id="cb604-2"><a href="#cb604-2" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">442423</span>)</span>
<span id="cb604-3"><a href="#cb604-3" tabindex="-1"></a>dat <span class="ot">=</span> <span class="fu">gen_data</span>(n, <span class="at">tau_1 =</span> <span class="sc">-</span><span class="dv">1</span>)</span>
<span id="cb604-4"><a href="#cb604-4" tabindex="-1"></a>dat <span class="ot">=</span> <span class="fu">mutate</span>( dat,</span>
<span id="cb604-5"><a href="#cb604-5" tabindex="-1"></a>              <span class="at">Z =</span> <span class="dv">0</span> <span class="sc">+</span> (<span class="fu">sample</span>( n ) <span class="sc">&lt;=</span> n<span class="sc">/</span><span class="dv">2</span>),</span>
<span id="cb604-6"><a href="#cb604-6" tabindex="-1"></a>              <span class="at">Yobs =</span> <span class="fu">ifelse</span>( Z <span class="sc">==</span> <span class="dv">1</span>, Y1, Y0 ) )</span>
<span id="cb604-7"><a href="#cb604-7" tabindex="-1"></a>mod <span class="ot">=</span> <span class="fu">lm</span>( Yobs <span class="sc">~</span> Z, <span class="at">data=</span>dat )</span>
<span id="cb604-8"><a href="#cb604-8" tabindex="-1"></a><span class="fu">coef</span>(mod)[[<span class="st">&quot;Z&quot;</span>]]</span></code></pre></div>
<pre><code>## [1] 0.8914992</code></pre>
<p>We can compare this to the true finite-sample ATE:</p>
<div class="sourceCode" id="cb606"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb606-1"><a href="#cb606-1" tabindex="-1"></a><span class="fu">mean</span>( dat<span class="sc">$</span>Y1 <span class="sc">-</span> dat<span class="sc">$</span>Y0 )</span></code></pre></div>
<pre><code>## [1] 1.154018</code></pre>
<p>Our finite-population simulation would be:</p>
<div class="sourceCode" id="cb608"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb608-1"><a href="#cb608-1" tabindex="-1"></a>rps <span class="ot">&lt;-</span> <span class="fu">rerun</span>( <span class="dv">1000</span>, {</span>
<span id="cb608-2"><a href="#cb608-2" tabindex="-1"></a>  dat <span class="ot">=</span> <span class="fu">mutate</span>( dat,</span>
<span id="cb608-3"><a href="#cb608-3" tabindex="-1"></a>              <span class="at">Z =</span> <span class="dv">0</span> <span class="sc">+</span> (<span class="fu">sample</span>( n ) <span class="sc">&lt;=</span> n<span class="sc">/</span><span class="dv">2</span>),</span>
<span id="cb608-4"><a href="#cb608-4" tabindex="-1"></a>              <span class="at">Yobs =</span> <span class="fu">ifelse</span>( Z <span class="sc">==</span> <span class="dv">1</span>, Y1, Y0 ) )</span>
<span id="cb608-5"><a href="#cb608-5" tabindex="-1"></a>  mod <span class="ot">=</span> <span class="fu">lm</span>( Yobs <span class="sc">~</span> Z, <span class="at">data=</span>dat )</span>
<span id="cb608-6"><a href="#cb608-6" tabindex="-1"></a>  <span class="fu">tibble</span>( <span class="at">ATE_hat =</span> <span class="fu">coef</span>(mod)[[<span class="st">&quot;Z&quot;</span>]],</span>
<span id="cb608-7"><a href="#cb608-7" tabindex="-1"></a>          <span class="at">SE_hat =</span> arm<span class="sc">::</span><span class="fu">se.coef</span>(mod)[[<span class="st">&quot;Z&quot;</span>]] )</span>
<span id="cb608-8"><a href="#cb608-8" tabindex="-1"></a>  }) <span class="sc">%&gt;%</span></span>
<span id="cb608-9"><a href="#cb608-9" tabindex="-1"></a>  <span class="fu">bind_rows</span>()</span></code></pre></div>
<pre><code>## Warning: `rerun()` was deprecated in purrr 1.0.0.
## ℹ Please use `map()` instead.
##   # Previously
## rerun(1000, {
## dat = mutate(dat, Z = 0 + (sample(n) &lt;= n / 2),
## Yobs = ifelse(Z == 1, Y1, Y0))
## mod = lm(Yobs ~ Z, data = dat)
## tibble(ATE_hat = coef(mod)[[&quot;Z&quot;]], SE_hat =
## arm::se.coef(
## mod)[[&quot;Z&quot;]])
## })
## 
##   # Now
## map(1:1000, ~ {
## dat = mutate(dat, Z = 0 + (sample(n) &lt;= n / 2),
## Yobs = ifelse(Z == 1, Y1, Y0))
## mod = lm(Yobs ~ Z, data = dat)
## tibble(ATE_hat = coef(mod)[[&quot;Z&quot;]], SE_hat =
## arm::se.coef(
## mod)[[&quot;Z&quot;]])
## })
## This warning is displayed once every 8 hours.
## Call `lifecycle::last_lifecycle_warnings()` to
## see where this warning was generated.</code></pre>
<div class="sourceCode" id="cb610"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb610-1"><a href="#cb610-1" tabindex="-1"></a>rps <span class="sc">%&gt;%</span> <span class="fu">summarise</span>( <span class="at">EATE_hat =</span> <span class="fu">mean</span>( ATE_hat ),</span>
<span id="cb610-2"><a href="#cb610-2" tabindex="-1"></a>                   <span class="at">SE =</span> <span class="fu">sd</span>( ATE_hat ),</span>
<span id="cb610-3"><a href="#cb610-3" tabindex="-1"></a>                   <span class="at">ESE_hat =</span> <span class="fu">mean</span>( SE_hat ) )</span></code></pre></div>
<pre><code>## # A tibble: 1 × 3
##   EATE_hat    SE ESE_hat
##      &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;
## 1     1.16 0.248   0.307</code></pre>
<p>We are simulating on a single dataset.
In particular, our set of potential outcomes is entirely fixed; the only source of randomness (and thus the randomness behind our SE) is the random assignment.
Now this opens up some room for critique: what if our single dataset is non-standard?</p>
<p>Our super-population simulation would be, by contrast:</p>
<div class="sourceCode" id="cb612"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb612-1"><a href="#cb612-1" tabindex="-1"></a>rps_sup <span class="ot">&lt;-</span> <span class="fu">rerun</span>( <span class="dv">1000</span>, {</span>
<span id="cb612-2"><a href="#cb612-2" tabindex="-1"></a>  dat <span class="ot">=</span> <span class="fu">gen_data</span>(n)</span>
<span id="cb612-3"><a href="#cb612-3" tabindex="-1"></a>  dat <span class="ot">=</span> <span class="fu">mutate</span>( dat,</span>
<span id="cb612-4"><a href="#cb612-4" tabindex="-1"></a>              <span class="at">Z =</span> <span class="dv">0</span> <span class="sc">+</span> (<span class="fu">sample</span>( n ) <span class="sc">&lt;=</span> n<span class="sc">/</span><span class="dv">2</span>),</span>
<span id="cb612-5"><a href="#cb612-5" tabindex="-1"></a>              <span class="at">Yobs =</span> <span class="fu">ifelse</span>( Z <span class="sc">==</span> <span class="dv">1</span>, Y1, Y0 ) )</span>
<span id="cb612-6"><a href="#cb612-6" tabindex="-1"></a>  mod <span class="ot">=</span> <span class="fu">lm</span>( Yobs <span class="sc">~</span> Z, <span class="at">data=</span>dat )</span>
<span id="cb612-7"><a href="#cb612-7" tabindex="-1"></a>  <span class="fu">tibble</span>( <span class="at">ATE_hat =</span> <span class="fu">coef</span>(mod)[[<span class="st">&quot;Z&quot;</span>]],</span>
<span id="cb612-8"><a href="#cb612-8" tabindex="-1"></a>          <span class="at">SE_hat =</span> arm<span class="sc">::</span><span class="fu">se.coef</span>(mod)[[<span class="st">&quot;Z&quot;</span>]] )</span>
<span id="cb612-9"><a href="#cb612-9" tabindex="-1"></a>  }) <span class="sc">%&gt;%</span></span>
<span id="cb612-10"><a href="#cb612-10" tabindex="-1"></a>  <span class="fu">bind_rows</span>()</span></code></pre></div>
<pre><code>## Warning: `rerun()` was deprecated in purrr 1.0.0.
## ℹ Please use `map()` instead.
##   # Previously
## rerun(1000, {
## dat = gen_data(n)
## dat = mutate(dat, Z = 0 + (sample(n) &lt;= n / 2),
## Yobs = ifelse(Z == 1, Y1, Y0))
## mod = lm(Yobs ~ Z, data = dat)
## tibble(ATE_hat = coef(mod)[[&quot;Z&quot;]], SE_hat =
## arm::se.coef(
## mod)[[&quot;Z&quot;]])
## })
## 
##   # Now
## map(1:1000, ~ {
## dat = gen_data(n)
## dat = mutate(dat, Z = 0 + (sample(n) &lt;= n / 2),
## Yobs = ifelse(Z == 1, Y1, Y0))
## mod = lm(Yobs ~ Z, data = dat)
## tibble(ATE_hat = coef(mod)[[&quot;Z&quot;]], SE_hat =
## arm::se.coef(
## mod)[[&quot;Z&quot;]])
## })
## This warning is displayed once every 8 hours.
## Call `lifecycle::last_lifecycle_warnings()` to
## see where this warning was generated.</code></pre>
<div class="sourceCode" id="cb614"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb614-1"><a href="#cb614-1" tabindex="-1"></a>rps_sup <span class="sc">%&gt;%</span> <span class="fu">summarise</span>( <span class="at">EATE_hat =</span> <span class="fu">mean</span>( ATE_hat ),</span>
<span id="cb614-2"><a href="#cb614-2" tabindex="-1"></a>                   <span class="at">SE =</span> <span class="fu">sd</span>( ATE_hat ),</span>
<span id="cb614-3"><a href="#cb614-3" tabindex="-1"></a>                   <span class="at">ESE_hat =</span> <span class="fu">mean</span>( SE_hat ))</span></code></pre></div>
<pre><code>## # A tibble: 1 × 3
##   EATE_hat    SE ESE_hat
##      &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;
## 1     1.00 0.381   0.378</code></pre>
<p>First, note our superpopulation simulation is not biased for the superpopulation ATE.
Also note the true SE is larger than our finite-sample simulation; this is because part of the uncertainty in our estimator is the uncertainty of whether our sample is representative of the superpopulation.</p>
<p>Finally, this clarifies that our linear regression estimator is estimating standard errors assuming a superpopulation model.
The true finite sample standard error is less than the expected estimated error: from a finite sample perspective, our estimator is giving overly conservative uncertainty estimates.
(This discrepancy is often called the correlation of potential outcomes problem.)</p>
</div>
<div id="nested-finite-simulation-procedure" class="section level2 hasAnchor" number="21.4">
<h2 class="hasAnchor"><span class="header-section-number">21.4</span> Nested finite simulation procedure<a href="#nested-finite-simulation-procedure" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>We just saw a difference between a specific, single, finite-sample dataset and a superpopulation.
What if we wanted to know if this phenomenon was more general across a set of datasets?
This question can be levied more broadly: if we run a simulation on a single dataset, this is even more narrow than running on a single scenario: if we compare methods and find one is superior to another for our single dataset, how do we know this is not an artifact of some specific characteristic of <em>that data</em> and not a general phenomonen at all?</p>
<p>One way forward is to run a nested simulation, where we generate a series of finite sample datasets, and then for each dataset run a small simulation.
We then calculate the expected finite sample performance across the datasets.
One could almost think of the datasets themselves as a “factor” in our multifactor experiment.
This is what we did in [CITE estimands paper]</p>
<p>Borrowing from the simulation appendix of [CITE estimands paper], repeat <span class="math inline">\(R\)</span> times:</p>
<ol style="list-style-type: decimal">
<li><p>Generate a dataset using a particular DGP. This data generation is the “sampling step” for a superpopulation (SP) framework. The DGP represents an inﬁnite superpopulation. Each dataset includes, for each observation, the potential outcome under treatment or control.</p></li>
<li><p>Record the true finite-sample ATE, both person and site weighted.</p></li>
<li><p>Then, three times, do a finite simulation as follows:</p></li>
</ol>
<ol style="list-style-type: lower-alpha">
<li>Randomize units to treatment and control.</li>
<li>Calculate the corresponding observed outcomes.</li>
<li>Analyze the results using the methods of interest, recording both the point estimate and estimated standard error for each.</li>
</ol>
<p>Having only three trials will give a poor estimate of within-dataset variability for each dataset, but the average across the
<span class="math inline">\(R\)</span> datasets in a given scenario gives a reasonable estimate of expected variability across datasets of the type we would see given the scenario parameters.</p>
<p>To demonstrate we first make a mini-finite sample driver:</p>
<div class="sourceCode" id="cb616"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb616-1"><a href="#cb616-1" tabindex="-1"></a>one_finite_run <span class="ot">&lt;-</span> <span class="cf">function</span>( <span class="at">R0 =</span> <span class="dv">3</span>, <span class="at">n =</span> <span class="dv">100</span>, ... ) {</span>
<span id="cb616-2"><a href="#cb616-2" tabindex="-1"></a>  dat <span class="ot">=</span> <span class="fu">gen_data</span>( <span class="at">n =</span> n, ... )</span>
<span id="cb616-3"><a href="#cb616-3" tabindex="-1"></a>  rps <span class="ot">&lt;-</span> <span class="fu">rerun</span>( R0, {</span>
<span id="cb616-4"><a href="#cb616-4" tabindex="-1"></a>         dat <span class="ot">=</span> <span class="fu">mutate</span>( dat,</span>
<span id="cb616-5"><a href="#cb616-5" tabindex="-1"></a>                    <span class="at">Z =</span> <span class="dv">0</span> <span class="sc">+</span> (<span class="fu">sample</span>( n ) <span class="sc">&lt;=</span> n<span class="sc">/</span><span class="dv">2</span>),</span>
<span id="cb616-6"><a href="#cb616-6" tabindex="-1"></a>                    <span class="at">Yobs =</span> <span class="fu">ifelse</span>( Z <span class="sc">==</span> <span class="dv">1</span>, Y1, Y0 ) )</span>
<span id="cb616-7"><a href="#cb616-7" tabindex="-1"></a>        mod <span class="ot">=</span> <span class="fu">lm</span>( Yobs <span class="sc">~</span> Z, <span class="at">data=</span>dat )</span>
<span id="cb616-8"><a href="#cb616-8" tabindex="-1"></a>        <span class="fu">tibble</span>( <span class="at">ATE_hat =</span> <span class="fu">coef</span>(mod)[[<span class="st">&quot;Z&quot;</span>]],</span>
<span id="cb616-9"><a href="#cb616-9" tabindex="-1"></a>                <span class="at">SE_hat =</span> arm<span class="sc">::</span><span class="fu">se.coef</span>(mod)[[<span class="st">&quot;Z&quot;</span>]] )</span>
<span id="cb616-10"><a href="#cb616-10" tabindex="-1"></a>    }) <span class="sc">%&gt;%</span></span>
<span id="cb616-11"><a href="#cb616-11" tabindex="-1"></a>    <span class="fu">bind_rows</span>()</span>
<span id="cb616-12"><a href="#cb616-12" tabindex="-1"></a>  rps<span class="sc">$</span>ATE <span class="ot">=</span> <span class="fu">mean</span>( dat<span class="sc">$</span>Y1 <span class="sc">-</span> dat<span class="sc">$</span>Y0 )</span>
<span id="cb616-13"><a href="#cb616-13" tabindex="-1"></a>  rps</span>
<span id="cb616-14"><a href="#cb616-14" tabindex="-1"></a>}</span></code></pre></div>
<p>This driver also stores the finite sample ATE for future reference:</p>
<div class="sourceCode" id="cb617"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb617-1"><a href="#cb617-1" tabindex="-1"></a><span class="fu">one_finite_run</span>()</span></code></pre></div>
<pre><code>## Warning: `rerun()` was deprecated in purrr 1.0.0.
## ℹ Please use `map()` instead.
##   # Previously
## rerun(3, {
## dat = mutate(dat, Z = 0 + (sample(n) &lt;= n / 2),
## Yobs = ifelse(Z == 1, Y1, Y0))
## mod = lm(Yobs ~ Z, data = dat)
## tibble(ATE_hat = coef(mod)[[&quot;Z&quot;]], SE_hat =
## arm::se.coef(
## mod)[[&quot;Z&quot;]])
## })
## 
##   # Now
## map(1:3, ~ {
## dat = mutate(dat, Z = 0 + (sample(n) &lt;= n / 2),
## Yobs = ifelse(Z == 1, Y1, Y0))
## mod = lm(Yobs ~ Z, data = dat)
## tibble(ATE_hat = coef(mod)[[&quot;Z&quot;]], SE_hat =
## arm::se.coef(
## mod)[[&quot;Z&quot;]])
## })
## This warning is displayed once every 8 hours.
## Call `lifecycle::last_lifecycle_warnings()` to
## see where this warning was generated.</code></pre>
<pre><code>## # A tibble: 3 × 3
##   ATE_hat SE_hat   ATE
##     &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;
## 1   0.348  0.421 0.768
## 2   1.32   0.472 0.768
## 3   1.17   0.549 0.768</code></pre>
<p>We then run a bunch of finite runs.</p>
<div class="sourceCode" id="cb620"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb620-1"><a href="#cb620-1" tabindex="-1"></a>runs <span class="ot">&lt;-</span> <span class="fu">rerun</span>( <span class="dv">500</span>, <span class="fu">one_finite_run</span>() ) <span class="sc">%&gt;%</span></span>
<span id="cb620-2"><a href="#cb620-2" tabindex="-1"></a>  <span class="fu">bind_rows</span>( <span class="at">.id =</span> <span class="st">&quot;runID&quot;</span> )</span></code></pre></div>
<p>We use <code>.id</code> because we will need to separate out each finite run and analyze separately, and then aggregate.</p>
<p>Each finite run is a very noisy simulation for a fixed dataset.
This means when we calculate performance measures we have to be careful to avoid bias in the calculations; in particular, we need to focus on estimating <span class="math inline">\(SE^2\)</span> across the finite runs, not <span class="math inline">\(SE\)</span>, to avoid the bias caused by having a few observations with every estimate.</p>
<div class="sourceCode" id="cb621"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb621-1"><a href="#cb621-1" tabindex="-1"></a>fruns <span class="ot">&lt;-</span> runs <span class="sc">%&gt;%</span> <span class="fu">group_by</span>( runID ) <span class="sc">%&gt;%</span></span>
<span id="cb621-2"><a href="#cb621-2" tabindex="-1"></a>  <span class="fu">summarise</span>( <span class="at">EATE_hat =</span> <span class="fu">mean</span>( ATE_hat ),</span>
<span id="cb621-3"><a href="#cb621-3" tabindex="-1"></a>             <span class="at">SE2 =</span> <span class="fu">var</span>( ATE_hat ),</span>
<span id="cb621-4"><a href="#cb621-4" tabindex="-1"></a>             <span class="at">ESE_hat =</span> <span class="fu">mean</span>( SE_hat ),</span>
<span id="cb621-5"><a href="#cb621-5" tabindex="-1"></a>             <span class="at">.groups =</span> <span class="st">&quot;drop&quot;</span> )</span></code></pre></div>
<p>And then we aggregate our finite sample runs:</p>
<div class="sourceCode" id="cb622"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb622-1"><a href="#cb622-1" tabindex="-1"></a>res <span class="ot">&lt;-</span> fruns <span class="sc">%&gt;%</span></span>
<span id="cb622-2"><a href="#cb622-2" tabindex="-1"></a>  <span class="fu">summarise</span>( <span class="at">EEATE_hat =</span> <span class="fu">mean</span>( EATE_hat ),</span>
<span id="cb622-3"><a href="#cb622-3" tabindex="-1"></a>             <span class="at">EESE_hat =</span> <span class="fu">sqrt</span>( <span class="fu">mean</span>( ESE_hat<span class="sc">^</span><span class="dv">2</span> ) ),</span>
<span id="cb622-4"><a href="#cb622-4" tabindex="-1"></a>             <span class="at">ESE =</span> <span class="fu">sqrt</span>( <span class="fu">mean</span>( SE2 ) ) ) <span class="sc">%&gt;%</span></span>
<span id="cb622-5"><a href="#cb622-5" tabindex="-1"></a>  <span class="fu">mutate</span>( <span class="at">calib =</span> <span class="dv">100</span> <span class="sc">*</span> EESE_hat <span class="sc">/</span> ESE )</span>
<span id="cb622-6"><a href="#cb622-6" tabindex="-1"></a></span>
<span id="cb622-7"><a href="#cb622-7" tabindex="-1"></a>res</span></code></pre></div>
<pre><code>## # A tibble: 1 × 4
##   EEATE_hat EESE_hat   ESE calib
##       &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     0.996    0.380 0.331  115.</code></pre>
<p>We see our expected standard error estimate is, across the collection of finite sample scenarios all sharing a similar parent superpopulation DGP, 15% too large for the true expected finite-sample standard error.</p>
<p>We need to keep the squaring. If we look at the SEs themselves, we have further apparent bias due to our <em>estimated</em> <code>ESE_hat</code> being so unstable due to too few observations:</p>
<div class="sourceCode" id="cb624"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb624-1"><a href="#cb624-1" tabindex="-1"></a><span class="fu">mean</span>( <span class="fu">sqrt</span>( fruns<span class="sc">$</span>SE2 ) )</span></code></pre></div>
<pre><code>## [1] 0.2944556</code></pre>
<p>We can use our collection of mini-finite-sample runs to estimate superpopulation quantities as well.
Given that the simulation datasets are i.i.d. draws, we can simply take expectations across all our simulations.
The only concern is our estimates of MCSE will be off due to the clustering in our simulation runs.</p>
<p>Here we calculate superpopulation performance measures (both with the squared SE and without; we prefer the squared version):</p>
<div class="sourceCode" id="cb626"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb626-1"><a href="#cb626-1" tabindex="-1"></a>runs <span class="sc">%&gt;%</span></span>
<span id="cb626-2"><a href="#cb626-2" tabindex="-1"></a>  <span class="fu">summarise</span>( <span class="at">EATE_hat =</span> <span class="fu">mean</span>( ATE_hat ),</span>
<span id="cb626-3"><a href="#cb626-3" tabindex="-1"></a>             <span class="at">SE_true =</span> <span class="fu">sd</span>( ATE_hat ),</span>
<span id="cb626-4"><a href="#cb626-4" tabindex="-1"></a>             <span class="at">SE_hat =</span> <span class="fu">mean</span>( SE_hat ),</span>
<span id="cb626-5"><a href="#cb626-5" tabindex="-1"></a>             <span class="at">SE2_true =</span> <span class="fu">var</span>( ATE_hat ),</span>
<span id="cb626-6"><a href="#cb626-6" tabindex="-1"></a>             <span class="at">SE2_hat =</span> <span class="fu">mean</span>( SE_hat<span class="sc">^</span><span class="dv">2</span> ) ) <span class="sc">%&gt;%</span></span>
<span id="cb626-7"><a href="#cb626-7" tabindex="-1"></a>  <span class="fu">pivot_longer</span>( <span class="at">cols =</span> <span class="fu">c</span>(SE_true<span class="sc">:</span>SE2_hat ),</span>
<span id="cb626-8"><a href="#cb626-8" tabindex="-1"></a>                <span class="at">names_to =</span> <span class="fu">c</span>( <span class="st">&quot;estimand&quot;</span>, <span class="st">&quot;.value&quot;</span> ),</span>
<span id="cb626-9"><a href="#cb626-9" tabindex="-1"></a>                <span class="at">names_sep =</span><span class="st">&quot;_&quot;</span> ) <span class="sc">%&gt;%</span></span>
<span id="cb626-10"><a href="#cb626-10" tabindex="-1"></a>  <span class="fu">mutate</span>( <span class="at">inflate =</span> <span class="dv">100</span> <span class="sc">*</span> hat <span class="sc">/</span> true )</span></code></pre></div>
<pre><code>## # A tibble: 2 × 5
##   EATE_hat estimand  true   hat inflate
##      &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;
## 1    0.996 SE       0.389 0.377    96.9
## 2    0.996 SE2      0.151 0.142    93.9</code></pre>
<!--chapter:end:150-potential-outcomes-framework.Rmd-->
</div>
</div>
<div id="the-parametric-bootstrap" class="section level1 hasAnchor" number="22">
<h1 class="hasAnchor"><span class="header-section-number">22</span> The Parametric bootstrap<a href="#the-parametric-bootstrap" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p>An inference procedure very much connected to simulation studies is the parametric bootstrap.
The parametric bootstrap is a bootstrap technique designed to obtain standard error estimates for an estimated parametric model.
It can do better than the case-wise bootstrap in some circumstances, usually when there is need to avoid the discrete, chunky nature of a casewise bootstrap (which will only give values that exist in the original dataset).</p>
<p>For a parametric bootstrap, the core idea is to fit a given model to actual data, and then take the parameters we estimate from that model as the DGP parameters in a simulation study.
The parametric bootstrap is a simulation study for a specific scenario, and our goal is to assess how variable (and, possibly, biased) our estimator is for this specific scenario.
If the behavior of our estimator in our simulated scenario is similar to what it would be under repeated trials in the real world, then our bootstrap answers will be informative as to how well our original estimator performs in practice.
This is the bootstrap principle, or analogy with an additional assumption that the real-world is effectively well specified as the parameteric model we are fitting.</p>
<p>In particular we do the following:</p>
<ol style="list-style-type: decimal">
<li>generate data from a model with coefficients as estimated on the original data.</li>
<li>repeatedly estimate our target quantity on a series of synthetic data sets, all generated from this model.</li>
<li>examine this collection of estimates to assess the character of the estimates themselves, i.e. how much they vary, whether we are systematically estimating too high or too low, and so forth.</li>
<li>The variance and bias of our estimates in our simulation is probably like the actual variance and bias of our original estimate (this is precisely the bootstrap analogy).</li>
</ol>
<p>A key feature of the parametric bootstrap is it is not, generally, a multifactor simulation experiment.
We fit our model to the data, and use our best estimate of the world, as given by the fit model, to generate our data.
This means we generally want to simulate in contexts that are (mostly) <em>pivotal</em>, meaning the distribution of our test statistic or point estimate is relatively stable across different scenarios.
In other words, we want the uncertainty of our estimator to not heavily depend on the exact parameter values we use in our simulation, so that if we are simulating with incorrect parameters our bootstrap analogy will still hold.</p>
<p>Often, to achieve a reasonable claim of being pivotal, we will focus on standardized statistics, such as the <span class="math inline">\(t\)</span>-statistic of</p>
<p><span class="math display">\[ t = \frac{est}{\widehat{SE}} \]</span>
It is more common for the distribution of a standardized test statistic to have a canonical distribution across scenarios than an absolute estimate.</p>
<div id="air-conditioners-a-stolen-case-study" class="section level2 hasAnchor" number="22.1">
<h2 class="hasAnchor"><span class="header-section-number">22.1</span> Air conditioners: a stolen case study<a href="#air-conditioners-a-stolen-case-study" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Following the case study presented in [CITE bootstrap book], consider some failure times of air conditioning units:</p>
<div class="sourceCode" id="cb628"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb628-1"><a href="#cb628-1" tabindex="-1"></a>dat <span class="ot">=</span> <span class="fu">c</span>( <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>, <span class="dv">18</span>, <span class="dv">43</span>, <span class="dv">85</span>, <span class="dv">91</span>, <span class="dv">98</span>, <span class="dv">100</span>, <span class="dv">130</span>, <span class="dv">230</span>, <span class="dv">487</span> )</span></code></pre></div>
<p>We are interested in the log of the average failure time:</p>
<div class="sourceCode" id="cb629"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb629-1"><a href="#cb629-1" tabindex="-1"></a>n <span class="ot">=</span> <span class="fu">length</span>(dat)</span>
<span id="cb629-2"><a href="#cb629-2" tabindex="-1"></a>y.bar <span class="ot">=</span> <span class="fu">mean</span>(dat)</span>
<span id="cb629-3"><a href="#cb629-3" tabindex="-1"></a>theta.hat <span class="ot">=</span> <span class="fu">log</span>( y.bar )</span>
<span id="cb629-4"><a href="#cb629-4" tabindex="-1"></a></span>
<span id="cb629-5"><a href="#cb629-5" tabindex="-1"></a><span class="fu">c</span>( <span class="at">n =</span> n, <span class="at">y.bar =</span> y.bar, <span class="at">theta.hat =</span> theta.hat )</span></code></pre></div>
<pre><code>##          n      y.bar  theta.hat 
##  12.000000 108.083333   4.682903</code></pre>
<p>We are interested in this because we are modeling the failure time of the air conditioners with an exponential distribution.
This means we will generate new failure times with an exponential distribution:</p>
<div class="sourceCode" id="cb631"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb631-1"><a href="#cb631-1" tabindex="-1"></a>reps <span class="ot">=</span> <span class="fu">replicate</span>( <span class="dv">10000</span>, {</span>
<span id="cb631-2"><a href="#cb631-2" tabindex="-1"></a>    smp <span class="ot">=</span> <span class="fu">rexp</span>(n, <span class="dv">1</span><span class="sc">/</span>y.bar)</span>
<span id="cb631-3"><a href="#cb631-3" tabindex="-1"></a>    <span class="fu">log</span>( <span class="fu">mean</span>( smp ) )</span>
<span id="cb631-4"><a href="#cb631-4" tabindex="-1"></a>})</span>
<span id="cb631-5"><a href="#cb631-5" tabindex="-1"></a></span>
<span id="cb631-6"><a href="#cb631-6" tabindex="-1"></a>res_par <span class="ot">=</span> <span class="fu">tibble</span>( </span>
<span id="cb631-7"><a href="#cb631-7" tabindex="-1"></a>  <span class="at">bias.hat =</span> <span class="fu">mean</span>( reps ) <span class="sc">-</span> theta.hat,</span>
<span id="cb631-8"><a href="#cb631-8" tabindex="-1"></a>  <span class="at">var.hat =</span> <span class="fu">var</span>( reps ),</span>
<span id="cb631-9"><a href="#cb631-9" tabindex="-1"></a>  <span class="at">CIlog_low =</span> theta.hat <span class="sc">+</span> bias.hat <span class="sc">-</span> <span class="fu">sqrt</span>(var.hat) <span class="sc">*</span> <span class="fu">qnorm</span>(<span class="fl">0.975</span>),</span>
<span id="cb631-10"><a href="#cb631-10" tabindex="-1"></a>  <span class="at">CIlog_high =</span> theta.hat <span class="sc">+</span> bias.hat <span class="sc">-</span> <span class="fu">sqrt</span>(var.hat) <span class="sc">*</span> <span class="fu">qnorm</span>(<span class="fl">0.025</span>),</span>
<span id="cb631-11"><a href="#cb631-11" tabindex="-1"></a>  <span class="at">CI_low =</span> <span class="fu">exp</span>( CIlog_low ),</span>
<span id="cb631-12"><a href="#cb631-12" tabindex="-1"></a>  <span class="at">CI_high =</span> <span class="fu">exp</span>( CIlog_high ) )</span>
<span id="cb631-13"><a href="#cb631-13" tabindex="-1"></a>res_par</span></code></pre></div>
<pre><code>## # A tibble: 1 × 6
##   bias.hat var.hat CIlog_low CIlog_high CI_low
##      &lt;dbl&gt;   &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;  &lt;dbl&gt;
## 1  -0.0420  0.0856      4.07       5.21   58.4
## # ℹ 1 more variable: CI_high &lt;dbl&gt;</code></pre>
<p>Note how we are, as usual, in our standard simulation framework of repeatidly (1) generating data and (2) analyzing the simulated data.
Nothing is changed.</p>
<p>The nonparametric, or case-wise, bootstrap (this is what people normally mean when they say bootstrap) would look like this:</p>
<div class="sourceCode" id="cb633"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb633-1"><a href="#cb633-1" tabindex="-1"></a>reps <span class="ot">=</span> <span class="fu">replicate</span>( <span class="dv">10000</span>, {</span>
<span id="cb633-2"><a href="#cb633-2" tabindex="-1"></a>    smp <span class="ot">=</span> <span class="fu">sample</span>( dat, <span class="at">replace=</span><span class="cn">TRUE</span> )</span>
<span id="cb633-3"><a href="#cb633-3" tabindex="-1"></a>    <span class="fu">log</span>( <span class="fu">mean</span>( smp ) )</span>
<span id="cb633-4"><a href="#cb633-4" tabindex="-1"></a>})</span>
<span id="cb633-5"><a href="#cb633-5" tabindex="-1"></a></span>
<span id="cb633-6"><a href="#cb633-6" tabindex="-1"></a>res_np <span class="ot">=</span> <span class="fu">tibble</span>( </span>
<span id="cb633-7"><a href="#cb633-7" tabindex="-1"></a>  <span class="at">bias.hat =</span> <span class="fu">mean</span>( reps ) <span class="sc">-</span> theta.hat,</span>
<span id="cb633-8"><a href="#cb633-8" tabindex="-1"></a>  <span class="at">var.hat =</span> <span class="fu">var</span>( reps ),</span>
<span id="cb633-9"><a href="#cb633-9" tabindex="-1"></a>  <span class="at">CIlog_low =</span> theta.hat <span class="sc">+</span> bias.hat <span class="sc">-</span> <span class="fu">sqrt</span>(var.hat) <span class="sc">*</span> <span class="fu">qnorm</span>(<span class="fl">0.975</span>),</span>
<span id="cb633-10"><a href="#cb633-10" tabindex="-1"></a>  <span class="at">CIlog_high =</span> theta.hat <span class="sc">+</span> bias.hat <span class="sc">-</span> <span class="fu">sqrt</span>(var.hat) <span class="sc">*</span> <span class="fu">qnorm</span>(<span class="fl">0.025</span>),</span>
<span id="cb633-11"><a href="#cb633-11" tabindex="-1"></a>  <span class="at">CI_low =</span> <span class="fu">exp</span>( CIlog_low ),</span>
<span id="cb633-12"><a href="#cb633-12" tabindex="-1"></a>  <span class="at">CI_high =</span> <span class="fu">exp</span>( CIlog_high ) )</span>
<span id="cb633-13"><a href="#cb633-13" tabindex="-1"></a></span>
<span id="cb633-14"><a href="#cb633-14" tabindex="-1"></a></span>
<span id="cb633-15"><a href="#cb633-15" tabindex="-1"></a><span class="fu">bind_rows</span>( <span class="at">parametric =</span> res_par, </span>
<span id="cb633-16"><a href="#cb633-16" tabindex="-1"></a>           <span class="at">casewise =</span> res_np, <span class="at">.id =</span> <span class="st">&quot;method&quot;</span>) <span class="sc">%&gt;%</span></span>
<span id="cb633-17"><a href="#cb633-17" tabindex="-1"></a>  <span class="fu">mutate</span>( <span class="at">length =</span> CI_high <span class="sc">-</span> CI_low )</span></code></pre></div>
<pre><code>## # A tibble: 2 × 8
##   method     bias.hat var.hat CIlog_low CIlog_high
##   &lt;chr&gt;         &lt;dbl&gt;   &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;
## 1 parametric  -0.0420  0.0856      4.07       5.21
## 2 casewise    -0.0651  0.132       3.90       5.33
## # ℹ 3 more variables: CI_low &lt;dbl&gt;,
## #   CI_high &lt;dbl&gt;, length &lt;dbl&gt;</code></pre>
<p>This is <em>also</em> a simulation: our data generating process is a bit more vague, however, as we are just resampling the data.
This means our estimands are not as clearly specified.
For example, in our parameteric approach, our target parameter is known to be true.
In the case-wise, the connection between our DGP and the parameter <code>theta.hat</code> is less explicit.</p>
<p>Overall, in this case, our parametric bootstrap can model the tail behavior of an exponential better than case-wise.
Especially considering the small number of observations, it is going to be a more faithful representation of what we are doing–provided our model is well specified for the real world distribution.</p>
<!--chapter:end:160-parametric-bootstrap.Rmd-->
</div>
</div>
<div id="appendix-appendices" class="section level1 unnumbered hasAnchor">
<h1 class="unnumbered hasAnchor">(APPENDIX) Appendices<a href="#appendix-appendices" class="anchor-section" aria-label="Anchor link to header"></a></h1>
</div>
<div id="coding-tidbits" class="section level1 hasAnchor" number="23">
<h1 class="hasAnchor"><span class="header-section-number">23</span> Coding tidbits<a href="#coding-tidbits" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p>This chapter is not specifically about simulation, but it does have a few tips and tricks regarding coding that are worth attending to.</p>
<div id="more-repeating-oneself" class="section level2 hasAnchor" number="23.1">
<h2 class="hasAnchor"><span class="header-section-number">23.1</span> How to repeat yourself<a href="#more-repeating-oneself" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>At the heart of simulation is replication: we want to do the same task over and over. In this book we have showcased a variety of tools to replicate a random process. In this section we give a formal presentation of these tools.</p>
<div id="using-replicate" class="section level3 hasAnchor" number="23.1.1">
<h3 class="hasAnchor"><span class="header-section-number">23.1.1</span> Using <code>replicate()</code><a href="#using-replicate" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>The <code>replicate( n, expr, simplify )</code> method is a base-R function, which takes two arguments: a number <code>n</code> and an expression <code>expr</code> to run repeatedly. You can set <code>simplify = FALSE</code> to get the output of the function as a list, and if you set <code>simplify = TRUE</code> then R will try to simplify your results into an array.</p>
<p>For simple tasks where your expression gives you a single number, replicate will produce a vector of numbers:</p>
<div class="sourceCode" id="cb635"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb635-1"><a href="#cb635-1" tabindex="-1"></a><span class="fu">replicate</span>( <span class="dv">5</span>, <span class="fu">mean</span>( <span class="fu">rpois</span>( <span class="dv">3</span>, <span class="at">lambda =</span> <span class="dv">1</span> ) ) )</span></code></pre></div>
<pre><code>## [1] 0.6666667 1.0000000 0.6666667 1.0000000
## [5] 0.6666667</code></pre>
<p>If you do not simplify, you then will need to massage your results:</p>
<div class="sourceCode" id="cb637"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb637-1"><a href="#cb637-1" tabindex="-1"></a>one_run <span class="ot">&lt;-</span> <span class="cf">function</span>() {</span>
<span id="cb637-2"><a href="#cb637-2" tabindex="-1"></a>  dd <span class="ot">=</span> <span class="fu">rpois</span>( <span class="dv">3</span>, <span class="at">lambda =</span> <span class="dv">1</span> )</span>
<span id="cb637-3"><a href="#cb637-3" tabindex="-1"></a>  <span class="fu">tibble</span>( <span class="at">mean =</span> <span class="fu">mean</span>( dd ), <span class="at">sd =</span> <span class="fu">sd</span>( dd ) )</span>
<span id="cb637-4"><a href="#cb637-4" tabindex="-1"></a>}</span>
<span id="cb637-5"><a href="#cb637-5" tabindex="-1"></a>rps <span class="ot">&lt;-</span> <span class="fu">replicate</span>( <span class="dv">2</span>, <span class="fu">one_run</span>(), <span class="at">simplify =</span> <span class="cn">FALSE</span> )</span>
<span id="cb637-6"><a href="#cb637-6" tabindex="-1"></a>rps</span></code></pre></div>
<pre><code>## [[1]]
## # A tibble: 1 × 2
##    mean    sd
##   &lt;dbl&gt; &lt;dbl&gt;
## 1  1.67  1.53
## 
## [[2]]
## # A tibble: 1 × 2
##    mean    sd
##   &lt;dbl&gt; &lt;dbl&gt;
## 1  1.33  1.15</code></pre>
<p>In particular, you will probably stack all your tibbles to make one large dataset:</p>
<div class="sourceCode" id="cb639"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb639-1"><a href="#cb639-1" tabindex="-1"></a>rps <span class="ot">&lt;-</span> <span class="fu">bind_rows</span>( rps )</span>
<span id="cb639-2"><a href="#cb639-2" tabindex="-1"></a>rps</span></code></pre></div>
<pre><code>## # A tibble: 2 × 2
##    mean    sd
##   &lt;dbl&gt; &lt;dbl&gt;
## 1  1.67  1.53
## 2  1.33  1.15</code></pre>
<p>Note that you give replicate a full piece of code that would run on its own. You can even give a whole block of code in curly braces.
This is exactly the same code as before:</p>
<div class="sourceCode" id="cb641"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb641-1"><a href="#cb641-1" tabindex="-1"></a>rps <span class="ot">&lt;-</span> <span class="fu">replicate</span>( <span class="dv">2</span>, {</span>
<span id="cb641-2"><a href="#cb641-2" tabindex="-1"></a>  dd <span class="ot">=</span> <span class="fu">rpois</span>( <span class="dv">3</span>, <span class="at">lambda =</span> <span class="dv">1</span> )</span>
<span id="cb641-3"><a href="#cb641-3" tabindex="-1"></a>  <span class="fu">tibble</span>( <span class="at">mean =</span> <span class="fu">mean</span>( dd ), <span class="at">sd =</span> <span class="fu">sd</span>( dd ) )</span>
<span id="cb641-4"><a href="#cb641-4" tabindex="-1"></a>}, <span class="at">simplify =</span> <span class="cn">FALSE</span> ) <span class="sc">%&gt;%</span></span>
<span id="cb641-5"><a href="#cb641-5" tabindex="-1"></a>  <span class="fu">bind_rows</span>()</span></code></pre></div>
<p>The <code>replicate()</code> method is good for simple tasks, but for more general use, you will probably want to use <code>map()</code>.</p>
</div>
<div id="using-map" class="section level3 hasAnchor" number="23.1.2">
<h3 class="hasAnchor"><span class="header-section-number">23.1.2</span> Using <code>map()</code><a href="#using-map" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>The tidyverse way of repeating oneself is the <code>map()</code> method. The nice thing about <code>map()</code> is you map over a list of values, and thus can call a function repeatedly, but with a shifting set of inputs.</p>
<div class="sourceCode" id="cb642"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb642-1"><a href="#cb642-1" tabindex="-1"></a>one_run_v2 <span class="ot">&lt;-</span> <span class="cf">function</span>( N ) {</span>
<span id="cb642-2"><a href="#cb642-2" tabindex="-1"></a>  dd <span class="ot">=</span> <span class="fu">rpois</span>( N, <span class="at">lambda =</span> <span class="dv">1</span> )</span>
<span id="cb642-3"><a href="#cb642-3" tabindex="-1"></a>  <span class="fu">tibble</span>( <span class="at">mean =</span> <span class="fu">mean</span>( dd ), <span class="at">sd =</span> <span class="fu">sd</span>( dd ) )</span>
<span id="cb642-4"><a href="#cb642-4" tabindex="-1"></a>}</span>
<span id="cb642-5"><a href="#cb642-5" tabindex="-1"></a>n_list <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">5</span>)</span>
<span id="cb642-6"><a href="#cb642-6" tabindex="-1"></a>rps <span class="ot">&lt;-</span> <span class="fu">map</span>( n_list, one_run_v2 )</span>
<span id="cb642-7"><a href="#cb642-7" tabindex="-1"></a>rps</span></code></pre></div>
<pre><code>## [[1]]
## # A tibble: 1 × 2
##    mean    sd
##   &lt;dbl&gt; &lt;dbl&gt;
## 1   0.5 0.707
## 
## [[2]]
## # A tibble: 1 × 2
##    mean    sd
##   &lt;dbl&gt; &lt;dbl&gt;
## 1   0.8 0.837</code></pre>
<p>You again would want to stack your results:</p>
<div class="sourceCode" id="cb644"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb644-1"><a href="#cb644-1" tabindex="-1"></a><span class="fu">bind_rows</span>(rps)</span></code></pre></div>
<pre><code>## # A tibble: 2 × 2
##    mean    sd
##   &lt;dbl&gt; &lt;dbl&gt;
## 1   0.5 0.707
## 2   0.8 0.837</code></pre>
<p>We have a small issue here, however, which is we lost what we <em>gave</em> <code>map()</code> for each call.
If we know we only get one row back from each call, we can add the column directly:</p>
<div class="sourceCode" id="cb646"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb646-1"><a href="#cb646-1" tabindex="-1"></a>rps<span class="sc">$</span>n <span class="ot">=</span> n_list</span></code></pre></div>
<p>A better approach is to <em>name</em> your list of input parameters, and then your <code>map</code> function can add those names for you as a new column when you stack:</p>
<div class="sourceCode" id="cb647"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb647-1"><a href="#cb647-1" tabindex="-1"></a>n_list <span class="sc">%&gt;%</span></span>
<span id="cb647-2"><a href="#cb647-2" tabindex="-1"></a>  <span class="fu">set_names</span>() <span class="sc">%&gt;%</span></span>
<span id="cb647-3"><a href="#cb647-3" tabindex="-1"></a>  <span class="fu">map</span>( one_run_v2 ) <span class="sc">%&gt;%</span></span>
<span id="cb647-4"><a href="#cb647-4" tabindex="-1"></a>  <span class="fu">bind_rows</span>( <span class="at">.id =</span> <span class="st">&quot;n&quot;</span> )</span></code></pre></div>
<pre><code>## # A tibble: 2 × 3
##   n      mean    sd
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 2       2    0   
## 2 5       1.4  1.14</code></pre>
<p>An advantage here is if you are returning multiple rows (e.g., one row for each estimator tested in a more complex simulation), all the rows will get named correctly and automatically.</p>
<p>In older tidyverse worlds, you will see methods such as <code>map_dbl()</code> or <code>map_dfr()</code>. These will automatically massage your output into the target type. <code>map_dfr()</code> will automatically bind rows, and <code>map_dbl()</code> will try to simplify the output into a list of doubles. Modern tidyverse no longer likes this, which we find somewhat sad.</p>
<p>To read more about <code>map()</code>, check out out <a href="https://r4ds.had.co.nz/iteration.html#the-map-functions">Section 21.5 of R for Data Science (1st edition)</a>, which provides a more thorough introduction to mapping.</p>
</div>
<div id="map-with-no-inputs" class="section level3 hasAnchor" number="23.1.3">
<h3 class="hasAnchor"><span class="header-section-number">23.1.3</span> map with no inputs<a href="#map-with-no-inputs" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>If you do not have parameters, but still want to use <code>map()</code>, you can. E.g.,</p>
<div class="sourceCode" id="cb649"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb649-1"><a href="#cb649-1" tabindex="-1"></a><span class="fu">map_dfr</span>( <span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>, \(.) <span class="fu">one_run</span>() )</span></code></pre></div>
<pre><code>## # A tibble: 3 × 2
##    mean    sd
##   &lt;dbl&gt; &lt;dbl&gt;
## 1 1     1    
## 2 0.667 0.577
## 3 0     0</code></pre>
<p>The weird “(.)” is a shorthand for a function that takes one argument and then calls <code>one_run()</code> with no arguments. We are using the 1:3 notation to just make a list of the right length (3 replicates, in this case) to map over. A lot of fuss! Just use <code>replicate()</code></p>
<p>To make all of this more clear, consider passing arguments that you manipulate on the fly:</p>
<div class="sourceCode" id="cb651"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb651-1"><a href="#cb651-1" tabindex="-1"></a><span class="fu">map_dfr</span>( n_list, \(x) <span class="fu">one_run_v2</span>( x<span class="sc">*</span>x ) )</span></code></pre></div>
<pre><code>## # A tibble: 2 × 2
##    mean    sd
##   &lt;dbl&gt; &lt;dbl&gt;
## 1  1     1.41
## 2  1.16  1.11</code></pre>
<p>Anonymous functions, as these are called, can be useful to connect your pieces of simulation together.</p>
</div>
<div id="other-approaches-for-repetition" class="section level3 hasAnchor" number="23.1.4">
<h3 class="hasAnchor"><span class="header-section-number">23.1.4</span> Other approaches for repetition<a href="#other-approaches-for-repetition" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>In the past, there was a tidyverse method called <code>rerun()</code>, but it is currently out of favor.
Originally, <code>rerun()</code> did exactly that: you gave it a number and a block of code, and it would rerun the block of code that many times, giving you the results as a list.
<code>rerun()</code> and <code>replicate()</code> are near equivalents.
As we saw, <code>replicate()</code> does what its name suggests—it replicates the result of an expression a specified number of times. Setting <code>simplify = FALSE</code> returns the output as a list (just like <code>rerun()</code>.</p>
</div>
</div>
<div id="default-arguments" class="section level2 hasAnchor" number="23.2">
<h2 class="hasAnchor"><span class="header-section-number">23.2</span> Default arguments for functions<a href="#default-arguments" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>To write functions that are both easy to use and configurable, we find it helpful to set default arguments.
For example,</p>
<div class="sourceCode" id="cb653"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb653-1"><a href="#cb653-1" tabindex="-1"></a>my_function <span class="ot">=</span> <span class="cf">function</span>( <span class="at">a =</span> <span class="dv">10</span>, <span class="at">b =</span> <span class="dv">20</span> ) {</span>
<span id="cb653-2"><a href="#cb653-2" tabindex="-1"></a>     <span class="dv">100</span> <span class="sc">*</span> a <span class="sc">+</span> b</span>
<span id="cb653-3"><a href="#cb653-3" tabindex="-1"></a>}</span>
<span id="cb653-4"><a href="#cb653-4" tabindex="-1"></a></span>
<span id="cb653-5"><a href="#cb653-5" tabindex="-1"></a><span class="fu">my_function</span>()</span></code></pre></div>
<pre><code>## [1] 1020</code></pre>
<div class="sourceCode" id="cb655"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb655-1"><a href="#cb655-1" tabindex="-1"></a><span class="fu">my_function</span>( <span class="dv">5</span> )</span></code></pre></div>
<pre><code>## [1] 520</code></pre>
<div class="sourceCode" id="cb657"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb657-1"><a href="#cb657-1" tabindex="-1"></a><span class="fu">my_function</span>( <span class="at">b =</span> <span class="dv">5</span> )</span></code></pre></div>
<pre><code>## [1] 1005</code></pre>
<div class="sourceCode" id="cb659"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb659-1"><a href="#cb659-1" tabindex="-1"></a><span class="fu">my_function</span>( <span class="at">b =</span> <span class="dv">5</span>, <span class="at">a =</span> <span class="dv">1</span> )</span></code></pre></div>
<pre><code>## [1] 105</code></pre>
<p>We can still call <code>my_function()</code> when we don’t know what the arguments are, but then when we know more about the function, we can specify things of interest.
Lots of R commands work exactly this way, and for good reason.</p>
<p>Especially for code to generate random datasets, default arguments can be a lifesaver as you can then call the method before you know exactly what everything means.</p>
<p>For example, consider the <code>blkvar</code> package that has some code to generate blocked randomized datasets.
We might locate a promising method, and type it in:</p>
<div class="sourceCode" id="cb661"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb661-1"><a href="#cb661-1" tabindex="-1"></a><span class="fu">library</span>( blkvar )</span>
<span id="cb661-2"><a href="#cb661-2" tabindex="-1"></a><span class="fu">generate_blocked_data</span>()</span></code></pre></div>
<pre><code>## Error in generate_blocked_data(): argument &quot;n_k&quot; is missing, with no default</code></pre>
<p>That didn’t work, but let’s provide some block sizes and see what happens:</p>
<div class="sourceCode" id="cb663"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb663-1"><a href="#cb663-1" tabindex="-1"></a><span class="fu">generate_blocked_data</span>( <span class="at">n_k =</span> <span class="fu">c</span>( <span class="dv">3</span>, <span class="dv">2</span> ) )</span></code></pre></div>
<pre><code>##    B         Y0       Y1
## 1 B1  0.1651598 6.371708
## 2 B1 -0.7767558 5.613676
## 3 B1 -1.4736741 4.856552
## 4 B2 -1.0636928 4.448634
## 5 B2  0.1533518 4.334540</code></pre>
<p>Nice! We see that we have a block ID and the control and treatment potential outcomes. We also don’t see a random assignment variable, so that tells us we probably need some other methods as well.
But we can play with this as it stands right away.</p>
<p>Next we can see that there are many things we might tune:</p>
<div class="sourceCode" id="cb665"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb665-1"><a href="#cb665-1" tabindex="-1"></a><span class="fu">args</span>( generate_blocked_data )</span></code></pre></div>
<pre><code>## function (n_k, sigma_alpha = 1, sigma_beta = 0, beta = 5, sigma_0 = 1, 
##     sigma_1 = 1, corr = 0.5, exact = FALSE) 
## NULL</code></pre>
<p>The documentation will tell us more, but if we just need some sample data, we can quickly assess our method before having to do much reading and understanding.
Only once we have identified what we need do we have to turn to the documentation itself.</p>
</div>
<div id="about-source-command" class="section level2 hasAnchor" number="23.3">
<h2 class="hasAnchor"><span class="header-section-number">23.3</span> The source command and keeping things organized<a href="#about-source-command" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Simulations have two general phases: generate your results and analyze your results.
The ending of the first phase should be to save the generated results.
The beginning of the second phase should then be to load the results from a file and analyze them.
These phases can be in a separate ‘.R’ files.
Dividing your simulations in this way allows for easily changing how one <em>analyzes</em> an experiment without re-running the entire thing.</p>
<p>This is the simplest version of a general principle of a larger project: put code for different purposes in different files.</p>
<p>For example, at the minimum, for a complex multifactor simulation, you will likely have three general collections of code, not including the code to run the multifactor simulation itself:</p>
<ul>
<li>Code for generating data</li>
<li>Code for analyzing data</li>
<li>Code for running a single simulation scenario</li>
</ul>
<p>If each of these pieces is large and complex, you might consider putting them in three different <code>.R</code> files.
Then, in your primary simulation driver, you could source these files.
E.g.,</p>
<div class="sourceCode" id="cb667"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb667-1"><a href="#cb667-1" tabindex="-1"></a><span class="fu">source</span>( <span class="st">&quot;pack_data_generators.R&quot;</span> )</span>
<span id="cb667-2"><a href="#cb667-2" tabindex="-1"></a><span class="fu">source</span>( <span class="st">&quot;pack_estimators.R&quot;</span> )</span>
<span id="cb667-3"><a href="#cb667-3" tabindex="-1"></a><span class="fu">source</span>( <span class="st">&quot;pack_simulation_support.R&quot;</span> )</span></code></pre></div>
<p>The <code>source()</code> command essentially “cuts and pastes” the contents of the given file into your R work session.
If the file has code to run, it will run it.
If the file has a list of methods, those methods will now be available for use.</p>
<p>Alternatively, <code>pack_simulation_support.R</code> could, inside it, source the other two files.
You would then only source the single simulation support file in your primay file.</p>
<p>One reason for putting code in individual files is you can then have testing code in each of your files (in False blocks, like described above), testing each of your components.
Then, when you are not focused on that component, you don’t have to look at that testing code.</p>
<p>Another good reason for this type of modular organizing is you can then have a variety of data generators, forming a library of options.
You can then easily create different simulations that use different pieces, in a larger project.</p>
<p>For example, in one recent simulation project on estimators for an Instrumental Variable analysis, we had several different data generators for generating different types of compliance patterns (IVs are often used to handle noncompliance in randomized experiments).
Our data generation code file then had several methods:</p>
<pre><code>&gt; ls()
[1] &quot;describe_sim_data&quot;  &quot;make_dat&quot;           &quot;make.dat.1side&quot;     
[4] &quot;make.dat.1side.old&quot; &quot;make.dat.orig&quot;      &quot;make.dat.simple&quot;
[7] &quot;make.dat.tuned&quot;     &quot;rand.exp&quot;           &quot;summarize_sim_data&quot;</code></pre>
<p>The describe and summarize methods printed various statistics about a sample dataset; these are used to debug and understand how the generated data looks.
We also had a variety of different DGP methods because we had different versions that came up as we were trying to chase down errors in our estimators and understand strange behavior.</p>
<p>Putting the estimators in a different file also had a nice additional purpose: we also had an applied data example in our work, and we could simply source that file and use those estimators on our actual data.
This ensured our simulation and applied analysis were perfectly aligned in terms of the estimators we were using.
Also, as we debugged our estimators and tweaked them, we immediately could re-run our applied analysis to update those results with minimal effort.</p>
<p>Modular programming is key.</p>
</div>
<div id="about-keeping-tests-with-FALSE" class="section level2 hasAnchor" number="23.4">
<h2 class="hasAnchor"><span class="header-section-number">23.4</span> Testing and debugging code in your scripts<a href="#about-keeping-tests-with-FALSE" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>If you have an extended script with a list of functions, you might have a lot of code that runs each function in turn, so you can easily remind yourself of what it does, or what the output looks like.
One way to keep this code around, but not have it run all the time when you run your script, is to put the code inside a “FALSE block,” that might look like so:</p>
<div class="sourceCode" id="cb669"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb669-1"><a href="#cb669-1" tabindex="-1"></a><span class="cf">if</span> ( <span class="cn">FALSE</span> ) {</span>
<span id="cb669-2"><a href="#cb669-2" tabindex="-1"></a>  res <span class="ot">&lt;-</span> <span class="fu">my_function</span>( <span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">30</span> )</span>
<span id="cb669-3"><a href="#cb669-3" tabindex="-1"></a>  res</span>
<span id="cb669-4"><a href="#cb669-4" tabindex="-1"></a>  <span class="co"># Some notes as to what I want to see.</span></span>
<span id="cb669-5"><a href="#cb669-5" tabindex="-1"></a>  </span>
<span id="cb669-6"><a href="#cb669-6" tabindex="-1"></a>  <span class="fu">sd</span>( res )</span>
<span id="cb669-7"><a href="#cb669-7" tabindex="-1"></a>  <span class="co"># This should be around 20</span></span>
<span id="cb669-8"><a href="#cb669-8" tabindex="-1"></a>}</span></code></pre></div>
<p>You can then, when looking at the script, paste the code inside the block into the console when you want to run it.
If you source the script, however, it will not run at all, and thus your code will source faster and not print out any extraneous output.</p>
</div>
<div id="about-browser-debugging" class="section level2 hasAnchor" number="23.5">
<h2 class="hasAnchor"><span class="header-section-number">23.5</span> Debugging with browser<a href="#about-browser-debugging" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Consider the following code taken from a simulation:</p>
<div class="sourceCode" id="cb670"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb670-1"><a href="#cb670-1" tabindex="-1"></a>    <span class="cf">if</span> ( <span class="fu">any</span>( <span class="fu">is.na</span>( rs<span class="sc">$</span>estimate ) ) ) {</span>
<span id="cb670-2"><a href="#cb670-2" tabindex="-1"></a>        <span class="fu">browser</span>()</span>
<span id="cb670-3"><a href="#cb670-3" tabindex="-1"></a>    }</span></code></pre></div>
<p>The <code>browser()</code> command stops your code and puts you in an interactive console where you can look at different objects and see what is happening.
Having it triggered when something bad happens (in this case when a set of estimates has an unexpected NA) can help untangle what is driving a rare event.</p>
</div>
<div id="about-stopifnot" class="section level2 hasAnchor" number="23.6">
<h2 class="hasAnchor"><span class="header-section-number">23.6</span> Protecting your functions with “stop”<a href="#about-stopifnot" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>When writing functions, especially those that take a lot of parameters, it is often wise to include <code>stopifnot()</code> statements at the top to verify the function is getting what it expects.
These are sometimes called “assert statements” and are a tool for making errors show up as early as possible.
For example, look at this (fake) example of generating data with different means and variances</p>
<div class="sourceCode" id="cb671"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb671-1"><a href="#cb671-1" tabindex="-1"></a>make_groups <span class="ot">&lt;-</span> <span class="cf">function</span>( means, sds ) {</span>
<span id="cb671-2"><a href="#cb671-2" tabindex="-1"></a>  Y <span class="ot">=</span> <span class="fu">rnorm</span>( <span class="fu">length</span>(means), <span class="at">mean=</span>means, <span class="at">sd =</span> sds )</span>
<span id="cb671-3"><a href="#cb671-3" tabindex="-1"></a>  <span class="fu">round</span>( Y )</span>
<span id="cb671-4"><a href="#cb671-4" tabindex="-1"></a>}</span></code></pre></div>
<p>If we call it, but provide different lengths for our means and variances, nothing happens, because R simply recycles the standard deviation parameter:</p>
<div class="sourceCode" id="cb672"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb672-1"><a href="#cb672-1" tabindex="-1"></a><span class="fu">make_groups</span>( <span class="fu">c</span>(<span class="dv">100</span>,<span class="dv">200</span>,<span class="dv">300</span>,<span class="dv">400</span>), <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">100</span>,<span class="dv">10000</span>) )</span></code></pre></div>
<pre><code>## [1]  100  206 8034  398</code></pre>
<p>If this function was used in our data generating code, we would see the warnings but might not know exactly what they were.
We can instead protect our function by putting an <em>assert statements</em> in our function like this:</p>
<div class="sourceCode" id="cb674"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb674-1"><a href="#cb674-1" tabindex="-1"></a>make_groups <span class="ot">&lt;-</span> <span class="cf">function</span>( means, sds ) {</span>
<span id="cb674-2"><a href="#cb674-2" tabindex="-1"></a>  <span class="fu">stopifnot</span>( <span class="fu">length</span>(means) <span class="sc">==</span> <span class="fu">length</span>(sds) )</span>
<span id="cb674-3"><a href="#cb674-3" tabindex="-1"></a>  Y <span class="ot">=</span> <span class="fu">rnorm</span>( <span class="fu">length</span>(means), <span class="at">mean=</span>means, <span class="at">sd =</span> sds )</span>
<span id="cb674-4"><a href="#cb674-4" tabindex="-1"></a>  <span class="fu">round</span>( Y )</span>
<span id="cb674-5"><a href="#cb674-5" tabindex="-1"></a>}</span></code></pre></div>
<p>This ensures your code is getting called as you intended.
What is nasty about this possible error is nothing is telling you something is wrong!
You could build an entire simulation on this, not realizing that your fourth group has the variance of your first, and get results that make no sense to you.
You could even publish something based on a finding that depends on this error, which would eventually be quite embarrasing.</p>
<p>These statements can also serve as a sort of documentation as to what you expect.
Consider, for example:</p>
<div class="sourceCode" id="cb675"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb675-1"><a href="#cb675-1" tabindex="-1"></a>make_xy <span class="ot">&lt;-</span> <span class="cf">function</span>( N, mu_x, mu_y, rho ) {</span>
<span id="cb675-2"><a href="#cb675-2" tabindex="-1"></a>  <span class="fu">stopifnot</span>( <span class="sc">-</span><span class="dv">1</span> <span class="sc">&lt;=</span> rho <span class="sc">&amp;&amp;</span> rho <span class="sc">&lt;=</span> <span class="dv">1</span> )</span>
<span id="cb675-3"><a href="#cb675-3" tabindex="-1"></a>  X <span class="ot">=</span> mu_x <span class="sc">+</span> <span class="fu">rnorm</span>( N )</span>
<span id="cb675-4"><a href="#cb675-4" tabindex="-1"></a>  Y <span class="ot">=</span> mu_y <span class="sc">+</span> rho <span class="sc">*</span> X <span class="sc">+</span> <span class="fu">sqrt</span>(<span class="dv">1</span><span class="sc">-</span>rho<span class="sc">^</span><span class="dv">2</span>)<span class="sc">*</span><span class="fu">rnorm</span>(N)</span>
<span id="cb675-5"><a href="#cb675-5" tabindex="-1"></a>  <span class="fu">tibble</span>(<span class="at">X =</span> X, <span class="at">Y=</span>Y)</span>
<span id="cb675-6"><a href="#cb675-6" tabindex="-1"></a>}</span></code></pre></div>
<p>Here we see that rho should be between -1 and 1 quite clearly.
A good reminder of what the parameter is for.</p>
<p>This also protects you from inadvetently misremembering the order of your parameters when you call the function (although it is good practice to name your parameters as you pass).
Consider:</p>
<div class="sourceCode" id="cb676"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb676-1"><a href="#cb676-1" tabindex="-1"></a>a <span class="ot">&lt;-</span> <span class="fu">make_xy</span>( <span class="dv">10</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="fl">0.75</span> )</span>
<span id="cb676-2"><a href="#cb676-2" tabindex="-1"></a>b <span class="ot">&lt;-</span> <span class="fu">make_xy</span>( <span class="dv">10</span>, <span class="fl">0.75</span>, <span class="dv">2</span>, <span class="dv">3</span> )</span></code></pre></div>
<pre><code>## Error in make_xy(10, 0.75, 2, 3): -1 &lt;= rho &amp;&amp; rho &lt;= 1 is not TRUE</code></pre>
<div class="sourceCode" id="cb678"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb678-1"><a href="#cb678-1" tabindex="-1"></a>c <span class="ot">&lt;-</span> <span class="fu">make_xy</span>( <span class="dv">10</span>, <span class="at">rho =</span> <span class="fl">0.75</span>, <span class="at">mu_x =</span> <span class="dv">2</span>, <span class="at">mu_y =</span> <span class="dv">3</span> )</span></code></pre></div>
<!--chapter:end:200-coding-tidbits.Rmd-->
</div>
</div>
<div id="further-readings-and-resources" class="section level1 hasAnchor" number="24">
<h1 class="hasAnchor"><span class="header-section-number">24</span> Further readings and resources<a href="#further-readings-and-resources" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p>We close with a list of things of interest we have discovered while writing this text.</p>
<ul>
<li><p><a href="https://doi.org/10.1002/sim.8086">Morris, White, &amp; Crowther (2019)</a>. Using simulation studies to evaluate statistical methods.</p></li>
<li><p>High-level simulation design considerations.</p></li>
<li><p>Details about performance criteria calculations.</p></li>
<li><p>Stata-centric.</p></li>
<li><p><a href="https://github.com/philchalmers/SimDesign/wiki">SimDesign</a> R package (Chalmers, 2019)</p></li>
<li><p>Tools for building generic simulation workflows.</p></li>
<li><p><a href="http://www.tqmp.org/RegularArticles/vol16-4/p248/">Chalmers &amp; Adkin (2019)</a>. Writing effective and reliable Monte Carlo simulations with the SimDesign package.</p></li>
<li><p><a href="https://declaredesign.org/">DeclareDesign</a> (Blair, Cooper, Coppock, &amp; Humphreys)</p></li>
<li><p>Specialized suite of R packages for simulating research designs.</p></li>
<li><p>Design philosophy is very similar to “tidy” simulation approach.</p></li>
<li><p><a href="https://meghapsimatrix.github.io/simhelpers/index.html">SimHelpers</a> R package (Joshi &amp; Pustejovsky, 2020)</p></li>
<li><p>Helper functions for calculating performance criteria.</p></li>
<li><p>Includes Monte Carlo standard errors.</p></li>
</ul>
<!--chapter:end:210-futher-resources.Rmd-->
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-abdulkadirouglu2017research" class="csl-entry">
Abdulkadiroğlu, Atila, Joshua D Angrist, Yusuke Narita, and Parag A Pathak. 2017. <span>“Research Design Meets Market Design: Using Centralized Assignment for Impact Evaluation.”</span> <em>Econometrica</em> 85 (5): 1373–1432.
</div>
<div id="ref-Bloom:2016um" class="csl-entry">
Bloom, Howard S., Stephen W. Raudenbush, Michael J. Weiss, and Kristin Porter. 2016. <span>“<span class="nocase">Using Multisite Experiments to Study Cross-Site Variation in Treatment Effects: A Hybrid Approach With Fixed Intercepts and a Random Treatment Coefficient</span>.”</span> <em>Journal of Research on Educational Effectiveness</em> 10 (4): 0–0. <a href="https://doi.org/10.1080/19345747.2016.1264518">https://doi.org/10.1080/19345747.2016.1264518</a>.
</div>
<div id="ref-borenstein2021introduction" class="csl-entry">
Borenstein, Michael, Larry V. Hedges, Julian P. T. Higgins, and Hannah R. Rothstein. 2021. <em>Introduction to Meta-Analysis</em>. 3rd ed. Chichester, UK: John Wiley &amp; Sons.
</div>
<div id="ref-boulesteix2020Replicationa" class="csl-entry">
Boulesteix, Anne-Laure, Sabine Hoffmann, Alethea Charlton, and Heidi Seibold. 2020. <span>“A Replication Crisis in Methodological Research?”</span> <em>Significance</em> 17 (5): 18–21. <a href="https://doi.org/10.1111/1740-9713.01444">https://doi.org/10.1111/1740-9713.01444</a>.
</div>
<div id="ref-boulesteix2013Plea" class="csl-entry">
Boulesteix, Anne-Laure, Sabine Lauer, and Manuel J. A. Eugster. 2013. <span>“A Plea for Neutral Comparison Studies in Computational Sciences.”</span> <em>PLOS ONE</em> 8 (4): e61562. <a href="https://doi.org/10.1371/journal.pone.0061562">https://doi.org/10.1371/journal.pone.0061562</a>.
</div>
<div id="ref-boulesteix2017evidencebased" class="csl-entry">
Boulesteix, Anne-Laure, Rory Wilson, and Alexander Hapfelmeier. 2017. <span>“Towards Evidence-Based Computational Statistics: Lessons from Clinical Research on the Role and Design of Real-Data Benchmark Studies.”</span> <em>BMC Medical Research Methodology</em> 17 (1, 1): 1–12. <a href="https://doi.org/10.1186/s12874-017-0417-2">https://doi.org/10.1186/s12874-017-0417-2</a>.
</div>
<div id="ref-brown1974SmallSampleBehavior" class="csl-entry">
Brown, Morton B., and Alan B. Forsythe. 1974. <span>“The <span>Small Sample Behavior</span> of <span>Some Statistics Which Test</span> the <span>Equality</span> of <span>Several Means</span>.”</span> <em>Technometrics</em> 16 (1): 129–32. <a href="https://doi.org/10.1080/00401706.1974.10489158">https://doi.org/10.1080/00401706.1974.10489158</a>.
</div>
<div id="ref-Cho2023bivariate" class="csl-entry">
Cho, Hunyong, Chuwen Liu, John S Preisser, and Di Wu. 2023. <span>“A Bivariate Zero-Inflated Negative Binomial Model and Its Applications to Biomedical Settings.”</span> <em>Statistical Methods in Medical Research</em> 32 (7): 1300–1317. <a href="https://doi.org/10.1177/09622802231172028">https://doi.org/10.1177/09622802231172028</a>.
</div>
<div id="ref-davison1997BootstrapMethodsTheir" class="csl-entry">
Davison, A. C., and D. V. Hinkley. 1997. <em>Bootstrap Methods and Their Applications</em>. Cambridge: Cambridge University Press.
</div>
<div id="ref-dong2013PowerUpToolCalculating" class="csl-entry">
Dong, Nianbo, and Rebecca Maynard. 2013. <span>“<span><em>PowerUp</em></span><span><em>!</em></span> : <span>A Tool</span> for <span>Calculating Minimum Detectable Effect Sizes</span> and <span>Minimum Required Sample Sizes</span> for <span>Experimental</span> and <span>Quasi-Experimental Design Studies</span>.”</span> <em>Journal of Research on Educational Effectiveness</em> 6 (1): 24–67. <a href="https://doi.org/10.1080/19345747.2012.673143">https://doi.org/10.1080/19345747.2012.673143</a>.
</div>
<div id="ref-efron2000BootstrapModernStatistics" class="csl-entry">
Efron, Bradley. 2000. <span>“The Bootstrap and Modern Statistics.”</span> <em>Journal of the American Statistical Association</em> 95 (452): 1293–96. <a href="https://doi.org/10.2307/2669773">https://doi.org/10.2307/2669773</a>.
</div>
<div id="ref-faul2009StatisticalPowerAnalyses" class="csl-entry">
Faul, Franz, Edgar Erdfelder, Axel Buchner, and Albert-Georg Lang. 2009. <span>“Statistical Power Analyses Using <span>G</span>*<span>Power</span> 3.1: <span>Tests</span> for Correlation and Regression Analyses.”</span> <em>Behavior Research Methods</em> 41 (4): 1149–60. <a href="https://doi.org/10.3758/BRM.41.4.1149">https://doi.org/10.3758/BRM.41.4.1149</a>.
</div>
<div id="ref-friedman1988metamodel" class="csl-entry">
Friedman, Linda Weiser, and Israel Pressman. 1988. <span>“The Metamodel in Simulation Analysis: Can It Be Trusted?”</span> <em>Journal of the Operational Research Society</em> 39 (10): 939–48.
</div>
<div id="ref-fryda2014H2oInterfaceH2O" class="csl-entry">
Fryda, Tomas, Erin LeDell, Navdeep Gill, Spencer Aiello, Anqi Fu, Arno Candel, Cliff Click, et al. 2014. <span>“H2o: <span>R Interface</span> for the ’<span>H2O</span>’ <span>Scalable Machine Learning Platform</span>.”</span> Comprehensive R Archive Network. <a href="https://doi.org/10.32614/CRAN.package.h2o">https://doi.org/10.32614/CRAN.package.h2o</a>.
</div>
<div id="ref-gelman2013BayesianDataAnalysis" class="csl-entry">
Gelman, Andrew, John B. Carlin, Hal S. Stern, David B. Dunson, Aki Vehtari, and Donald B. Rubin. 2013. <em>Bayesian <span>Data Analysis</span></em>. 0th ed. <span>Chapman and Hall/CRC</span>. <a href="https://doi.org/10.1201/b16018">https://doi.org/10.1201/b16018</a>.
</div>
<div id="ref-gelman2002let" class="csl-entry">
Gelman, Andrew, Cristian Pasarica, and Rahul Dodhia. 2002. <span>“Let’s Practice What We Preach: Turning Tables into Graphs.”</span> <em>The American Statistician</em> 56 (2): 121–30.
</div>
<div id="ref-gilbert2024multilevel" class="csl-entry">
Gilbert, Joshua, and Luke Miratrix. 2024. <span>“Multilevel Metamodels: A Novel Approach to Enhance Efficiency and Generalizability in Monte Carlo Simulation Studies.”</span> <em>arXiv Preprint arXiv:2401.07294</em>.
</div>
<div id="ref-good2013permutation" class="csl-entry">
Good, Phillip. 2013. <em>Permutation Tests: A Practical Guide to Resampling Methods for Testing Hypotheses</em>. Springer Science &amp; Business Media.
</div>
<div id="ref-hunter2023PowerMultiplicityProject" class="csl-entry">
Hunter, Kristen B., Luke Miratrix, and Kristin Porter. 2024. <span>“PUMP: Estimating Power, Minimum Detectable Effect Size, and Sample Size When Adjusting for Multiple Outcomes in Multi-Level Experiments.”</span> <em>Journal of Statistical Software</em> 108 (6): 1–43. <a href="https://doi.org/10.18637/jss.v108.i06">https://doi.org/10.18637/jss.v108.i06</a>.
</div>
<div id="ref-james1951ComparisonSeveralGroups" class="csl-entry">
James, G. S. 1951. <span>“The Comparison of Several Groups of Observations When the Ratios of the Population Variances Are Unknown.”</span> <em>Biometrika</em> 38 (3/4): 324. <a href="https://doi.org/10.2307/2332578">https://doi.org/10.2307/2332578</a>.
</div>
<div id="ref-jones2012IntroductionScientificProgramming" class="csl-entry">
Jones, Owen, Robert Maillardet, and Andrew Robinson. 2012. <em>Introduction to <span>Scientific Programming</span> and <span>Simulation Using R</span></em>. New York: <span>Chapman and Hall/CRC</span>. <a href="https://doi.org/10.1201/9781420068740">https://doi.org/10.1201/9781420068740</a>.
</div>
<div id="ref-Kern_calibrated" class="csl-entry">
Kern, Holger L., Elizabeth A. Stuart, Jennifer Hill, and Donald P. Green. 2014. <span>“<span class="nocase">Assessing Methods for Generalizing Experimental Impact Estimates to Target Populations</span>.”</span> <em>Journal of Research on Educational Effectiveness</em> 9 (1): 103–27. <a href="https://doi.org/10.1080/19345747.2015.1060282">https://doi.org/10.1080/19345747.2015.1060282</a>.
</div>
<div id="ref-kleijnen1981regression" class="csl-entry">
Kleijnen, Jack PC. 1981. <span>“Regression Analysis for Simulation Practitioners.”</span> <em>Journal of the Operational Research Society</em> 32 (1): 35–43.
</div>
<div id="ref-lehmann1975statistical" class="csl-entry">
Lehmann, Erich Leo et al. 1975. <span>“Statistical Methods Based on Ranks.”</span> <em>Nonparametrics. San Francisco, CA, Holden-Day</em> 2.
</div>
<div id="ref-longUsingHeteroscedasticityConsistent2000" class="csl-entry">
Long, J. Scott, and Laurie H. Ervin. 2000. <span>“Using Heteroscedasticity Consistent Standard Errors in the Linear Regression Model.”</span> <em>The American Statistician</em> 54 (3): 217–24. <a href="https://doi.org/10.1080/00031305.2000.10474549">https://doi.org/10.1080/00031305.2000.10474549</a>.
</div>
<div id="ref-mehrotra1997ImprovingBrownforsytheSolution" class="csl-entry">
Mehrotra, Devan V. 1997. <span>“Improving the Brown-Forsythe Solution to the Generalized Behrens-Fisher Problem.”</span> <em>Communications in Statistics - Simulation and Computation</em> 26 (3): 1139–45. <a href="https://doi.org/10.1080/03610919708813431">https://doi.org/10.1080/03610919708813431</a>.
</div>
<div id="ref-miratrix2021applied" class="csl-entry">
Miratrix, Luke W., Michael J. Weiss, and Brit Henderson. 2021. <span>“An <span>Applied Researcher</span>’s <span>Guide</span> to <span>Estimating Effects</span> from <span>Multisite Individually Randomized Trials</span>: <span>Estimands</span>, <span>Estimators</span>, and <span>Estimates</span>.”</span> <em>Journal of Research on Educational Effectiveness</em> 14 (1): 270–308. <a href="https://doi.org/10.1080/19345747.2020.1831115">https://doi.org/10.1080/19345747.2020.1831115</a>.
</div>
<div id="ref-morris2019UsingSimulationStudies" class="csl-entry">
Morris, Tim P., Ian R. White, and Michael J. Crowther. 2019. <span>“Using Simulation Studies to Evaluate Statistical Methods.”</span> <em>Statistics in Medicine</em>, January. <a href="https://doi.org/10.1002/sim.8086">https://doi.org/10.1002/sim.8086</a>.
</div>
<div id="ref-pashley2024improving" class="csl-entry">
Pashley, Nicole E, Luke Keele, and Luke W Miratrix. 2024. <span>“Improving Instrumental Variable Estimators with Poststratification.”</span> <em>Journal of the Royal Statistical Society Series A: Statistics in Society</em>, qnae073.
</div>
<div id="ref-robert2010IntroducingMonteCarlo" class="csl-entry">
Robert, Christian, and George Casella. 2010. <em>Introducing <span>Monte Carlo Methods</span> with <span>R</span></em>. New York, NY: Springer. <a href="https://doi.org/10.1007/978-1-4419-1576-4">https://doi.org/10.1007/978-1-4419-1576-4</a>.
</div>
<div id="ref-siepe2024SimulationStudiesMethodological" class="csl-entry">
Siepe, Björn S., František Bartoš, Tim Morris, Anne-Laure Boulesteix, Daniel W. Heck, and Samuel Pawel. 2024. <span>“Simulation Studies for Methodological Research in Psychology: A Standardized Template for Planning, Preregistration, and Reporting,”</span> January. <a href="https://doi.org/10.31234/osf.io/ufgy6">https://doi.org/10.31234/osf.io/ufgy6</a>.
</div>
<div id="ref-staiger2010searching" class="csl-entry">
Staiger, Douglas O, and Jonah E Rockoff. 2010. <span>“Searching for Effective Teachers with Imperfect Information.”</span> <em>Journal of Economic Perspectives</em> 24 (3): 97–118.
</div>
<div id="ref-sundberg2003conditional" class="csl-entry">
Sundberg, Rolf. 2003. <span>“<span class="nocase">Conditional statistical inference and quantification of relevance</span>.”</span> <em>Journal of the Royal Statistical Society: Series B (Statistical Methodology)</em> 65 (1): 299–315.
</div>
<div id="ref-tipton2014stratified" class="csl-entry">
Tipton, Elizabeth. 2013. <span>“Stratified Sampling Using Cluster Analysis: A Sample Selection Strategy for Improved Generalizations from Experiments.”</span> <em>Evaluation Review</em> 37 (2): 109–39. <a href="https://doi.org/10.1177/0193841X13516324">https://doi.org/10.1177/0193841X13516324</a>.
</div>
<div id="ref-vevea1995general" class="csl-entry">
Vevea, Jack L, and Larry V Hedges. 1995. <span>“A General Linear Model for Estimating Effect Size in the Presence of Publication Bias.”</span> <em>Psychometrika</em> 60 (3): 419–35. <a href="https://doi.org/10.1007/BF02294384">https://doi.org/10.1007/BF02294384</a>.
</div>
<div id="ref-welch1951ComparisonSeveralMean" class="csl-entry">
Welch, B. L. 1951. <span>“On the Comparison of Several Mean Values: <span>An</span> Alternative Approach.”</span> <em>Biometrika</em> 38 (3/4): 330. <a href="https://doi.org/10.2307/2332579">https://doi.org/10.2307/2332579</a>.
</div>
<div id="ref-westfall2013understanding" class="csl-entry">
Westfall, Peter H, and Kevin SS Henning. 2013. <em>Understanding Advanced Statistical Methods</em>. Vol. 543. CRC Press Boca Raton, FL.
</div>
<div id="ref-White1980heteroskedasticity" class="csl-entry">
White, Halbert. 1980. <span>“A Heteroskedasticity-Consistent Covariance Matrix Estimator and a Direct Test for Heteroskedasticity.”</span> <em>Econometrica</em> 48 (4): 817–38.
</div>
<div id="ref-Wickham2014tidydata" class="csl-entry">
Wickham, Hadley. 2014. <span>“Tidy Data.”</span> <em>Journal of Statistical Software</em> 59 (10): 1–23. <a href="https://doi.org/10.18637/jss.v059.i10">https://doi.org/10.18637/jss.v059.i10</a>.
</div>
</div>
</div>
<div class="footnotes footnotes-end-of-document">
<hr />
<ol>
<li id="fn1"><p>A comment from James: I recall attending seminars in the statistics department during graduate school, where guest speakers usually presented both some theory and some simulation results. A few years into my graduate studies, I realized that the simulation part of the presentation could nearly always be replaced with a single slide that said “we did some simulations and showed that our new method works better than old methods under conditions that we have cleverly selected to be favorable for our approach.” I hope that my own work is not as boring or predictable as my memory of these seminars.<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p>To learn more about how R determines which values to use when executing a function, see <a href="https://adv-r.hadley.nz/functions.html#lexical-scoping">Section 6.4 of Advance R</a>.<a href="#fnref2" class="footnote-back">↩︎</a></p></li>
<li id="fn3"><p>The pipe is a relatively recent addition to R’s basic syntax. Prior to its inclusion in base R, the <code>magrittr</code> package provided—and still provides—a pipe symbol <code>%&gt;%</code> that works similarly but has some additional syntactic nuances. We use base R’s <code>|&gt;</code> because it is always available, even without loading any additional packages. To learn more about the nuanced <code>%&gt;%</code> pipe and similar operators, see <a href="https://magrittr.tidyverse.org/articles/magrittr.html">the magrittr package</a>.<a href="#fnref3" class="footnote-back">↩︎</a></p></li>
<li id="fn4"><p><a href="https://r4ds.hadley.nz/data-transform.html#sec-the-pipe">Chapter 3.4 of R for Data Science (2nd edition)</a> provides more discussion and examples of how to use <code>|&gt;</code>. <a href="https://r4ds.had.co.nz/pipes.html">Chapter 18 of R for Data Science (1st edition)</a> provides more discussion and examples of how to use <code>magrittr</code>’s <code>%&gt;%</code>.<a href="#fnref4" class="footnote-back">↩︎</a></p></li>
<li id="fn5"><p>Alternately, readers familiar with the <code>*apply()</code> family of functions from Base R might prefer to use <code>lapply()</code> or <code>sapply()</code>, which do essentially the same thing as <code>purrr::map_dbl()</code>.<a href="#fnref5" class="footnote-back">↩︎</a></p></li>
<li id="fn6"><p>You can also check out <a href="https://r4ds.had.co.nz/iteration.html#the-map-functions">Section 21.5 of R for Data Science (1st edition)</a>, which provides an introduction to mapping.<a href="#fnref6" class="footnote-back">↩︎</a></p></li>
<li id="fn7"><p><span class="citation">Wickham (<a href="#ref-Wickham2014tidydata">2014</a>)</span> provides a broader introduction to the concept of tidy data in the context of data-analysis tasks.<a href="#fnref7" class="footnote-back">↩︎</a></p></li>
<li id="fn8"><p>In the example from Chapter @ref(t-test-simulation), we used the <code>replicate()</code> function from base R to repeat the process of generating and analyzing data.
This function is a fine alternative to the <code>repeat_and_stack()</code> approach demonstrated in the skeleton.
The only drawback is that it requires some further work to combine the results across replications.
Here is a different version of the skeleton, which uses <code>replicate()</code> instead of <code>repeat_and_stack()</code>:</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb88-1"><a href="#cb88-1" tabindex="-1"></a>results_list <span class="ot">&lt;-</span> <span class="fu">replicate</span>(<span class="at">n =</span> R, <span class="at">expr =</span> {</span>
<span id="cb88-2"><a href="#cb88-2" tabindex="-1"></a>  dat <span class="ot">&lt;-</span> <span class="fu">generate_data</span>( params )</span>
<span id="cb88-3"><a href="#cb88-3" tabindex="-1"></a>  one_result <span class="ot">&lt;-</span> <span class="fu">analyze</span>(dat)</span>
<span id="cb88-4"><a href="#cb88-4" tabindex="-1"></a>  <span class="fu">return</span>(one_result)</span>
<span id="cb88-5"><a href="#cb88-5" tabindex="-1"></a>}, <span class="at">simplify =</span> <span class="cn">FALSE</span>)</span>
<span id="cb88-6"><a href="#cb88-6" tabindex="-1"></a></span>
<span id="cb88-7"><a href="#cb88-7" tabindex="-1"></a>results <span class="ot">&lt;-</span> purrr<span class="sc">::</span><span class="fu">list_rbind</span>(results_list)</span></code></pre></div>
<p>This version of the skeleton does not create a <code>one_run()</code> helper function, but instead puts the code from the body of <code>one_run()</code> directly into the <code>expr</code> argument of <code>replicate()</code>. To learn about other ways of repeatedly evaluating the simulation process, see Appendix @ref(repeating-oneself).<a href="#fnref8" class="footnote-back">↩︎</a></p></li>
<li id="fn9"><p>If you would prefer the output as a list rather than a stacked dataset, set <code>repeat_and_stack()</code>’s optional argument <code>stack = FALSE</code>.<a href="#fnref9" class="footnote-back">↩︎</a></p></li>
<li id="fn10"><p>This latter piece makes Brown and Forsythe’s study a prototypical example of a statistical methodology paper: find some problem that current procedures do not perfectly solve, invent something to do a better job, and then do simulations and/or math to build a case that the new procedure is better.<a href="#fnref10" class="footnote-back">↩︎</a></p></li>
<li id="fn11"><p>An alternative definition is based on the pooled standard deviation, but this is usually a bad choice if one suspects treatment variation. More treatment variation should not reduce the effect size for the same absolute average impact.<a href="#fnref11" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
<!--bookdown:body:end-->
            </section>

          </div>
        </div>
      </div>
<!--bookdown:link_prev-->
<!--bookdown:link_next-->
    </div>
  </div>
<!--bookdown:config-->

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
