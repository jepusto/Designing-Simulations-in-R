```{r, include=FALSE}
library( tidyverse )
library( blkvar )
```


# Coding tidbits {#on_functions}

This chapter is not about simulation, but does have a few tips and tricks regarding coding that are worth attending to.


## Ways of repeating yourself {#repeating_oneself}

There are several ways to call a bit of code (e.g., `one_run()` over and over).
We have seen `rerun()` before.
Another, more classic, way is to use an R function called `replicate`; `rerun()` and `replicate()` are near equivalents.
`replicate()` does what its name suggests---it replicates the result of an expression a specified number of times. The first argument is the number of times to replicate and the next argument is an expression (a short piece of code to run). A further argument, `simplify` allows you to control how the results are structured. Setting `simplify = FALSE` returns the output as a list (just like `rerun()`.
The following code produces four replications of our simulation:



## Default arguments for functions {#default_arguments}

To generate code both easy to use and configure, use default arguments.
For example,

```{r}
my_function = function( a = 10, b = 20 ) {
     100 * a + b
}

my_function()
my_function( 5 )
my_function( b = 5 )
my_function( b = 5, a = 1 )
```

We can still call `my_function()` when we don't know what the arguments are, but then when we know more about the function, we can specify things of interest.
Lots of R commands work exactly this way, and for good reason.

Especially for code to generate random datasets, default arguments can be a lifesaver as you can then call the method before you know exactly what everything means.

For example, consider the `blkvar` package that has some code to generate blocked randomized datasets.
We might locate a promising method, and type it in:

```{r, error=TRUE}
library( blkvar )
generate_blocked_data()
```

That didn't work, but let's provide some block sizes and see what happens:

```{r}
generate_blocked_data( n_k = c( 3, 2 ) )
```

Nice!  We see that we have a block ID and the control and treatment potential outcomes.  We also don't see a random assignment variable, so that tells us we probably need some other methods as well.
But we can play with this as it stands right away.

Next we can see that there are many things we might tune:
```{r}
args( generate_blocked_data )
```

The documentation will tell us more, but if we just need some sample data, we can quickly assess our method before having to do much reading and understanding.
Only once we have identified what we need do we have to turn to the documentation itself.



## Debugging with browser

Consider the code taken from a simulation:

```{r, eval=FALSE}
    if ( any( is.na( rs$estimate ) ) ) {
        browser()
    }
```

The `browser()` command stops your code and puts you in an interactive console where you can look at different objects and see what is happening.
Having it triggered when something bad happens (in this case when a set of estimates has an unexpected NA) can help untangle what is driving a rare event.

