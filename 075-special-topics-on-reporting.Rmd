---
output: html_document
editor_options: 
  chunk_output_type: console
---


```{r setup_exp_design_analysis, include=FALSE}
library( tidyverse )
library( purrr )
options(list(dplyr.summarise.inform = FALSE))
theme_set( theme_classic() )



### Code for one of the running examples
source( "case_study_code/clustered_data_simulation.R" )
source( "case_study_code/cronbach_alpha_simulation.R" )

res <- readRDS( file = "results/simulation_CRT.rds" )
res

sres <- 
  res %>% 
  group_by( n_bar, J, ATE, size_coef, ICC, alpha, method ) %>%
  summarise( 
    bias = mean(ATE_hat - ATE),
    SE = sd( ATE_hat ),
    RMSE = sqrt( mean( (ATE_hat - ATE )^2 ) ),
    ESE_hat = sqrt( mean( SE_hat^2 ) ),
    SD_SE_hat = sqrt( sd( SE_hat^2 ) ),
    power = mean( p_value <= 0.05 ),
    R = n(),
    .groups = "drop"
  )
sres

# 100 iterations per factor
summary( sres$R )
```

# Special Topics on Reporting Simulation Results

In this chapter we cover some special topics on reporting simulation results.
We first walk through some examples of how to do regression modeling.
We then dive more deeply into what to do when you have only a few iterations per scenario, and then we discuss what to do when you are evaluating methods that sometimes fail to converge or give an answer.


## Using regression to analyze simulation results

In Chapter \@ref(presentation-of-results) we saw some examples of using regression and ANOVA to analyze simulation results.
We next provide some further in-depth examples that give the code for doing this sort of thing.

### Example 1: Biserial, revisited

We first give the code that produced the final ANOVA summary table for the biserial correlation example in Chapter \@ref(presentation-of-results).
In the visualization there, we saw that several factors appeared to impact bias, but we might want to get a sense of how much.
Under modeling of that same chapter, we saw a table that partialed out the variance across several factors so we could see which simulation factors mattered most for bias.

To build that table, we first fit a regression model to see:

```{r, include=FALSE}
load("data/d2r results.rData")
allResults$n <- ordered(allResults$n)
allResults$p.inv <- allResults$p1
allResults$p1 <- ordered(allResults$p1, 
                labels = paste("p1 = 1/",unique(allResults$p1), sep=""))
allResults$fixed <- factor(allResults$fixed, levels=c("TRUE","FALSE"), 
                labels = c("Fixed percentiles","Sample percentiles"))

r_F <- allResults %>%
  filter(stat=="r.i" & design=="Extreme Group") %>%
  droplevels()
levels(r_F$fixed) <- c("Pop. cutoff","Sample cutoff")
r_F$bias <- r_F$mean - r_F$rho
r_F$bias.sm <- r_F$mean.sm - r_F$rho
r_F$rmse <- sqrt(r_F$bias^2 + r_F$var)
```

```{r modeling_demonstration, warning=FALSE}
options(scipen = 5)
mod = lm( bias ~ fixed + rho + I(rho^2) + p1 + n, data = r_F)
summary(mod, digits=2)
```

The above printout gives main effects for each factor, averaged across other factors.
Because `p1` and `n` are ordered factors, the `lm()` command automatically generates linear, quadradic, cubic and fourth order contrasts for them.
We smooth our `rho` factor, which has many levels of a continuous measure, with a quadratic curve.
We could instead use splines or some local linear regression if we were worried about model fit for a complex relationship.

The main effects are summaries of trends across contexts.
For example, averaged across the other contexts, the "sample cutoff" condition is around 0.004 lower than the population (the baseline condition).

We can also use ANOVA to get a sense of the major sources of variation in the simulation results (e.g., identifying which factors have negligible/minor influence on the bias of an estimator).
To do this, we use `aov()` to fit an analysis of variance model:

```{r anova_example, warning=FALSE}
anova_table <- aov(bias ~ rho * p1 * fixed * n, data = r_F)
summary(anova_table)
```

The advantage here is the multiple levels of our categorical factors get bundled together in our table of results, making a tidier display.

The table in Chapter \@ref(presentation-of-results) is a summary of this anova table, which we generate as follows:

```{r, warning=FALSE, eval=FALSE}
library(lsr)
etaSquared(anova_table) %>%
  as.data.frame() %>%
  rownames_to_column("source") %>%
  mutate( order = 1 + str_count(source, ":" ) ) %>%
  group_by( order ) %>%
  arrange( -eta.sq, .by_group = TRUE ) %>%
  relocate( order ) %>%
  knitr::kable( digits = 2 )
```

We group the results by the order of the interaction, so that we can see the main effects first, then two-way interactions, and so on.
We then sort within each group to put the high importance factors first.
The resulting variance decomposition table (see Chapter \@ref(presentation-of-results)) shows which factors are explaining how much of the variation.



### Example 2: Cluster RCT example, revisited

When we have several methods to compare, we can also use meta-regression to understand how these methods change as other simulation factors change.
We next continue our running Cluster RCT example.

We first turn our simulation levels (except for ICC, which has several levels) into factors, so R does not assume that sample size, for example, should be treated as a continuous variable:

```{r}
sres_f = sres %>%
  mutate( across( c( n_bar, J, size_coef, alpha ), factor ) )
sres_f$ICC = as.numeric( sres_f$ICC )

# Run the regression
M <- lm( bias ~ (n_bar + J + size_coef + ICC + alpha) * method, 
         data = sres_f )

# View the results
stargazer::stargazer(M, type = "text",
                     single.row = TRUE )
```

We can quickly generate a lot of regression coefficients, making our meta-regression somewhat hard to interpret.
The above model does not even have interactions of the simulation factors--which, given the found interactions from our plots, is a major concern!
That said, picking out the significant coefficients is a quick way to obtain a lot of clues as to what is driving performance.
E.g., several features interact with the LR method for bias.
The other two methods seem less impacted.


#### Using LASSO to simplify the model

<!-- LWM: Not sure if the following is completely off the rails.  Or what we want to say about modeling more broadly.  The Josh work also is in the background, possibly worth considering, about using random effects when number of simulations are few -->

We can simplify our model using LASSO regression, to drop coefficients that are less relevant.
This requires some work to make our model matrix of dummy variables with all the interactions.

```{r}
library(modelr)
library(glmnet)

# Define formula with all three-way interactions
form <- bias ~ ( n_bar + J + size_coef + ICC + alpha) * method

# Create model matrix
X <- model.matrix(form, data = sres_f)[, -1]  # drop intercept

# Fit LASSO
fit <- cv.glmnet(X, sres_f$bias, alpha = 1)

# Coefficients
coef(fit, s = "lambda.1se") %>%
  as.matrix() %>%
  as.data.frame() %>%
  rownames_to_column("term") %>%
  filter(abs(s0) > 0) %>%
  knitr::kable(digits = 3)
```

When using regression, and especially LASSO, which levels are baseline can impact the final results.
Here "Agg" is our baseline method, and so our coefficients are showing how other methods differ from the Agg method.
If we selected LR as baseline, then we might suddenly see Agg and MLM as having large coefficients.

One trick is to give dummy variables for all the methods, and overload the `method` factor with the baseline method, so that it is always the first level.
```{r}
form <- bias ~ 0 + ( n_bar + J + size_coef + ICC + alpha) * method
sres_f$method <- factor(sres_f$method)
vars = c("n_bar", "J", "size_coef", "alpha", "method")
contr.identity <- function(x) {
  n = nlevels(x)
  m <- diag(n)
  rownames(m) <- colnames(m) <- levels(x)

  m
}
contr.identity(sres_f$n_bar)
X <- model.matrix(~ 0 + ( n_bar + J + size_coef  + alpha) * method, 
                  data = sres_f,
                  contrasts.arg = lapply(sres_f[,vars], 
                                         \(x) contr.identity(x)))

colnames(X)
```

Now do the LASSO on this colinear mess:
```{r}
fit <- cv.glmnet(X, sres_f$bias, alpha = 1)
coef(fit, s = "lambda.1se") %>%
  as.matrix() %>%
  as.data.frame() %>%
  rownames_to_column("term") %>%
  filter(abs(s0) > 0) %>%
  knitr::kable(digits = 3)
```


We can also extend to allow for pairwise interactions of simulation factors:
```{r}
form2 <- bias ~ ( n_bar + J + size_coef + ICC + alpha)^2 * method
```

Interestingly, we get basically the same result:
```{r, echo=FALSE}
X2 <- model.matrix(form2, data = sres_f)[, -1]  # drop intercept
fit2 <- cv.glmnet(X2, sres_f$bias, alpha = 1)
coef(fit2, s = "lambda.1se") %>%
  as.matrix() %>%
  as.data.frame() %>%
  rownames_to_column("term") %>%
  filter(abs(s0) > 0) %>%
  knitr::kable(digits = 3)
```


#### Fitting models to each method
We know each method responds differently to the simulation factors, so we could fit three models, one for each method, and compare them.

```{r}
meth = c( "LR", "MLM", "Agg" )
models <- map( meth, function(m) {
  M <- lm( bias ~ (n_bar + J + size_coef + ICC + alpha)^2, 
      data = sres_f %>% filter( method == m ) )
  tidy( M )
} )
models <- models %>% set_names(meth) %>% 
  bind_rows( .id = "model" )

m_res <- models %>% 
  dplyr::select( model, term, estimate ) %>%
  pivot_wider( names_from="model", values_from="estimate" )

m_res %>%
  knitr::kable( digits = 2 )
```

Of course, this is a hard to read table.  We could instead plot, or use LASSO to simplify.


```{r}
m_resL <- m_res %>%
  pivot_longer( -term, 
                names_to = "model", values_to = "estimate" ) %>%
  mutate( term = factor(term, levels = unique(term)) ) %>%
  mutate( has_nbar = str_detect(term, "n_bar" ),
          has_J = str_detect(term, "J"),
          has_size_coef = str_detect(term, "size_coef"),
          has_ICC = str_detect(term, "ICC"),
          has_alpha = str_detect(term, "alpha") )

ggplot( m_resL,
        aes( x = term, y = estimate, 
             fill = model, group = model ) ) +
  facet_wrap( ~ has_nbar, scales="free_y" ) +
  geom_bar( stat = "identity", position = "dodge" ) +
  coord_flip()
```

Here we see how LR stands out, but also how MLM stands out under different simulation factor combinations.
Staring at this provides some understanding of how the methods are similar, and dissimilar.

For another example we turn to the standard error.
Here we regress $log(SE)$ onto the coefficients, and we rescale ICC to be on a 5 point scale to control it's relative coefficeint size to the dummy variables.
We regress $log(SE)$ and then exponentiate the coefficients to get the relative change in SE.
We can then interpret an exponentiated coefficient of, 0.64 for MLM for `n_bar80` as a 36% reduction of the standard error when we increase n_bar from the baseline of 20 to 80.

Here we make a plot like above, but with these relative changes:
```{r, echo=FALSE}
meth = c( "LR", "MLM", "Agg" )

sres_f$ICCsc = sres_f$ICC * 5 # rescale ICC to be on a 5 point scale
models <- map( meth, function(m) {
  M <- lm( log(SE) ~ (n_bar + J + size_coef + ICCsc + alpha)^2, 
      data = sres_f %>% filter( method == m ) )
  tidy( M ) %>%
    mutate( estimate =exp(estimate) - 1 )
} )
models <- models %>% set_names(meth) %>% 
  bind_rows( .id = "model" )

m_res <- models %>% 
  dplyr::select( model, term, estimate ) %>%
  pivot_wider( names_from="model", values_from="estimate" )

m_resL <- m_res %>%
  pivot_longer( -term, 
                names_to = "model", values_to = "estimate" ) %>%
  mutate( term = factor(term, levels = unique(term)) ) %>%
  mutate( has_nbar = str_detect(term, "n_bar" ),
          has_J = str_detect(term, "J"),
          has_size_coef = str_detect(term, "size_coef"),
          has_ICC = str_detect(term, "ICC"),
          has_alpha = str_detect(term, "alpha") )

ggplot( m_resL,
        aes( x = term, y = estimate, 
             fill = model, group = model ) ) +
  facet_wrap( ~ has_nbar, scales="free_y" ) +
  geom_bar( stat = "identity", position = "dodge" ) +
  geom_hline( yintercept = 0, linetype = "dashed" ) +
  labs( y = "Relative change in SE", 
        x = "Simulation factor" ) +
  scale_y_continuous(labels = scales::percent ) +
  coord_flip()
```

This clearly shows that the methods are basically the same in terms of uncertainty estimation.
We also see some interesting trends, such as the impact of `n_bar` declines when ICC is higher (see the interaction terms at rigth of plot).



## Using regression trees to find important factors

Sometimes with more complex experiments, where the various factors are interacting with each other in strange ways, it can be a bit tricky to decipher what is running what.
Another tool one might use to explore is to fit a regression tree on the simulation results.


```{r}
source( here::here( "code/create_analysis_tree.R" ) )
set.seed(4344443)
create_analysis_tree( sres_f,
                      outcome = "bias",
                      predictor_vars = c("method", "n_bar", "J",
                                         "size_coef", "ICC", "alpha"),
                      tree_title = "Cluster RCT Bias Analysis Tree" )
```

We will not walk through the tree code, but you can review it [here](code/create_analysis_tree.R).
This function is a wrapper of the `rpart` package.

The default pruning is based on a cross-fitting evaluation, and our sample size is not too terribly high (just the number of simulation scenarios fit).
Rerunning the code with a different seed can give a different tree.
In general, it might be worth forcibly simplifying the tree.
Trees are built greedily, so forcibly trimming often gives you the big things.
For example:

```{r}
create_analysis_tree( sres_f,
                      outcome = "bias",
                      predictor_vars = c("method", "n_bar", "J",
                                         "size_coef", "ICC", "alpha"),
                      tree_title = "Smaller Cluster RCT Bias Analysis Tree" )
```

A very straightforward story: if `size_coef` is not 0, we are using LR, and alpha is large, then we have large bias.

We can also zero in on specific methods to understand how they engage with the simulation factors, like so:

```{r}
create_analysis_tree( filter( sres_f, method=="LR" ),
                      outcome = "bias",
                      min_leaves = 4,
                      predictor_vars = c("n_bar", "J",
                                         "size_coef", "ICC", "alpha"),
                      tree_title = "Drivers of Bias for LR method" )
```

We force more leaves to get at some more nuance.
We again immediately see, for the LR method, that bias is large when we have non-zero size coefficient _and_ large alpha value.
Then, when $J$ is small, bias is even larger.

Generally we would not use a tree like this for a final reporting of results, but they can be important tools for _understanding_ your results, which leads to how to make and select more conventional figures for final reporting.


## Analyzing results with few iterations per scenario

When your simulation iterations are expensive to run (i.e., when each model fitting takes several minutes), then running thousands of iterations for many scenarios may no longer be computationally feasible.
In this case you will have very noisy estimates of estimator performance.

For a given scenario, if the methods being evaluated are substantially different, then even with a few iterations you may be able to demonstrate what you need to, but in general the Monte Carlo Standard Errors (MCSEs) may be so large that you will have a hard time telling if something is going on, or if it is just noise in the simulation itself.

One tool to handle this is aggregation: if you use visualization methods that average across scenarios, those averages will have more precise estimates of (average) performance.
Do not, by contrast, trust the bundling approaches--the MCSEs will make your boxes wider, and give the impression that there is more variation across scenarios than there really is.

Regression approaches can be particularly useful: the regressions will effectively average performance across scenario, and give summaries of overall trends.
You can even fit random effects regression, specifically accounting for the noise in the scenario-specific performance measures.
For more on this approach see @gilbert2024multilevel.

### Example: ClusterRCT with only 100 replicates per scenario

In the prior chapter we analyzed the results of our cluster RCT simulation with 1000 replicates per scenario.
But say we only had 100 per scenario.
Using the prior chapter as a guide, we recreate some of the plots to show how MCSE can distort the picture of what is going on.

First, we look at our single plot of the raw results.
Before we plot, however, we calculate MCSEs and add them to the plot as error bars.

```{r}
sres_sub <- sres %>%
  filter( n_bar == 320, J == 20 ) %>%
  mutate( bias.mcse = SE / sqrt( R ) )
ggplot( sres_sub, aes( as.factor(alpha), bias, 
                       col=method, pch=method, group=method ) ) +
  facet_grid( size_coef ~ ICC, labeller = label_both ) +
  geom_point() + 
  geom_errorbar( aes( ymin = bias - 2*bias.mcse, 
                      ymax = bias + 2*bias.mcse ), 
                 width = 0 ) +
  geom_line() +
  geom_hline( yintercept = 0 ) +
  theme_minimal() 
```

Aggregation should smooth out some of our uncertainty.
When we aggregate across 9 scenarios, our number of replicates goes from 100 to 900; our MCSEs should be about a third the size.
Here is our aggregated bias plot:

```{r}
sres_sub2 <- sres %>%
  mutate( bias.mcse = SE / sqrt( R ) ) %>%
  group_by( n_bar, J ) %>%
  summarise( bias = mean( bias ),
             bias.mcse = sqrt( mean( bias.mcse^2 )) / sqrt(n()),
             .groups = "drop" )

ggplot( sres_sub, aes( as.factor(alpha), bias, 
                       col=method, pch=method, group=method ) ) +
  facet_grid( size_coef ~ ICC, labeller = label_both ) +
  geom_point() + 
  geom_errorbar( aes( ymin = bias - 2*bias.mcse, 
                      ymax = bias + 2*bias.mcse ), 
                 width = 0 ) +
  geom_line() +
  geom_hline( yintercept = 0 ) +
  theme_minimal() 

```

To get aggregate MCSE, we aggregate our scenario-specific MCSEs as follows:
$$ MCSE_{agg} = \sqrt{ \frac{1}{K^2} \sum_{k=1}^{K} MCSE_k^2 } $$

where $MCSE_i$ is the Monte Carlo Standard Error for scenario $i$, and $k$ is the number of scenarios.
Assuming a collection of estimates are independent, the overall $SE^2$ of the average is the average $SE^2$ divided by $K$.

Even with the additional replicates per point, we see noticable noise in our plot.
Note how our three methods track each other up and down in the zero-bias scenarios, giving a sense of a shared bias in some cases.
This is because all methods are analyzing the same set of datasets; they have shared uncertainty.
This uncertainty can be deceptive.
It can also be a boon: if we are explicitly comparing the performance of one method vs another, the shared uncertainty can be subtracted out, similar to having a blocked experiment @gilbert2024multilevel.

Here we fit a multilevel model to the data.

```{r}
library(lme4)
sub_res = filter( res, runID <= 100 ) %>%
  mutate( error = ATE_hat - ATE,
          simID = paste0( n_bar, "_", J, "_", size_coef, "_", ICC, "_", alpha ),
          J = as.factor(J),
          n_bar = as.factor(n_bar),
          alpha = as.factor(alpha),
          size_coef = as.factor(size_coef) )

M <- lmer( error ~ method*(J + n_bar + ICC + alpha + size_coef) + (1|runID) + (1|simID),
           data = sub_res )
arm::display(M)
```

We can look at the random effects:
```{r}
ranef_vars <- as.data.frame(VarCorr(M)) %>%
  dplyr::select(grp = grp, sd = vcov) %>%
  mutate( sd = sqrt(sd),
          ICC = sd^2 / sum(sd^2 ) )

knitr::kable(ranef_vars, digits = 2)
```

The above model is a multilevel model that allows us to estimate how bias varies with method and simulation factor, while accounting for the uncertainty in the simulation.
The random variation for `simID` captures unexplained variation due to the interactions of the simulation factors.  We see a large value, indicating that many interactions are present, and our main effects are not fully capturing all trends.




## Analyzing results when some trials have failed

If the method you are evaluating sometimes fail, then when they tend to fail is something to investigate in its own right.
Ideally, failure would not be too common, meaning we could drop those trials, or keep them, without really impacting our overall results.
But one should at least know what one is ignoring.

For example, in our cluster RCT running example, we know that our multilevel model, at least sometimes, has convergence issues.
We also know that ICC is an important driver of when these convergence issues might occur, so we can explore how often we get a convergence message by ICC level:

```{r examine_convergence_rates}
res %>% 
  group_by( method, ICC ) %>%
  summarise( message = mean( message ) ) %>%
  pivot_wider( names_from = "method", values_from="message" )
```

We see that when the ICC is 0 we get a lot of convergence issues, but as soon as we pull away from 0 it drops off considerably.
At this point we might decide to drop those runs with a message or keep them.
In this case, we decide to keep.
It should not matter much, except possibly when ICC = 0, and we know the convergence issues are driven by trying to estimate a 0 variance, and thus is in some sense expected.
Furthermore, we know people using these methods would likely ignore these messages, and thus we are faithfully capturing how these methods would be used in practice.
We might eventually, however, want to do a separate analysis of the ICC = 0 context to see if the MLM approach is actually falling apart, or if it is just throwing warnings.






